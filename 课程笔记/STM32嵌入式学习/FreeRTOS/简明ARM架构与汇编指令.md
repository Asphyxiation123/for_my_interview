# 代码底层实现方式
在 CPU 中至少要有六类寄存器：指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）、数据寄存器（DR）、累加寄存器（AC）、程序状态字寄存器（PSW）。
## 1. 数据寄存器
数据寄存器（Data Register，DR）又称数据缓冲寄存器，其主要功能是作为 CPU 和主存、外设之间信息传输的中转站，用以弥补 CPU 和主存、外设之间操作速度上的差异。

数据寄存器用来暂时存放由主存储器读出的一条指令或一个数据字；反之，当向主存存入一条指令或一个数据字时，也将它们暂时存放在数据寄存器中。

数据寄存器的作用是 ：

（1）作为 CPU 和主存、外围设备之间信息传送的中转站；

（2）弥补 CPU 和主存、外围设备之间在操作速度上的差异；

（3）在单累加器结构的运算器中，数据寄存器还可兼作操作数寄存器。

## 2.  指令寄存器
指令寄存器（Instruction Register，IR）用来保存当前正在执行的一条指令。

当执行一条指令时，首先把该指令从主存读取到数据寄存器中，然后再传送至指令寄存器。

指令包括操作码和地址码两个字段，为了执行指令，必须对操作码进行测试，识别出所要求的操作，指令译码器（Instruction Decoder，ID）就是完成这项工作的。指令译码器对指令寄存器的操作码部分进行译码，以产生指令所要求操作的控制电位，并将其送到微操作控制线路上，在时序部件定时信号的作用下，产生具体的操作控制信号。

指令寄存器中操作码字段的输出就是指令译码器的输入。操作码一经译码，即可向操作控制器发出具体操作的特定信号。

## 3. 程序计数器
**程序计数器（Program Counter，PC）用来指出下一条指令在主存储器中的地址。**
在程序执行之前，首先必须将程序的首地址，即程序第一条指令所在主存单元的地址送入 PC，因此 PC 的内容即是从主存提取的第一条指令的地址。
当执行指令时，CPU 能自动递增 PC 的内容，使其始终保存将要执行的下一条指令的主存地址，为取下一条指令做好准备。若为单字长指令，则 (PC)+1àPC，若为双字长指令，则 (PC)+2àPC，以此类推。
但是，当遇到转移指令时，下一条指令的地址将由转移指令的地址码字段来指定，而不是像通常的那样通过顺序递增 PC 的内容来取得。
因此，程序计数器的结构应当是具有寄存信息和计数两种功能的结构。

## 4.   地址寄存器
地址寄存器（Address Register，AR）用来保存 CPU 当前所访问的主存单元的地址。
由于在主存和 CPU 之间存在操作速度上的差异，所以必须使用地址寄存器来暂时保存主存的地址信息，直到主存的存取操作完成为止。
当 CPU 和主存进行信息交换，即 CPU 向主存存入数据/指令或者从主存读出数据/指令时，都要使用地址寄存器和数据寄存器。
如果我们把外围设备与主存单元进行统一编址，那么，当 CPU 和外围设备交换信息时，我们同样要使用地址寄存器和数据寄存器。

## 5.   累加寄存器
累加寄存器通常简称累加器（Accumulator，AC），是一个通用寄存器。
累加器的功能是：当运算器的算术逻辑单元 ALU 执行算术或逻辑运算时，为 ALU 提供一个工作区，可以为 ALU 暂时保存一个操作数或运算结果。
显然，运算器中至少要有一个累加寄存器。

## 6.   程序状态字寄存器
程序状态字（Program Status Word，PSW）用来表征当前运算的状态及程序的工作方式。
程序状态字寄存器用来保存由算术/逻辑指令运行或测试的结果所建立起来的各种条件码内容，如运算结果进/借位标志（C）、运算结果溢出标志（O）、运算结果为零标志（Z）、运算结果为负标志（N）、运算结果符号标志（S）等，这些标志位通常用 1 位触发器来保存。
除此之外，程序状态字寄存器还用来保存中断和系统工作状态等信息，以便 CPU 和系统及时了解机器运行状态和程序运行状态。
因此，程序状态字寄存器是一个保存各种状态条件标志的寄存器。

# 常用汇编指令
- 读内存: load - `LDR`
```Assembly
LDR R0,  [R1,#4]   ; 读地址"R1+4"，得到4字节数据存入R0
```
- 写内存 Store - `STR`
```
STR R0, [R1,#4]  ； 把寄存器R0的4字节数据写入地址“R1+4”
STRBH ; 写1Byte
STRH  ; 写2个字节(半字（word）)
```
- MOV
将后面的数值放到前面的地址里
```
MOV  r1, #1
MOVS r0 , r4
```
- 加减
```
ADD R0， R1，R2 ； R0 = R1+R2
ADD R0， R0，#1 ； R0 = R0+1
SUB R0， R1，R2 ； R0 = R1-R2
SUB R0， R0，#1 ； R0 = R1-1
```
-  比较 `CMP`
```
CMP R0,R1 ;
```
- 跳转-**实现程序跳转，也就是调用子程序**
```
B main;  Branch,直接跳转
BL main ; Branch and link先把返回地址保存在LR寄存器里再跳转
```
> BL - 返回命令地址并链接到下一条指令

b 与 bl 指令的区别：
	- b 指令：简单的程序跳转，跳转到到目标标号处执行。
	- bl 指令：带链接程序跳转，也就是要带返回地址。在发生跳转前，将当前 PC-4保存到 R14中。也就是返回地址存在R14中，所以可以在子程序返回时只要`MOV PC, LR`即可。


## 汇编使用实例
```asm
BL  add  ；0x8002f***
```
调用
局部变量都会保存在栈里
```C
```
C 函数汇编代码原型
![[局部变量储存.png]]
**函数结束，弹出**
![[Pasted image 20231101155137.png]]

# 堆与栈
## 堆的概念与堆管理
堆--自行可分配空间
一般来说，内存管理函数会使用链表来对内存进行分配

全局链表 `g_heap` 可定义为
```C
struct myheao g_heap ={0,RAM_head}
```
其中的 `myheap` 定义为
```C
struct myheap
{
	int size;//分配内存大小
	void * next_free;//下一段分配内存的地址
}
```
之后，每用 `my_malloc` 分配一段内存，将在内存中同时记录一个头大小，并将全局变量 `myheap` 的内存指针指向新空余内存首地址
![[内存分配原理.png]]

那么释放内存函数 `my_free(buf)`，则是直接将空闲块的空闲指针 `next_free` 指向将要释放的内存空间
![[Pasted image 20231101165954.png]]
## 栈概念-函数调用
栈：也是一块内存空间，CPU 的 SP 寄存器指向它，可以用于函数调用、局部变量等
BL 功能：记录 LR 地址跳转后将继续执行 BL 之下的指令，跳转函数（PC 寄存器指向将要调用函数的地址）
在 C 语言的关键入口，都会通过 `PUSH` 指令保存必要的

## 局部变量
未加 `volatile`，则是放在内存里，否则则放入栈中；放入内存中是编译器优化的结果
## RTOS 如何使用栈
![[Pasted image 20231101201232.png]]
在任务 A 的结构体中记录 SP
在恢复 A 时：找到 A 结构体中的栈
## 堆与栈的区别
堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：
- （1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；
- （2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小64bits的Windows默认1M，64bits的Linux默认10M；
- （3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。
- （4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。
- （5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。
- （6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内存（eip），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（ebp），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是调用函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。

从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。