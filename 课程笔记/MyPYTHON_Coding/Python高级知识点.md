# Python 函数相关
## 参数引用
如果传递的变量类型是数值、字符串、布尔等类型，那么就是值传递，如果传递的变量类型是序列、对象（后面的章节介绍）等复合类型，就是引用传递。


# Python 特性
## 列表推理式（List Comprehension）
 列表推理式（List Comprehension）是 Python 中一种简洁的创建列表的方法，它使用一个表达式和一个 for 循环来生成新的列表。列表推理式的主要优点是简洁、易读，可以快速生成一个新列表。

列表推理式的语法如下：
```python
[表达式 for 变量 in 可迭代对象 if 条件]
```

其中，`表达式` 是用于生成新元素的函数，`变量` 是迭代对象中的元素，`条件` 是过滤元素的条件。

例如，假设我们有一个整数列表 `numbers`，我们想要创建一个新的列表，其中包含 `numbers` 中所有偶数元素：

```python
numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 使用列表推理式创建新的列表
even_numbers = [num for num in numbers if num % 2 == 0]

print(even_numbers)  # 输出：[2, 4, 6, 8]
```

在这个例子中，我们使用了列表推理式来创建一个名为 `even_numbers` 的新列表，其中包含 `numbers` 中所有偶数元素。列表推理式中的表达式是 `num`，迭代对象是 `numbers`，条件是 `num % 2 == 0`，用于过滤出偶数元素。

列表推理式可以用于创建各种类型的列表，如数字列表、字符串列表等。它是一种非常有用的工具，可以帮助我们快速生成新列表。

## 装饰器
 Python 装饰器是一种用于扩展函数功能的编程技巧。装饰器本质上是一个接受函数作为参数的高阶函数, 并返回一个经过增强或修改后的函数。装饰器的主要作用是在不修改原始函数代码的基础上, 为其添加新的功能。

下面是一个简单的 Python 装饰器示例:

```python
def my_decorator(func):
    def wrapper():
        print("在原始函数执行之前做一些操作")
        func()
        print("在原始函数执行之后做一些操作")
    return wrapper

@my_decorator
def my_function():
    print("这是原始函数")

my_function()
```

在这个示例中, 我们定义了一个名为 `my_decorator` 的装饰器, 它接受一个函数 `func` 作为参数, 并定义了一个内部函数 `wrapper`。在 `wrapper` 函数中, 我们首先打印一条消息, 然后调用原始函数 `func`,最后再打印另一条消息。最后, 我们将 `wrapper` 函数作为返回值, 将其赋值给原始函数 `my_function`。

通过在 `my_function` 前加上 `@my_decorator` 装饰器, 我们实际上将 `my_decorator` 装饰器应用到了 `my_function` 上。当我们调用 `my_function()` 时, 实际上是在调用 `my_decorator` 内部的 `wrapper` 函数, 从而实现对原始函数的增强或修改。
>从函数指针的角度来理解，`decorator` 里的函数是具体实现，而原函数的参数是函数指针，调用装饰器内的函数时便是将原函数函数指针指向所调用的装饰器内函数。

装饰器在 Python 中非常灵活和强大, 可以用于实现各种功能, 例如日志记录、性能测试、用户身份验证等。
