# 1 命名空间 (namespace)
## 1.1 背景即作用  
背景：在 C/C++中，变量、函数和类都是大量存在的，如果不特殊声明，那么这些变量、函数和类的名称都将作用于全局作用域中。
动机：引入命名空间前，，一方面语义上比较混乱，不易管理阅读，另一方面也可能会导致很多命名冲突，因为通常情况下，这里用了 xxx 这个命名，那么其他地方就不能用了。
作用：使用命名空间的目的就是为了解决以上问题， C++中使用 namespace 这个关键字来操作命名空间， 当你的 C++项目越来越大的时候， 非常有必要使用 namespace 。
note：一个命名空间就定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中。
```C++
／／1．普通的命名空间，里面可以定义变量，也可以定义函数 namespace Panda {
	int height=1;
	int weight =100;
	int eat (int a, int b){
		return a+b;
	}
}
namespace pig {
	int height=1;
	int weight =100;
	int eat (int a, int b){}
		return a+b;
	}
}
```


## 1.2 使用命名空间
![[命名空间使用.png]]
# 2. 对象

## 多态
### 虚函数
一句话说明虚函数的使用场景：父类决定调用时机/调用方式，子类决定具体实现。如：
```C++
class father
{
public:
	void clock_8() //每天8点钟的时候
	{
		//执行穿衣函数
		dress();
	}
	//穿衣函数，是个纯虚函数，具体实现在子类中实现
	//这样，父类就决定了，这个穿衣函数的调用时机
	virtual void dress() = 0;
};

class child1 : public father
{
public:
	//子类决定了，穿衣函数的具体实现
	virtual void dress() 
	{
		cout << "穿红衣服" << endl;
	}
};

int main()
{
	child1 c;
	//这样子类，每天起床时，都会调用，穿衣服
	c.clock_8();
	return 0;
}
```
# 内存分配相关
## 为什么要进行动态内存分配
- 答 1：因为内存太宝贵。
- 答 2：如果全部是静止内存不能释放，对于小的程序可以运行完毕。但是对于大的程序，还没运行完，内存就要被占用完，此时就要发生内存泄露。
- 答 3：给定一个占用内存可变大小的变量（假设是数组的长度 len），给该变量通过函数动态分配内存后，分配内存的大小是根据数组的长度 len 决定的，假定用户输入 len 的大小是 5，系统就会动态的给该数组分配长度为 5 的内存，该段代码运行结束后，系统调用 free ()函数释放分配的内存，然后接着运行剩下的程序。换句话说，动态分配内存可以根据需要去申请内存，用完后就还回去，让需要的程序用。
## 什么时候需要动态内存分配
答：当程序中有比较大的数据块需要使用内存的时候使用。原因：比较大的数据块如果使用了静态内存，在该数据块运行完毕后不能动态的释放该内存，直到整个程序运行完才能释放，如果整个程序比较大，有可能因为内存不够而发生错误。
## 不可以在该静态分配的内存使用完后，使用 free()函数释放吗？
答：不可以，首先 malloc() 函数和 free()函数必须是配套使用，其次 free()函数不能释放普通变量，只能释放指针。
## 什么时候需要动态内存分配
答：什么时候我们需要动态分配内存空间呢？举一个例子吧。`Int *p`；我们定义了一个指向 `int` 类型的指针 p；p 是用来储存一个地址的值的，我们之所以要为 p 这个变量分配空间是让它有一个明确的指向，打个比方吧！你现在做好了一个指向方向的路标，但是你并没有让这个路标指向一个确切的方位，也就是说现在的这个路标是瞎指向的，这样我们就不能够通过它来明确到底哪里是东，哪里是西，何为北，何为南了。虽然我们在计算机的内存里定义了一个指针变量，但是我们并没有让这个变量指示一个确切 int 类型变量的地址，所以我们就必须要让它有一个明确的指示方向。这样我们就要通过动态分配内存的方式来认为的规定它的方向！
### 计算机内存的四大区域：栈区，常量区，全局区，堆区（动态分配）
- 栈区：在栈里面储存一些我们定义的局部变量以及形参；
- 常量区：主要是储存一些字符常量；
- 全局区：在全局区里储存一些全局变量和静态变量；
- 堆：堆主要是通过动态分配的储存空间；

例子：数组的动态内存分配
```C++
#include<stdio.h>
#include<malloc.h>
int main()
{
	int len;//定义数组的长度
	int *pArr=(int *)malloc(sizeof(int)*len);
	for(int i=0;i<len;++i)
		scanf("%d"\n,&pArr[i]);
	for(i=0;i<len;++i)
		printf("%d\n",*(pArr+i));
    free(pArr);  //pArr指向数组的首地址
    pArr = NULL;
    /*...
    剩余代码
    ...*/
	return 0;
}
```

## 问 ：为什么 malloc 函数前面需要 `int *`的强制转换？

答：因为程序需要告诉编译器 malloc 函数返回值的第一个字节是 `int *`类型的还是其他类型的。

1: 代码中的 malloch 函数分配内存，在该段代码运行完后，通过 free ()函数释放，被释放的内存空间留着可以被剩余代码接着利用。
2: 同时当我们使用`malloc ()`函数的时候还应该注意当我们释放完空间的时候还要将原先的指针变量赋予一个 NULL，也就是赋予一个空指针，留着下次的时候使用它！如果我们不赋予|NULL 行不行呢？？答案是：不行的！如果我们不赋予一个空指针这样会导致原先的指针变量成为了一个野指针，何谓野指针？野指针就是一个没有明确指向的指针，系统不知道它会指向什么地方，野指针是很危险的，因此当我们每次使用完 malloc ()函数的时候都必须将指针赋予一个空指针！
## C++语法
### （1）变量申请：
```C++
Type* pointer = new Type;
//...
delete pointer;
```
  表达式用于分配内存以包含一个类型类型的单个元素。

### （2）数组申请 ：
```C++
Type* pointer = new Type[N];
//...
delete[] pointer;
```
表示用于分配类型类型的元素的块（数组），其中N是表示这些元素的量的整数值。
