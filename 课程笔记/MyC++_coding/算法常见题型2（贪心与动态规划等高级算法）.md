# 1. 贪心算法
##  分发饼干
![[Pasted image 20231112162552.png]]

```C++
// 版本一
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int index = s.size() - 1; // 饼干数组的下标
        int result = 0;
        for (int i = g.size() - 1; i >= 0; i--) { // 遍历胃口
            if (index >= 0 && s[index] >= g[i]) { // 遍历饼干
                result++;
                index--;
            }
        }
        return result;
    }
};
```

## 摆动数组
![[Pasted image 20240406154658.png]]
### 贪心解法
关键在于，判断出现转折的地方，当 diff 出现变化的时候便为出现转折。
关键在于 `prediff` 之后在出现转折时更新，否则不更新
```C++
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int result = 1;  // 记录峰值个数，序列默认序列最右边有一个峰值
        for (int i = 0; i < nums.size() - 1; i++) {
            curDiff = nums[i + 1] - nums[i];
            // 出现峰值
            if ((preDiff <= 0 && curDiff > 0) || (preDiff >= 0 && curDiff < 0)) {
                result++;
                preDiff = curDiff; // 注意这里，只在摆动变化的时候更新prediff
            }
        }
        return result;
    }
};
```


## 最大子序列和
###   贪心解法

**贪心贪的是哪里呢？**

如果 -2 1 在一起，计算起点的时候，一定是从 1 开始计算，因为负数只会拉低总和，这就是贪心贪的地方！

局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素 “连续和”只会越来越小。

全局最优：选取最大“连续和”

**局部最优的情况下，并记录最大的“连续和”，可以推出全局最优**。

>从代码角度上来讲：遍历 nums，从头开始用 count 累积，如果 count 一旦加上 nums[i]变为负数，那么就应该从 nums[i+1]开始从 0 累积 count 了，因为已经变为负数的 count，只会拖累总和。

**这相当于是暴力解法中的不断调整最大子序和区间的起始位置**。
**区间终止位置不用调整么？ 如何才能得到最大“连续和”呢？**
区间的终止位置，其实就是如果 count 取到最大值了，及时记录下来了。例如如下代码：
```C
if (count > result) result = count;
```

**这样相当于是用 result 记录最大子序和区间和（变相的算是调整了终止位置）**。
如动画所示：

![53.最大子序和](https://code-thinking.cdn.bcebos.com/gifs/53.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C.gif)

红色的起始位置就是贪心每次取 count 为正数的时候，开始一个区间的统计。
解法如下

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int count = 0,result = INT32_MIN;
        for(int i =0 ; i<nums.size();i++){
            count+=nums[i];//不断累加
            result = count>result?count:result;//取区间最大值
            if(count<=0) count = 0;//重制最大子序列的起始位置，贪心避免取到负值
        }
        return result;
    }
};

```


- 时间复杂度：O(n)
- 空间复杂度：O(1)

当然题目没有说如果数组为空，应该返回什么，所以数组为空的话返回啥都可以了。

### 常见误区

误区一：

不少同学认为 如果输入用例都是-1，或者 都是负数，这个贪心算法跑出来的结果是 0， 这是**又一次证明脑洞模拟不靠谱的经典案例**，建议大家把代码运行一下试一试，就知道了，也会理解 为什么 result 要初始化为最小负数了。

误区二：
大家在使用贪心算法求解本题，经常陷入的误区，就是分不清，是遇到负数就选择起始位置，还是连续和为负选择起始位置。

在动画演示用，大家可以发现， 4，遇到 -1 的时候，我们依然累加了，为什么呢？
因为和为 3，只要连续和还是正数就会 对后面的元素 起到增大总和的作用。 所以只要连续和为正数我们就保留。

这里也会有录友疑惑，那 4 + -1 之后 不就变小了吗？ 会不会错过 4 成为最大连续和的可能性？

其实并不会，因为还有一个变量 result 一直在更新 最大的连续和，只要有更大的连续和出现，result 就更新了，那么 result 已经把 4 更新了，后面 连续和变成 3，也不会对最后结果有影响。

## 移掉 K 位数字
![[Pasted image 20240323205657.png]]
### 贪心策略
若要使得剩下的数字最小，需要保证靠前的数字尽可能小。
给定一个长度为 $n$ 的数字序列 $[D_0D_1D_2D_3\ldots D_{n-1}]$ ,从左往右找到第一个位置 $i\left(i>0\right)$ 使得 $D_i<D_{i-1}$,并删去 $D_{i-1};$ 如果不存在，说明整个数字序列单调不降，删去最后一个数字即可。
因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到
- 栈为空
- 或者新的栈顶元素不大于当前数字
- 或者我们已经删除了 k 位数字
### 单调栈+贪心
```C++
class Solution {
public:
    string removeKdigits(string num, int k) {
        vector<char> stk;
        for (auto& digit: num) {
            while (stk.size() > 0 && stk.back() > digit && k) {
                stk.pop_back();
                k -= 1;
            }
            stk.push_back(digit);
        }

        for (; k > 0; --k) {
            stk.pop_back();
        }

        string ans = "";
        bool isLeadingZero = true;
        for (auto& digit: stk) {
            if (isLeadingZero && digit == '0') {
                continue;
            }
            isLeadingZero = false;
            ans += digit;
        }
        return ans == "" ? "0" : ans;
    }
};
```
## 跳跃游戏
![[Pasted image 20240413205643.png]]
思路：
```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
};

```
## 跳跃游戏 2
![[Pasted image 20240413204126.png]]
思路：每次跳的范围 `[left,right]`，初始为 `[0，0]`，使用 `rightmost` 变量实时记录能够到达的最右的点。
```C++
class Solution {
public:
    int jump(vector<int>& nums) {
        int n = nums.size();
        if(n == 1) return 0;
        int rightmost = 0,left = 0,right = 0;
        int cnt = 0;
        while(rightmost<n-1){
            
            for(int i = left; (i<=right) && (i<n); i++){
                // cout<<i<<", "<<rightmost<<endl;
                rightmost = max(nums[i]+i,rightmost);
            }
            left = right;
            right = rightmost;
            // cout<<rightmost<<endl;
            cnt++;
        }
        return cnt;
    }
};
```

## K 次取反后最大化的数组和
![[Pasted image 20240502181121.png]]
贪心策略：先解决所有负数的转正，再处理最后绝对值最小的值由正转负。
```C++
class Solution {
static bool cmp(int a, int b) {
    return abs(a) > abs(b);
}
public:
    int largestSumAfterKNegations(vector<int>& A, int K) {
        sort(A.begin(), A.end(), cmp);       // 第一步
        for (int i = 0; i < A.size(); i++) { // 第二步
            if (A[i] < 0 && K > 0) {
                A[i] *= -1;
                K--;
            }
        }
        if (K % 2 == 1) A[A.size() - 1] *= -1; // 第三步
        int result = 0;
        for (int a : A) result += a;        // 第四步
        return result;
    }
};
```
## 加油站
![[Pasted image 20240502221027.png]]
可以换一个思路，首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量`rest[i]`相加一定是大于等于零的。

每个加油站的剩余量`rest[i]为gas[i] - cost[i]`。

i从0开始累加`rest[i]`，和记为`curSum`，一旦curSum小于零，说明`[0, i]`区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。

如图：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230117165628.png)

那么为什么一旦`[0，i]` 区间和为负数，起始位置就可以是i+1呢，i+1后面就不会出现更大的负数？
如果出现更大的负数，就是更新i，那么起始位置又变成新的i+1了。
那有没有可能 `[0，i]` 区间 选某一个作为起点，累加到 i这里 curSum是不会小于零呢？ 如图：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230117170703.png)

如果 curSum<0 说明 区间和1 + 区间和2 < 0， 那么 假设从上图中的位置开始计数curSum不会小于0的话，就是 区间和2>0。

区间和1 + 区间和2 < 0 同时 区间和2>0，只能说明区间和1 < 0， 那么就会从假设的箭头初就开始从新选择其实位置了。

**那么局部最优：当前累加`rest[i]`的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置**。

局部最优可以推出全局最优，找不出反例，试试贪心！

C++代码如下：

```C++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int curSum = 0;
        int totalSum = 0;
        int start = 0;
        for (int i = 0; i < gas.size(); i++) {
            curSum += gas[i] - cost[i];
            totalSum += gas[i] - cost[i];
            if (curSum < 0) {   // 当前累加rest[i]和 curSum一旦小于0
                start = i + 1;  // 起始位置更新为i+1
                curSum = 0;     // curSum从0开始
            }
        }
        if (totalSum < 0) return -1; // 说明怎么走都不可能跑一圈了
        return start;
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(1)

**说这种解法为贪心算法，才是有理有据的，因为全局最优解是根据局部最优推导出来的**。


## 划分字母区间
![[Pasted image 20240504174830.png]]
### 解题思路
1. 先统计各个字符的最右端位置，因为依据题意，划分区间至少得保证所有字母包括在同一区间中。
2. 开始循环，不断更新最远端字符所在的位置，不断寻找直到条件 `if(end == i)` 满足，即可认为 $[start, i]$ 区间为答案所求区间之一。
```C++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        vector<int> res;
        int n = s.size();
        unordered_map<char,int> fardis;
        for(int i = 0; i<n; i++){
            if( i > fardis[s[i]] ){
                fardis[s[i]] = i;
            }
        }

        int startidx = 0, end = 0;
        for(int i = 0; i<n; i++){
            end = max ( end , fardis[s[i]]);
            if(end == i){
                int dis = i - startidx + 1;
                res.push_back(dis);
                end++;
                startidx = i+1;
            }
        }  
        return res;
    }
};
```
## 分发糖果
![[Pasted image 20240506201700.png]]
思路：
1. 先进行从右到左考虑，保证从右到左逻辑上满足题目要求
2. 再进行从左到右遍历，在保证从左到右在逻辑上满足题目要求时，需要注意不能破坏第一步中的逻辑，通过该逻辑取最大值即可。
```C++
if(ratings[i] > ratings[i-1])
	candynum[i] = max (candynum[i-1] + 1, candynum[i]);
```

```C++
class Solution {
public:
    int candy(vector<int>& ratings) {
        int n = ratings.size();
        int res = 0;
        map<int,vector<int>> numpos;
        vector<int> candynum(n,1);
        for(int i = n-2; i>=0; i--){
            if(ratings[i] > ratings[i+1])
                candynum[i] = candynum[i+1] + 1;
        }
        for(int i = 1; i<n; i++){
            if(ratings[i] > ratings[i-1])
                candynum[i] = max (candynum[i-1] + 1, candynum[i]);
        }
        res = accumulate(candynum.begin(),candynum.end(),0);
        return res;
    }
};
```

## 柠檬水找零
![[Pasted image 20240515235245.png]]
思路：先付大金额，再付小金额。
```C++
class Solution {
public:
    bool lemonadeChange(vector<int>& bills) {
        vector<int>mp(2);
        for(int bill : bills){
            if(bill == 5) mp[0]++;
            else if(bill == 10){
                mp[0]--;
                mp[1]++;
                if(mp[0] <0) return false;
            }
            else if(bill == 20){
                if(mp[1] >0){
                    mp[1]--;
                    mp[0]--;
                    if(mp[1] < 0 || mp[0] < 0 ) return false;
                }
                else{
                    mp[0]-=3;
                    if( mp[0] < 0 ) return false;
                }
            }
        }
        return true;
    }
};
```
## 区间最优贪心
### 用最少弓箭射气球
![[Pasted image 20240516111826.png]]
贪心策略：，每次射箭已经改尽可能射中更多的气球，那么可以先对先排序，每次射箭只射满足气球重叠时最小的右边界以保证**在射出必要弓箭地情况下能够最多地带走更多的气球**，若没有重叠，则需要+1 箭。
```C++
class Solution {
private:
    // static bool cmp(const vector<int>& a, const vector<int>& b) {
    //     return a[0] < b[0];
    // }

public:
    int findMinArrowShots(vector<vector<int>>& points) {
        if (points.size() == 0)
            return 0;
        auto cmp = [](const vector<int>& v1, const vector<int>& v2) {
            if (v1[0] == v2[0]) {
                return v1[1] > v2[1];
            } else {
                return v1[0] < v2[0];
            }
        };
        sort(points.begin(), points.end(), cmp);

        int res = 1;
        int shootpos = points[0][1];
        for (int i = 1; i < points.size(); i++) {
            if (points[i][0] > shootpos) {//无重叠
                res++;
                shootpos = points[i][1];
            } else {
                shootpos = min(shootpos, points[i][1]);
            }
        }
        return res;
    }
};
```

### 无重叠区间
![[Pasted image 20240516164132.png]]
思路：此题和上题最优射箭类似。首先对区间排序，同样分为两种情况：
1. 当没有空间重叠时，直接过渡到下一个区间。
2. 当空间产生重叠时，删除区间右值更大的区间。

```C++
class Solution {
public:
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        int res = 0;
        // vector<vector<int>> intervallen = intervals;
        // for(int i = 0; )
        sort(intervals.begin(), intervals.end());
        for(int i = 1; i<intervals.size(); i++){
            if(intervals[i-1][1] <= intervals[i][0]){
                continue;
            }
            else{//已重叠，删除右端口最大的区间
                res++;
                intervals[i][1] = min(intervals[i-1][1] , intervals[i][1]);
                // if( intervals[i-1][1] <= intervals[i][1] )
            }
        }
        return res;
    }
};
```
### 合并区间
![[Pasted image 20240516163652.png]]
```C++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> mergeResult;
        sort(intervals.begin(), intervals.end());
        mergeResult.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] <= mergeResult.back()[1])
            {
                mergeResult.back()[1] = max(mergeResult.back()[1],intervals[i][1]);
            }
            else
            {
                mergeResult.push_back(intervals[i]);
            }
        }
        return mergeResult;
    }
};
```
# 2 动态规划
## 爬楼梯
![[爬楼梯.png]]
### 思路

本题大家如果没有接触过的话，会感觉比较难，多举几个例子，就可以发现其规律。

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。
那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。
所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。

我们来分析一下，动规五部曲：

定义一个一维数组来记录不同楼层的状态

1. 确定dp数组以及下标的含义

dp[i]： 爬到第i层楼梯，有dp[i]种方法

2. 确定递推公式

如何可以推出dp[i]呢？

从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。

首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。

还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。

那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！

所以$dp[i] = dp[i - 1] + dp[i - 2]$ 。

在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。

这体现出确定dp数组以及下标的含义的重要性！

3. dp数组如何初始化

再回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]种方法。

那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但基本都是直接奔着答案去解释的。

例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。

但总有点牵强的成分。

那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.

**其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1**。

从dp数组定义的角度上来说，dp[0] = 0 也能说得通。

需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。

所以本题其实就不应该讨论dp[0]的初始化！

我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。

所以我的原则是：不考虑dp[0]如何初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。

4. 确定遍历顺序

从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的

5. 举例推导dp数组

举例当n为5的时候，dp table（dp数组）应该是这样的

![70.爬楼梯](https://code-thinking-1253855093.file.myqcloud.com/pics/20210105202546299.png)

如果代码出问题了，就把dp table 打印出来，看看究竟是不是和自己推导的一样。

**此时大家应该发现了，这不就是斐波那契数列么！**

```C++
// 版本一
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) { // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```
- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

## 使用最小花费爬楼梯
![[Pasted image 20231115104243.png]]
### 动态规划解法
#### 版本 1：未优化
```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size()+1);
        dp[0] = 0;
        dp[1] = 0;
        for(int i = 2;i<=cost.size();i++){
            
            dp[i] = min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
            //cout<<"i="<<i<<","<<dp[i-2]+cost[i-2]<<","<<dp[i-1]+cost[i-1]<<","<<"dp[i]="<<dp[i]<<endl;
            
        }
        return dp.back();
    }
};
```
#### 版本 2：优化
只使用两个数值便可进行动态规划递归
```C++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(2);
        dp[0] = 0;
        dp[1] = 0;
        for(int i = 2;i<=cost.size();i++){
            int tmp = dp[1];
            dp[1] = min(dp[1]+cost[i-1],dp[0]+cost[i-2]);
            dp[0] = tmp;
            //cout<<"i="<<i<<","<<dp[i-2]+cost[i-2]<<","<<dp[i-1]+cost[i-1]<<","<<"dp[i]="<<dp[i]<<endl;
        }
        return dp.back();
    }
};
```
- 时间复杂度：O(m × n)
- 空间复杂度：O(m × n)

### 数论解法
在这个图中，可以看出一共 m，n 的话，无论怎么走，走到终点都需要 m + n - 2 步。
![62.不同路径](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113602700-20230310120944078.png)

在这m + n - 2 步中，一定有 m - 1 步是要向下走的，不用管什么时候向下走。
那么有几种走法呢？ 可以转化为，给你m + n - 2个不同的数，随便取m - 1个数，有几种取法。
那么这就是一个组合问题了。
那么答案，如图所示：

![62.不同路径2](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209113725324.png)

**求组合的时候，要防止两个int相乘溢出！** 所以不能把算式的分子都算出来，分母都算出来再做除法。

例如如下代码是不行的。

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        int numerator = 1, denominator = 1;
        int count = m - 1;
        int t = m + n - 2;
        while (count--) numerator *= (t--); // 计算分子，此时分子就会溢出
        for (int i = 1; i <= m - 1; i++) denominator *= i; // 计算分母
        return numerator / denominator;
    }
};

```

需要在计算分子的时候，不断除以分母，代码如下：

```C++
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long numerator = 1; // 分子
        int denominator = m - 1; // 分母
        int count = m - 1;
        int t = m + n - 2;
        while (count--) {
            numerator *= (t--);
            while (denominator != 0 && numerator % denominator == 0) {
                numerator /= denominator;
                denominator--;
            }
        }
        return numerator;
    }
};
```

- 时间复杂度：O(m)
- 空间复杂度：O(1)

**计算组合问题的代码还是有难度的，特别是处理溢出的情况！**
## 不同路径 2
![[Pasted image 20231116164444.png]]
```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(),n = obstacleGrid[0].size();
        int dp[m][n];
        dp[0][0] = !obstacleGrid[0][0];
        for(int i = 1;i<m;i++) dp[i][0] = dp[i-1][0] * (!obstacleGrid[i][0]);
        for(int j = 1;j<n;j++) dp[0][j] = dp[0][j-1] * (!obstacleGrid[0][j]);
        
        for(int i = 1;i<m;i++){
            for(int j =1;j<n;j++){
                if(obstacleGrid[i][j]) dp[i][j] = 0;
                else{

                    dp[i][j] = dp[i-1][j] +dp[i][j-1] ;
                    //cout<<"dp['i']['j']="<<dp[i][j]<<endl;
                }
            }
        }
        return dp[m-1][n-1];
    }
};
```
## 整数拆分
![[Pasted image 20231121105523.png]]
### 动态规划

动规五部曲，分析如下：

1. 确定dp数组（dp table）以及下标的含义
dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。
dp[i]的定义将贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！

2. 确定递推公式
可以想 dp[i]最大乘积是怎么得到的呢？
其实可以从1遍历j，然后有两种渠道得到dp[i].
一个是j * (i - j) 直接相乘。
一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。
**那有同学问了，j怎么就不拆分呢？**
j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。
如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。
所以递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});
那么在取最大值的时候，为什么还要比较dp[i]呢？
因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。

3. dp的初始化
不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？
有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。
严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。
拆分0和拆分1的最大乘积是多少？
这是无解的。
这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！

4. 确定遍历顺序
确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。
所以遍历顺序为：
```C
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j < i - 1; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}
```
注意 枚举j的时候，是从1开始的。从0开始的话，那么让拆分一个数拆个0，求最大乘积就没有意义了。
j的结束条件是 j < i - 1 ，其实 j < i 也是可以的，不过可以节省一步，例如让j = i - 1，的话，其实在 j = 1的时候，这一步就已经拆出来了，重复计算，所以 j < i - 1
至于 i是从3开始，这样dp[i - j]就是dp[2]正好可以通过我们初始化的数值求出来。
更优化一步，可以这样：

```C
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j <= i / 2; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}
```

因为拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的。
例如 6 拆成 3 * 3， 10 拆成 3 * 3 * 4。 100的话 也是拆成m个近似数组的子数 相乘才是最大的。
只不过我们不知道m究竟是多少而已，但可以明确的是m一定大于等于2，既然m大于等于2，也就是 最差也应该是拆成两个相同的 可能是最大值。
那么 j 遍历，只需要遍历到 n/2 就可以，后面就没有必要遍历了，一定不是最大值。
至于 “拆分一个数n 使之乘积最大，那么一定是拆分成m个近似相同的子数相乘才是最大的” 这个我就不去做数学证明了，感兴趣的同学，可以自己证明。

5. 举例推导dp数组
举例当n为10 的时候，dp数组里的数值，如下：
![343.整数拆分](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104173021581.png)

以上动规五部曲分析完毕，C++代码如下：
```C++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n ; i++) {
            for (int j = 1; j <= i / 2; j++) {
                dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
            }
        }
        return dp[n];
    }
};
```
- 时间复杂度：O(n^2)
- 空间复杂度：O(n)

### 贪心解法

本题也可以用贪心，每次拆成**n个3**，如果剩下是4，则保留4，然后相乘，**但是这个结论需要数学证明其合理性！**

我没有证明，而是直接用了结论。感兴趣的同学可以自己再去研究研究数学证明哈。

给出我的C++代码如下：

```C++
class Solution {
public:
    int integerBreak(int n) {
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n == 4) return 4;
        int result = 1;
        while (n > 4) {
            result *= 3;
            n -= 3;
        }
        result *= n;
        return result;
    }
};
```
- 时间复杂度：O(n)
- 空间复杂度：O(1)

## 不同的二叉搜索树
![[Pasted image 20231121124829.png]]
了解了二叉搜索树之后，我们应该先举几个例子，画画图，看看有没有什么规律，如图：

![96.不同的二叉搜索树](https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093106367.png)

n为1的时候有一棵树，n为2有两棵树，这个是很直观的。

![96.不同的二叉搜索树1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093129889.png)

来看看n为3的时候，有哪几种情况。

当1为头结点的时候，其右子树有两个节点，看这两个节点的布局，是不是和 n 为2的时候两棵树的布局是一样的啊！

（可能有同学问了，这布局不一样啊，节点数值都不一样。别忘了我们就是求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异）

当3为头结点的时候，其左子树有两个节点，看这两个节点的布局，是不是和n为2的时候两棵树的布局也是一样的啊！

当2为头结点的时候，其左右子树都只有一个节点，布局是不是和n为1的时候只有一棵树的布局也是一样的啊！

发现到这里，其实我们就找到了重叠子问题了，其实也就是发现可以通过dp[1] 和 dp[2] 来推导出来dp[3]的某种方式。

思考到这里，这道题目就有眉目了。

dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

有2个元素的搜索树数量就是dp[2]。

有1个元素的搜索树数量就是dp[1]。

有0个元素的搜索树数量就是dp[0]。

所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

如图所示：

![96.不同的二叉搜索树2](https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093226241.png)

此时我们已经找到递推关系了，那么可以用动规五部曲再系统分析一遍。

1. 确定dp数组（dp table）以及下标的含义

**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。

也可以理解是i个不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

以下分析如果想不清楚，就来回想一下dp[i]的定义

2. 确定递推公式

在上面的分析中，其实已经看出其递推关系， $dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]$

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

3. dp数组如何初始化

初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

那么dp[0]应该是多少呢？

从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。

从递归公式上来讲，$dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]$ 中以j为头结点左子树节点数量为0，也需要$dp[以j为头结点左子树节点数量] = 1$， 否则乘法的结果就都变成0了。

所以初始化dp[0] = 1

4. 确定遍历顺序

首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

那么遍历i里面每一个数作为头结点的状态，用j来遍历。

代码如下：

```C
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```

5. 举例推导dp数组

n为5时候的dp数组状态如图：

![96.不同的二叉搜索树3](https://code-thinking-1253855093.file.myqcloud.com/pics/20210107093253987.png)

当然如果自己画图举例的话，基本举例到n为3就可以了，n为4的时候，画图已经比较麻烦了。

**我这里列到了n为5的情况，是为了方便大家 debug代码的时候，把dp数组打出来，看看哪里有问题**。

综上分析完毕，C++代码如下：

```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```


- 时间复杂度：$O(n^2)$
- 空间复杂度：$O(n)$

大家应该发现了，我们分析了这么多，最后代码却如此简单！
## 背包问题
### 0-1 背包问题
#### 二维 dp 数组01背包

依然动规五部曲分析一波。

1. 确定dp数组以及下标的含义

对于背包问题，有一种写法，是使用二维数组，**即 $dp[i][j]$ 表示从下标为 $[0-i]$ 的物品里任意取，放进容量为 j 的背包，价值总和最大是多少**。

只看这个二维数组的定义，大家一定会有点懵，看下面这个图：

![动态规划-背包问题1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103003361.png)

**要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的**，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。

2. 确定递推公式

再回顾一下dp[i][j]的含义：从下标为`[0-i]`的物品里任意取，放进容量为`j`的背包，价值总和最大是多少。

那么可以有两个方向推出来 $dp[i][j]$，
#0-1背包问题思路 ^542562
- **不放物品i**：由dp$[i - 1][j]$推出，即背包容量为j，里面不放物品i的最大价值，此时$dp[i][j]$就是$dp[i - 1][j]$。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
- **放物品i**：由$dp[i - 1][j - weight[i]]$推出，$dp[i - 1][j - weight[i]]$ 为背包容量为$j - weight[i]$的时候不放物品i的最大价值，那么$dp[i - 1][j - weight[i]] + value[i]$ （物品i的价值），就是背包放物品i得到的最大价值
>本质上就是遍历到了 `dp[i][j]` 时判断是否将物品 i 加入

所以递归公式：$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$;

3. dp数组如何初始化

**关于初始化，一定要和dp数组的定义吻合，否则到递推公式的时候就会越来越乱**。

首先从$dp[i][j]$的定义出发，如果背包容量j为0的话，即$dp[i][0]$，无论是选取哪些物品，背包价值总和一定为0。如图：

![动态规划-背包问题2](https://code-thinking-1253855093.file.myqcloud.com/pics/2021011010304192.png)

在看其他情况。

状态转移方程 $dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$; 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。

$dp[0][j]$，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。

那么很明显当 $j < weight[0]$的时候，dp[0][j] 应该是 0，因为背包容量比编号0的物品重量还小。

当j >= weight[0]时，$dp[0][j]$ 应该是value[0]，因为背包容量放足够放编号0物品。

代码初始化如下：

```C++
for (int j = 0 ; j < weight[0]; j++) {  // 当然这一步，如果把dp数组预先初始化为0了，这一步就可以省略，但很多同学应该没有想清楚这一点。
    dp[0][j] = 0;
}
// 正序遍历
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}
```

此时dp数组初始化情况如图所示：

![动态规划-背包问题7](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103109140.png)

dp[0][j] 和 dp[i][0] 都已经初始化了，那么其他下标应该初始化多少呢？

其实从递归公式： $dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$; 可以看出dp[i][j] 是由左上方数值推导出来了，那么 其他下标初始为什么数值都可以，因为都会被覆盖。

**初始-1，初始-2，初始100，都可以！**

但只不过一开始就统一把dp数组统一初始为0，更方便一些。

如图：

![动态规划-背包问题10](https://code-thinking-1253855093.file.myqcloud.com/pics/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%9810.jpg)

最后初始化代码如下：

```C++
// 初始化 dp
vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
for (int j = weight[0]; j <= bagweight; j++) {
    dp[0][j] = value[0];
}

```


**费了这么大的功夫，才把如何初始化讲清楚，相信不少同学平时初始化dp数组是凭感觉来的，但有时候感觉是不靠谱的**。

4. 确定遍历顺序

在如下图中，可以看出，有两个遍历的维度：物品与背包重量

![动态规划-背包问题3](https://code-thinking-1253855093.file.myqcloud.com/pics/2021011010314055.png)

那么问题来了，**先遍历 物品还是先遍历背包重量呢？**

**其实都可以！！ 但是先遍历物品更好理解**。

那么我先给出先遍历物品，然后遍历背包重量的代码。

```C++
// weight数组的大小 就是物品个数
for(int i = 1; i < weight.size(); i++) { // 遍历物品
    for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```

**先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）**

例如这样：

```C++
// weight数组的大小 就是物品个数
for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
```

为什么也是可以的呢？

**要理解递归的本质和递推的方向**。

$dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])$; 递归公式中可以看出$dp[i][j]$是靠$dp[i-1][j]$和$dp[i - 1][j - weight[i]]$推导出来的。
$dp[i-1][j]$和$dp[i - 1][j - weight[i]]$ 都在$dp[i][j]$的左上角方向（包括正上方向），那么先遍历物品，再遍历背包的过程如图所示：

![动态规划-背包问题5](https://code-thinking-1253855093.file.myqcloud.com/pics/202101101032124.png)

再来看看先遍历背包，再遍历物品呢，如图：

![动态规划-背包问题6](https://code-thinking-1253855093.file.myqcloud.com/pics/20210110103244701.png)

**大家可以看出，虽然两个for循环遍历的次序不同，但是dp[i][j]所需要的数据就是左上角，根本不影响dp[i][j]公式的推导！**

但先遍历物品再遍历背包这个顺序更好理解。

**其实背包问题里，两个for循环的先后循序是非常有讲究的，理解遍历顺序其实比理解推导公式难多了**。

5. 举例推导dp数组

来看一下对应的dp数组的数值，如图：

![动态规划-背包问题4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210118163425129.jpg)

最终结果就是`dp[2][4]`。

建议大家此时自己在纸上推导一遍，看看dp数组里每一个数值是不是这样的。

**做动态规划的题目，最好的过程就是自己在纸上举一个例子把对应的dp数组的数值推导一下，然后在动手写代码！**

很多同学做dp题目，遇到各种问题，然后凭感觉东改改西改改，怎么改都不对，或者稀里糊涂就改过了。

主要就是自己没有动手推导一下dp数组的演变过程，如果推导明白了，代码写出来就算有问题，只要把dp数组打印出来，对比一下和自己推导的有什么差异，很快就可以发现问题了。

```C++
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagweight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}

```


本题力扣上没有原题，大家可以去[卡码网第46题 (opens new window)](https://kamacoder.com/problem.php?id=1046)去练习，题意是一样的，代码如下：

```C++

//二维dp数组实现
#include <bits/stdc++.h>
using namespace std;

int n, bagweight;// bagweight代表行李箱空间
void solve() {
    vector<int> weight(n, 0); // 存储每件物品所占空间
    vector<int> value(n, 0);  // 存储每件物品价值
    for(int i = 0; i < n; ++i) {
        cin >> weight[i];
    }
    for(int j = 0; j < n; ++j) {
        cin >> value[j];
    }
    // dp数组, dp[i][j]代表行李箱空间为j的情况下,从下标为[0, i]的物品里面任意取,能达到的最大价值
    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化, 因为需要用到dp[i - 1]的值
    // j < weight[0]已在上方被初始化为0
    // j >= weight[0]的值就初始化为value[0]
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    for(int i = 1; i < weight.size(); i++) { // 遍历科研物品
        for(int j = 0; j <= bagweight; j++) { // 遍历行李箱容量
            // 如果装不下这个物品,那么就继承dp[i - 1][j]的值
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            // 如果能装下,就将值更新为 不装这个物品的最大值 和 装这个物品的最大值 中的 最大值
            // 装这个物品的最大值由容量为j - weight[i]的包任意放入序号为[0, i - 1]的最大值 + 该物品的价值构成
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    cout << dp[weight.size() - 1][bagweight] << endl;
}

int main() {
    while(cin >> n >> bagweight) {
        solve();
    }
    return 0;
}
```

### 总结

讲了这么多才刚刚把二维dp的01背包讲完，**这里大家其实可以发现最简单的是推导公式了，推导公式估计看一遍就记下来了，但难就难在如何初始化和遍历顺序上**。

可能有的同学并没有注意到初始化 和 遍历顺序的重要性，我们后面做力扣上背包面试题目的时候，大家就会感受出来了。

### 滚动数组解法
在下面这段代码中
```C++
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
```
本质上只有一行数组在不断更新，故可以只用一维数组维护所更新的结果。
因为遍历用到了前面的数据，所以需要从后面开始遍历。

```C++
// 一维dp数组实现
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // 读取 M 和 N
    int M, N;
    cin >> M >> N;

    vector<int> costs(M);
    vector<int> values(M);

    for (int i = 0; i < M; i++) {
        cin >> costs[i];
    }
    for (int j = 0; j < M; j++) {
        cin >> values[j];
    }

    // 创建一个动态规划数组dp，初始值为0
    vector<int> dp(N + 1, 0);

    // 外层循环遍历每个类型的研究材料
    for (int i = 0; i < M; ++i) {
        // 内层循环从 N 空间逐渐减少到当前研究材料所占空间
        for (int j = N; j >= costs[i]; --j) {
            // 考虑当前研究材料选择和不选择的情况，选择最大值
            dp[j] = max(dp[j], dp[j - costs[i]] + values[i]);
        }
    }

    // 输出dp[N]，即在给定 N 行李空间可以携带的研究材料最大价值
    cout << dp[N] << endl;

    return 0;
}

```


### 分割等和子集问题
![[Pasted image 20231130104937.png]]
#### 使用0-1 背包解题思路
[[#^542562|0-1背包思路]]
建立一个大小为 $sum/2$ 的动态数组 dp 用于维护，其中 `dp[j]` 表示的是当容器容量（子数组和）为 j 时所能承载的最大数值，并且实际上是以滚动数组的方式进行维护的。
其中 `values[i]和 weight[i]都由 nums[i]`所代替
本质上是二维 $dp[i][j]$ 的动态数组维护方式。放入前（0-i）个数能让容器容量为 j 时的最大值，最后取用 `dp[targetnum]==targetnum` 即可. 遍历如下，使用了滚动数组维护.
```C++
for(int i = 0; i<nums.size() ;i++ ){
	for(int j = targetnum; j>=nums[i];j--){
		dp[j] = max(dp[j],dp[j-nums[i]]+nums[i]);
	}
}
```

### 一和零
![[Pasted image 20231211105804.png]]
#### 解法思路
此题物品容量为一二维容量表征体系，背包容量包括“1 的容量和 0 的容量”，最终结果 `dp[i][j]` 表示 1容量为 i 和 0 容量为 j 时拥有的最大子集数目。每次遍历采用倒叙滚动数组遍历。
```C++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
        for (string str : strs) { // 遍历物品
            int oneNum = 0, zeroNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }
            for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！
                for (int j = n; j >= oneNum; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

### 完全背包理论
完全背包和 0-1 背包的区别在于，完全背包可以将物品多次拿取, 故在便利的时候需要从前向后遍历
```C++
// 先遍历物品，再遍历背包
for(int i = 0; i < weight.size(); i++) { // 遍历物品
    for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```
### 统计方案总数
与其相似的还有目标和题目，但区别在于，如果要求的是统计的是所有方案种类数，`dp[j]` 意义需要变更为容量为` j 时所有的方案种类数`，递推公式为 `dp[j]+=dp[j-nums[i]]`
然后统计目标范围内的目标总和数即可。
只要搞到 nums[i]，凑成 `dp[j]`就有 `dp[j - nums[i]]` 种方法。
例如：`dp[j]`，j 为5，
- 已经有一个 1（`nums[i]`） 的话，有 `dp[4]`种方法凑成容量为 5 的背包。
- 已经有一个 2（`nums[i]`） 的话，有 `dp[3]`种方法凑成容量为 5 的背包。
- 已经有一个 3（`nums[i]`） 的话，有 `dp[2]`中方法凑成容量为 5 的背包
- 已经有一个 4（`nums[i]`） 的话，有 `dp[1]`中方法凑成容量为 5 的背包
- 已经有一个 5 （`nums[i]`）的话，有 `dp[0]`中方法凑成容量为 5 的背包


那么凑整 `dp[target]` 有多少方法呢，也就是把所有的 `dp[j - nums[i]]` 累加起来。其中 $j ∈[nums[i],target]$，最终答案本质上是遍历到的最后一个值。
#### 目标和 (0-1 背包)
解题思路，当要求得和为 `target` 时需要满足：假设加法的总和为 x，那么减法对应的总和就是 sum - x。则有
$$x - (sum - x) = target$$
即 $$x = (target + sum) / 2$$
故，**此时问题本质为装满容量为 x 的背包，有几种方法**。
这里的x就是我们后面要求的背包容量。
```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = accumulate(nums.begin(),nums.end(),0);
        if((sum+target) %2 ==1) return 0;
        target = (sum+target) / 2;
        if(target<0) return 0;
        vector<int> dp(target+1);
        int n = nums.size();
        dp[0] = 1;
        for(int i = 0; i<n; i++){
            for(int j = target; j>=nums[i]; j--){
                dp[j]+= dp[j - nums[i]] ;
            }
        }
        return dp[target];
    }
};
```

#### 零钱兑换
![[Pasted image 20240412141136.png]]
```C++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount+1);
        int n = coins.size();
        dp[0] = 1;
        for(int i = 0; i<n; i++){
            for(int j = coins[i]; j<=amount; j++){
                dp[j]+=dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

#### 组合总和 (求排列总数题)
![[Pasted image 20240413141318.png]]
```C++
class Solution
{
public:
    int combinationSum4(vector<int> &nums, int target)
    {
        int n = nums.size();
        vector<int> dp(target + 1);
        dp[0] = 1;

        for (int j = 0; j <= target; j++)
        {
            for (int i = 0; i < n; i++)
            {
                if(nums[i] > j || dp[j] > (INT_MAX - dp[j - nums[i]]) ) continue;
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[target];
    }
};
```
### 其他完全背包
![[Pasted image 20240415162012.png]]
思路：字符串的连接和顺序有着强关系，故该问题本质上是求完全背包问题中的排列问题，排列的判断核心是：
其为前 j 个字字符能否由字典中的单词构成（true or false）
`dp[j] = dp[j] || (dp[j - mp[i]] && s.substr (j - mp[i], mp[i]) == wordDict[i])`

```C++
#include <bits/stdc++.h>
using namespace std;
class Solution
{
public:
    bool wordBreak(string s, vector<string> &wordDict)
    {
        unordered_map<int, int> mp;
        int n = wordDict.size();
        int sSize = s.size();
        vector<bool> dp(sSize + 1, false);
        for (size_t i = 0; i < n; i++)
        {
            mp[i] = wordDict[i].size();
        }
        dp[0] = true;

        for (int j = 0; j <= sSize; j++)
        {
            for (int i = 0; i < n; i++)
            {
                if (j < mp[i])
                    continue;
                dp[j] = dp[j] || (dp[j - mp[i]] && s.substr(j - mp[i], mp[i]) == wordDict[i]);
            }
        }
        return dp[sSize];
    }
};
```
### 背包递推公式总结

问能否能装满背包（或者最多装多少）：$dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])$; ，对应题目如下：
- [动态规划：416.分割等和子集(opens new window)](https://programmercarl.com/0416.%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86.html)
- [动态规划：1049.最后一块石头的重量 II(opens new window)](https://programmercarl.com/1049.%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII.html)

问装满背包有几种方法：$dp[j] += dp[j - nums[i]]$ ，对应题目如下：
- [动态规划：494.目标和(opens new window)](https://programmercarl.com/0494.%E7%9B%AE%E6%A0%87%E5%92%8C.html)
- [动态规划：518. 零钱兑换 II(opens new window)](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)
- [动态规划：377.组合总和Ⅳ(opens new window)](https://programmercarl.com/0377.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E2%85%A3.html)
- [动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)

问背包装满最大价值：$dp[j] = max(dp[j], dp[j - weight[i]] + value[i])$; ，对应题目如下：
- [动态规划：474.一和零(opens new window)](https://programmercarl.com/0474.%E4%B8%80%E5%92%8C%E9%9B%B6.html)

问装满背包所有物品的最小个数：$dp[j] = min(dp[j - coins[i]] + 1, dp[j])$; ，对应题目如下：
- [动态规划：322.零钱兑换(opens new window)](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)
- [动态规划：279.完全平方数](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)

### 背包遍历方法
#### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html#_01%E8%83%8C%E5%8C%85) 01背包

在[动态规划：关于01背包问题，你该了解这些！ (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.html)中我们讲解二维dp数组01背包先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

和[动态规划：关于01背包问题，你该了解这些！（滚动数组） (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-2.html)中，我们讲解一维dp数组01背包只能先遍历物品再遍历背包容量，且第二层for循环是从大到小遍历。

**一维dp数组的背包在遍历顺序上和二维dp数组实现的01背包其实是有很大差异的，大家需要注意！**

#### [#](https://programmercarl.com/%E8%83%8C%E5%8C%85%E6%80%BB%E7%BB%93%E7%AF%87.html#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85) 完全背包

说完01背包，再看看完全背包。

在[动态规划：关于完全背包，你该了解这些！ (opens new window)](https://programmercarl.com/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85.html)中，讲解了纯完全背包的一维dp数组实现，先遍历物品还是先遍历背包都是可以的，且第二层for循环是从小到大遍历。

但是仅仅是纯完全背包的遍历顺序是这样的，题目稍有变化，两个for循环的先后顺序就不一样了。

**如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包容量**。
**如果求排列数就是外层 for 遍历背包容量，内层 for 循环遍历物品**。

相关题目如下：
- 求组合数：[动态规划：518.零钱兑换II(opens new window)](https://programmercarl.com/0518.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II.html)
- 求排列数：[动态规划：377. 组合总和 Ⅳ (opens new window)](https://mp.weixin.qq.com/s/Iixw0nahJWQgbqVNk8k6gA)、[动态规划：70. 爬楼梯进阶版（完全背包）(opens new window)](https://programmercarl.com/0070.%E7%88%AC%E6%A5%BC%E6%A2%AF%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E7%89%88%E6%9C%AC.html)

如果求最小数，那么两层for循环的先后顺序就无所谓了，相关题目如下：
- 求最小数：[动态规划：322. 零钱兑换 (opens new window)](https://programmercarl.com/0322.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2.html)、[动态规划：279.完全平方数(opens new window)](https://programmercarl.com/0279.%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0.html)

**对于背包问题，其实递推公式算是容易的，难是难在遍历顺序上，如果把遍历顺序搞透，才算是真正理解了**。

## 买卖股票最佳时机问题 (状态机 DP)
### 只买/抛一次
![[Pasted image 20240410145307.png]]
#### 动态规划思路
定义 `dp[i][j]` 为到第 i 个元素选择抛了股票（记为 j =1）和没买入股票时（记为 j =0）。
不入股票，则资产 $dp[i][0]$ 视为在之前可买股票票价的最小值；入股票，则资产为
$$dp[i][1] = max(dp[i-1][1],dp[i-1][0]+prices[i])$$
即是否在第 i 个节点选择抛售股票

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();if(!n) return 0;
        vector<vector<int>> dp(n,vector<int>(2,0));
        int res = 0;
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        for(int i = 1; i < n; i++){
            dp[i][0] =  max(dp[i-1][0],-prices[i]);
            dp[i][1] =  max(dp[i-1][1], dp[i-1][0] + prices[i]) ;
        }
        return dp[n-1][1];
    }
};
```
### 可买抛多次 
![[Pasted image 20240415193524.png]]
思路：基于有限状态机来构建，在第 i 天，系统只有持有股票和不持有股票两种状态。若为不持有股票，则可以在第 i 天选择买入；若持有，则可在第 i 天选择抛出。
考虑 $dp[i][0]$ 的转移方程，如果这一天交易完后手里没有股票，那么可能的转移状态为前一天已经没有股票，即 $dp[i-1][0]$。或者前一天结束的时候手里持有一支股票，即 $dp[i-1][1]$,这时候我们要将其卖出，并获得 $prices[i]$ 的收益。因此为了收益最大化，我们列出如下的转移方程：
$dp[i][0]=\max\{dp[i-1][0],dp[i-1][1]+prices[i]\}$
再来考虑 $dp[i][1]$, 按照同样的方式考虑转移状态，那么可能的转移状态为前一天已经持有一支股票，即 $dp[i-1][1]$,或者前一天结束时还没有股票，即
 $dp[i-1][0]$,这时候我们要将其买入，并减少 $prices[i]$ 的收益。可以列出如下
 的转移方程：
$dp[i][1]=\max\{dp[i-1][1],dp[i-1][0]-prices[i]\}$
![[Pasted image 20240415193511.png]]
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int psize = prices.size();
        if(psize == 1) return 0;
        int dp0 = 0;
        int dp1 = -prices[0];
        for(int i = 1; i<psize; i++){
            int tmpdp0 = dp0;
            dp0 = max(dp1 + prices[i], dp0);
            dp1 = max(tmpdp0 - prices[i], dp1);
        }
        return dp0;
    }
};
```
### 买卖股票的最佳时机含冷冻期
![[Pasted image 20240415204413.png]]
卖出后不能马上买入，那在买入处的递归关系改为
$$dp[i][1] = max(dp[i-2][0] - prices[i], dp[i-1][1])$$
即可；同时处理好初始化条件。
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int psize = prices.size();
        if(psize <= 1) return 0;
        vector<vector<int>> dp(psize,vector<int>(2,0));
        dp[0][0] = 0;dp[0][1] = -prices[0];
        dp[1][0] =  max(0,prices[1]-prices[0]);
        dp[1][1] = max(-prices[0],-prices[1]);
        for(int i = 2; i<psize; i++){
            dp[i][0] = max(dp[i-1][1] + prices[i], dp[i-1][0]);
            dp[i][1] = max(dp[i-2][0] - prices[i], dp[i-1][1]);
        }
        return dp[psize-1][0];
    }
};
```

## 选与不选问题（打家劫舍）
![[Pasted image 20240408145910.png]]
```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n,0);
        if(n == 1) return nums[0];
        else if(n == 2) return max(nums[0],nums[1]);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        for(int i  = 2; i<n; i++){
            dp[i] = max( dp[i-2] + nums[i] ,dp[i-1] );
        }
        return dp[n-1];
    }
};
```

### 打家劫舍 2
![[Pasted image 20240507123917.png]]
**思路**：在环形道路上，
```C++
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if(n <= 2) return *max_element(nums.begin(), nums.end());
        vector<int> dp(n, 0);
        int res = 0;
        //抢劫dp[0]
        dp[0] = nums[0];
        dp[1] = nums[0];
        for (int i = 2; i < n-1; i++)
        {
            dp[i] = max(dp[i-2] + nums[i],dp[i-1]);
        }
        res = dp[n-2];

        //不抢劫dp[0]
        dp[0] = 0;
        dp[1] = nums[1];
        for (int i = 2; i < n; i++)
        {
            dp[i] = max(dp[i-2] + nums[i],dp[i-1]);
        }
        res = max(res,dp[n-1]);
        return res;
        
    }
};
```


### 删除并获得点数
![[Pasted image 20240514003544.png]]
和打家劫舍一样，统计 sum 数组作为每栋房屋的价值，随后进行 dp 即可
$dp[i][0]$ 不删除 i, $dp[i][1]$ 删除 i
$dp[i][1] = max(dp[i-1][0],dp[i])$
#### 简单 dp
```C++
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        int maxval = *max_element(nums.begin(),nums.end());
        vector<int> sum(maxval+1);
        for(int num : nums){
            sum[num]+=num;
        }
        int dp0 = 0;
        int dp1 = sum[0];
        for(int i  = 1; i<=maxval; i++){
            int tmp = max(dp0,dp1);
            dp1 = max(dp0 + sum[i], dp1);
            dp0 = tmp;
        }
        return max(dp0,dp1);
    }
};
```
#### 状态机 dp
```C++
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        unordered_map <int,int> mp;
        for(int num : nums){
            mp[num]++;
        }
        vector<pair<int,int>> nummp(mp.begin(),mp.end());
        sort(nummp.begin(),nummp.end());
        int n = nummp.size();
        vector<int> dp(2);
        dp[1] = nummp[0].first * nummp[0].second;
        for(int i = 1; i<n; i++){
            int tmpdp0 = max(dp[0],dp[1]) ;
            if(nummp[i-1].first +1 == nummp[i].first){
                dp[1] =max(dp[0]+ nummp[i].first * nummp[i].second, dp[1] ) ;
            }
            else{
                int tmpadd = dp[1] + nummp[i].first * nummp[i].second;
                dp[1] =max(dp[0], tmpadd);
            }
            dp[0] = tmpdp0;
        }
        return max(dp[0], dp[1]);
    }
};
```

## 最长（递增递减）子序列，子数组问题区间 DP
### 最大子数组和
![[Pasted image 20240426162124.png]]
```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int res = nums[0];
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        for(int i = 1; i<nums.size(); i++){
            dp[i] = max(dp[i-1] +nums[i],nums[i]);
            res = max(res,dp[i]);
        }
        return res;
    }
};
```
### 乘积最大子数组
![[Pasted image 20240426161815.png]]
思维转换：此题和和最大子数组不同之处在于：之前所求的乘积有可能是负数。故对于 `dp[i]`，即以第 i 个元素为结尾时的子数组最大乘积，在递归时，还需要考虑乘积为负数时的可能性。故考虑 `dpminus[i-1]` 为以第 i 个元素为结尾时的子数组最小乘积，以应对可能存在的负数情况。
#### 递推公式
$dp[i] = max({nums[i],dp[i-1]*nums[i],dpminus[i-1]*nums[i]})$
$dpminus[i] = min({nums[i],dp[i-1]*nums[i],dpminus[i-1]*nums[i]})$
#### 解答
```C++
#include <bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int res = nums[0];
        int n = nums.size();
        if(n == 1) return nums[0];
        vector<int> dp(n, 0);
        vector<int> dpminus(n, 0);
        dp[0] = dpminus[0] =nums[0];
        
        for(int i = 1; i<n; i++){
            dp[i] = max({nums[i],dp[i-1]*nums[i],dpminus[i-1]*nums[i]});
            dpminus[i] = min({nums[i],dp[i-1]*nums[i],dpminus[i-1]*nums[i]});
            
            res = max(res, dp[i]);
        }
        return res;
    }
};
```
### 最长递增子序列
![[Pasted image 20240408101905.png]]
#### 动态规划解题思路
定义 $dp[i]$ 为考虑前 $i$ 个元素，以第 $i$ 个数字**结尾**的最长上升子序列的长度注意 $nums[i]$ 必须被选取。
 我们从小到大计算 $dp$ 数组的值，在计算 $dp[i]$ 之前，我们已经计算出
 $dp[0\ldots i-1]$ 的值，则状态转移方程为：

$dp[i]=\max(dp[j])+1$,其中 $0\leq j<i$ 且 $num[j]$ < $num[i]$
```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n,1);
        int res = 1;
        for(int i = 1; i<n; i++){
            for(int j = 0; j<i; j++){
                if(nums[i] > nums[j] ) dp[i] = max(dp[i],dp[j]+1);
            }
            if(dp[i] > res) res = dp[i];
        }
        return res;
    }
};
```

### 1143. 最长公共子序列
![[Pasted image 20240404222330.png]]
该题和相似，但是序列不要求为相邻字符。思路为 `dp[i][j]` 为 $nums 1（0，i-1）$ 的子数组与 nums 2 (0，j-1)的子数组之间的最大公共子数组。
```C++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size(), n = text2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for (int i = 1; i <= m; i++ )
        {
            for (int j = 1; j <= n; j++ )
            {
                if (text1[i-1] == text2[j-1])
                {
                    dp[i][j] = max(dp[i][j], dp[i-1][j-1] + 1);
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1] );
                }
                // cout<<"i,j: "<<i<<", "<<j<<" : "<<dp[i][j]<<endl;
            }
        }
        return dp[m][n];
    }
};
```

### 最长重复子数组
![[Pasted image 20240408124403.png]]

确定递推公式
主要就是两大情况： `text1[i - 1] 与 text2[j - 1]相同`，`text1[i - 1] 与 text2[j - 1]不相同`
如果`text1[i - 1]` 与 `text2[j - 1]`相同，那么找到了一个公共元素，所以$dp[i][j] = dp[i - 1][j - 1] + 1$;
如果 `text1[i - 1]` 与 `text2[j - 1]`不相同，那就看看 `text1[0, i - 2]`与 `text2[0, j - 1]`的最长公共子序列和` text1[0, i - 1]与 text2[0, j - 2]`的最长公共子序列，取最大的。
由此可以得到如下状态转移方程：
$$
dp[i][j]=\begin{cases}dp[i-1][j-1]+1,&text_1[i-1]=text_2[j-1]\\\max(dp[i-1][j],dp[i][j-1]),&text_1[i-1]\neq text_2[j-1]\end{cases}
$$

```C++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp (nums1.size() + 1, vector<int>(nums2.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= nums1.size(); i++) {
            for (int j = 1; j <= nums2.size(); j++) {
                if (nums1[i - 1] == nums2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    }
};
```


### 不相交的线
![[Pasted image 20240408152633.png]]
思路和上题完全一致：
根据贪心策略，是否将末尾两线相连取决于，对于 `dp[i][j]` 考虑对应的 nums 1[i]与 nums 2[j]线是否相连
```C++
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        int n = nums1.size(), m = nums2.size();
        vector< vector<int> > dp(n+1, vector<int> (m+1,0));
        for(int i = 0; i<n; i++){
            for(int j = 0; j<m; j++ ){
                if(nums1[i] == nums2[j]) dp[i+1][j+1] = dp[i][j] +1;
                else dp[i+1][j+1] = max(dp[i][j+1],dp[i+1][j]);
            }
        }
        return dp[n][m];
    }
};
```
### 编辑距离
![[Pasted image 20240416155812.png]]


#### 递推公式
$$
\left.dfs(i,j)=\left\{\begin{array}{ll}dfs(i-1,j-1)&s[i]=t[j]\\\\\min{(dfs(i,j-1),dfs(i-1,j),dfs(i-1,j-1))+1}&s[i]\neq t[j]\end{array}\right.\right.
$$
思考方式：当有公共字符时，可以其可完全递推到两字符字串前一个字母的字串；
当没有公共字符时，对字符 i 进行插入，删除，替换分别对应着 $dfs(i,j-1),dfs(i-1,j),dfs(i-1,j-1)$；

#### 初始化
根据 dp 数组的含义不难初始化，主要是保证空数组到另一个数组子数组之间的编辑距离正确。
```C++
int m = word1.size(), n = word2.size();
vector<vector<int>> dp(m+1,vector<int>(n+1,0));
for(int i = 1 ;i <= m; i++) dp[i][0] = i;
for(int j = 1 ;j <= n; j++) dp[0][j] = j;
```


```C++
class Solution {
public:
    int minDistance(string word1, string word2) {
        int m = word1.size(), n = word2.size();
        vector<vector<int>> dp(m+1,vector<int>(n+1,0));
        for(int i = 1 ;i <= m; i++) dp[i][0] = i;
        for(int j = 1 ;j <= n; j++) dp[0][j] = j;
        for (int i = 1; i <= m; i++ )
        {
            for (int j = 1; j <= n; j++ )
            {
                if (word1[i-1] == word2[j-1])
                {
                    dp[i][j] = dp[i-1][j-1];
                }
                else
                {
                    dp[i][j] = min( min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]  )+ 1 ;
                }
                // cout<<"i,j: "<<i<<", "<<j<<" : "<<dp[i][j]<<endl;
            }
        }
        return dp[m][n];
    }
};
```
### 不同的子序列
![[Pasted image 20240420162555.png]]
解题思路：
`dp[i][j]` 指的是末位为 `s[i]` 和末尾为 `s[j]` 子字符 s2, t 2串满足题目要求的包含值。
当末尾相同时，可以通过算入 `s[i]` 与不算入 `s[i]` 来合并；
$dp[i][j] = dp[i-1][j-1] + dp[i-1][j];$
末尾不同时，显然要将 s 字串 $dp[i-1][j]$ 来判定序列个数, 即 $dp[i][j] = dp[i-1][j]$

```C++
for(int i = 1; i<=m; i++){
	for(int j = 1; j<=n; j++){
		if(s[i-1] == t[j-1])
			dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
		else dp[i][j] = dp[i-1][j];
	}
}
```

```C++
class Solution {
public:
    int numDistinct(string s, string t) {
        int m = s.size(), n = t.size();
        vector<vector<uint64_t>> dp(m+1,vector<uint64_t>(n+1));
        for(int i = 0 ;i <= m; i++) dp[i][0] = 1;
        for(int i = 1; i<=m; i++){
            for(int j = 1; j<=n; j++){
                if(s[i-1] == t[j-1]){
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                }
                else
                {
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[m][n];

    }
};
```

## 多维 DP
### 多层回文字串
![[Pasted image 20240416103836.png]]
#### 解题思路
考虑 `dp[i][j]` 为从 i 到 j 的字符串是否为回文子串。

那么有递推公式
$dp[i][i+len-1] = dp[i+1][i+len-2]\space and \space(s[i] == s[i+len-1])$
实时保存最大的 len 即可

#### 题解
```C++
#include <bits/stdc++.h>
using namespace std;

class Solution {
    
public:
    string longestPalindrome(string s) {
        int n = s.size();
        vector<vector<bool>> dp(s.size(), vector<bool>(s.size(), 0));
        int maxLen = 1, start = 0;
        for (int i = 0; i < n-1; i++)
        {
            dp[i][i] = true;
            if(s[i] == s[i+1]) {
                dp[i][i+1] = true;
                maxLen = 2;
                start = i;    
            }
        }
        dp[n-1][n-1] = true;
        for (int len = 3; len <= n; len++)
        {
            for (int i = 0; i+len-1< n ; i++)
            {
                dp[i][i+len-1] = dp[i+1][i+len-2] &&( s[i] == s[i+len-1]);
                cout<<"i: "<<i<<", len = "<<len<<" ,  :"<<dp[i][i+len-1]<<endl;
                if (dp[i][i+len-1] && len > maxLen){
                    maxLen = len;
                    start = i;
                }    
            }
            
        }
        cout<<start<<", "<<maxLen<<endl;
        return s.substr(start, maxLen);

    }
};
```

### 最长重复子数组
![[Pasted image 20240402141736.png]]
#### 动态规划解法
直接暴力遍历会因为有反复判断 `nums[i] == nums[j]` 的内容，故可采用动态规划的思路解决问题， `dp[i][j]` 用于表示 `nums1[i:]` 里 `nums2[j:]` 范围内最大重复子串长度，即指定左边界，遍历边界之后的数据。
```C++
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        int n = A.size(), m = B.size();
        vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));
        int ans = 0;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = m - 1; j >= 0; j--) {
                dp[i][j] = A[i] == B[j] ? dp[i + 1][j + 1] + 1 : 0;
                ans = max(ans, dp[i][j]);
            }
        }
        return ans;
    }
};
```






## 其他技巧题
### 戳气球
![[Pasted image 20240409194352.png]]
状态 $dp[lo][hi]$ 为戳破开区间 $(lo,hi)$ 里所有气球后所能获得的最大硬币数量。但状态的转移方程怎么定义呢？如何根据 $dp[lo][hi]$ 的子集推算出 $dp[lo][hi]$ 呢？
 我们假设 $(lo,hi)$ 里最后戳破的气球为 $i$,那么此时得到的硬币数量就应该是：
$$dp[lo][i]+dp[i][hi]+nums[i]*nums[lo]*nums[hi]$$
为什么呢？因为如果最后戳破的气球是 $i$,那肯定得是 $i$ 左右两边的气球都已经被戳破了，戳破左右两边得到的硬币数分别是 $dp[lo][i]$ 与 $dp[i][hi]$。(不戳两端)
 左右两边的气球都已经戳破了，那戳破气球 $i$ 得到的硬币就是 $nums[i]*nums[lo]*$
 $nums[hi]$ 了。
```C++
class Solution {
public:
    int maxCoins(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> dp(n+2, vector<int>(n+2, 0));
        vector<int> val(n+2,1);
        // val[0] = 1;val[n+1] = 1;
        for(int i = 1;i<n+1; i++) val[i] = nums[i-1];

        for(int i = n-1; i>=0;i--){
            for(int j = i+2; j<n+2;j++){
                for(int k = i+1; k<j; k++){
                    int Addsum = val[i] * val[k] *val[j];
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + Addsum);
                }
            }
        }
        return dp[0][n+1];
    }
};
```
# 3 数组
## 二分查找
```C++
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```
二分法是非常重要的基础算法，其实主要就是对区间的定义没有理解清楚，在循环中没有始终坚持根据查找区间的定义来做边界处理。
区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。


#  最短路径
一般搜索算法流程框架：
1．定义点集 X 为已经处理的点，点集 F 为已发现但尚未处理的点
2．初始化点集 X 为空，点集 F 只包含搜索的起点
3．只要点集 F 不为空，循环 4～6：
	4．从点集 F 中取出一个点 v
	5．处理点 v，把点 v 加入点集 X
	6．遍历 v 的出边，对于每个 v 的邻居，若既不在点集 X 中也不在点集 F 中，则加入点集 F
7．搜索结束，点集 X 里的点是搜索过的点
注：F 为栈时，则算法时 DFS；若 F 是队列，则算法为 BFS。
## 深度搜索
### 1. 深搜应用-二叉树的遍历
#### 1.1 使用递归法
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    void travelsal(TreeNode* cur,vector<int> &res){
        if(cur == nullptr) return;
        if(cur->left) travelsal(cur->left,res);//左
        res.push_back(cur->val);//中
        if(cur->right) travelsal(cur->right,res);//右


    }

    vector<int> inorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> res;

        travelsal(root,res);
        return res;
    }
};
```


其他细节见 [[C++数据结构与算法基础#二叉树遍历方式]]

## 广度搜索
### 1. 无权图广度优先搜索
无权图按层级遍历搜索：不需要遍历完整整图就能找到答案

```C++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

// 使用BFS算法计算无权图的最短路径
vector<int> shortestPath(vector<vector<int>>& graph, int start, int end) {
    // 创建一个队列，用于存储待遍历的节点
    queue<int> q;
    // 创建一个布尔型数组，用于记录每个节点是否已经被遍历过
    vector<bool> visited(graph.size(), false);
    // 创建一个整型数组，用于记录每个节点到起始节点的距离
    vector<int> dist(graph.size(), -1);
    // 创建一个整型数组，用于记录每个节点在最短路径中的前一个节点
    vector<int> prev(graph.size(), -1);

    // 将起始节点加入队列中，并标记为已遍历
    q.push(start);
    visited[start] = true;
    dist[start] = 0;

    while (!q.empty()) {
        int curr = q.front();
        q.pop();

        for (int next : graph[curr]) {
            if (!visited[next]) {
                q.push(next);
                visited[next] = true;
                dist[next] = dist[curr] + 1;
                prev[next] = curr;
            }
        }
    }

    vector<int> path;
    if (dist[end] != -1) {
        int curr = end;
        while (curr != -1) {
            path.push_back(curr);
            curr = prev[curr];
        }
        reverse(path.begin(), path.end());
    }

    return path;
}

int main() {
    int n, start, end;
    cin >> n >> start >> end;

    // 创建一个二维向量，用于存储图的邻接表表示
    vector<vector<int>> graph(n + 1);

    for (int i = 0; i < n; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
    }

    // 计算最短路径
    vector<int> path = shortestPath(graph, start, end);

    // 输出结果
    if (path.empty()) {
        cout << "无法到达目标站点" << endl;
    } else {
        cout << "最短路径为：";
        for (int i = 0; i < path.size(); i++) {
            cout << path[i];
            if (i != path.size() - 1) {
                cout << "->";
            }
        }
        cout << endl;
    }

    return 0;
}

```

### 解释
1. 首先，我们定义了一个使用 BFS 算法计算无权图最短路径的函数 `shortestPath`，这个函数接收三个参数：一个二维向量 `graph` 表示图的邻接表，一个整数 `start` 表示起始节点的编号，一个整数 `end` 表示目标节点的编号。

2. 在函数内部，我们首先创建了一个队列 `q`，用于存储待遍历的节点。同时，我们还创建了三个向量：`visited` 用于记录每个节点是否已经被遍历过，`dist` 用于记录每个节点到起始节点的距离，`prev` 用于记录每个节点在最短路径中的前一个节点。这些向量的大小都等于图中节点的数量。

3. 接下来，我们将起始节点加入队列中，并标记为已遍历。同时，将起始节点到自己的距离设为 0。

4. 在队列不为空的情况下，我们从队列中取出第一个节点，并遍历其所有邻居节点。如果邻居节点还没有被遍历过，则将其加入队列中，并标记为已遍历。同时，将邻居节点到起始节点的距离设为当前节点到起始节点的距离加 1，并将当前节点设为邻居节点在最短路径中的前一个节点。

5. 当队列中所有节点都被遍历完毕后，我们就可以得到图中所有节点到起始节点的最短路径。具体来说，我们可以通过目标节点的 `dist` 值是否为-1 来判断是否存在从起始节点到目标节点的路径。如果存在路径，则可以通过 `prev` 数组逆向推导出这条路径上所有的节点。

1. 最后，我们将所有路径上的节点存储在一个向量 `path` 中，并返回该向量作为函数的结果。

# 3 图论相关

## 广度优先搜索

## 深度优先搜索
深度优先搜索一般使用回溯代码框架
```C
void dfs(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本节点所连接的其他节点) {
        处理节点;
        dfs(图，选择的节点); // 递归
        回溯，撤销处理结果
    }
}
```
### 详解深搜三部曲

其实深搜也是一样的，深搜三部曲如下：

1. 确认递归函数，参数
```C
void dfs(参数)
```
通常我们递归的时候，我们递归搜索需要了解哪些参数，其实也可以在写递归函数的时候，发现需要什么参数，再去补充就可以。
一般情况，深搜需要 二维数组数组结构保存所有路径，需要一维数组保存单一路径，这种保存结果的数组，我们可以定义一个全局变量，避免让我们的函数参数过多。
例如这样：
```C
vector<vector<int>> result; // 保存符合条件的所有路径
vector<int> path; // 起点到终点的路径
void dfs (图，目前搜索的节点)  
```
但这种写法看个人习惯，不强求。

2. 确认终止条件

终止条件很重要，很多同学写dfs的时候，之所以容易死循环，栈溢出等等这些问题，都是因为终止条件没有想清楚。

```C
if (终止条件) {
    存放结果;
    return;
}
```


终止添加不仅是结束本层递归，同时也是我们收获结果的时候。

另外，其实很多dfs写法，没有写终止条件，其实终止条件写在了， 下面dfs递归的逻辑里了，也就是不符合条件，直接不会向下递归。这里如果大家不理解的话，没关系，后面会有具体题目来讲解。

3. 处理目前搜索节点出发的路径

一般这里就是一个for循环的操作，去遍历 目前搜索节点 所能到的所有节点。

```C
for (选择：本节点所连接的其他节点) {
    处理节点;
    dfs(图，选择的节点); // 递归
    回溯，撤销处理结果
}
```



## 3.1 岛屿数量
### dfs 算法
深度优先算法
```C++
// 版本一 
class Solution {
private:
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
            if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') { // 没有访问过的 同时 是陆地的

                visited[nextx][nexty] = true; 
                dfs(grid, visited, nextx, nexty);
            } 
        }
    }
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false)); 

        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && grid[i][j] == '1') { 
                    visited[i][j] = true;
                    result++; // 遇到没访问过的陆地，+1
                    dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                }
            }
        }
        return result;
    }
};
```
### BFS 算法
关键点：加入队列就立即进行标记处理
```C++
class Solution {
private:
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que;
    que.push({x, y});
    visited[x][y] = true; // 只要加入队列，立刻标记
    while(!que.empty()) {
        pair<int ,int> cur = que.front(); que.pop();
        int curx = cur.first;
        int cury = cur.second;
        for (int i = 0; i < 4; i++) {
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
            if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') {
                que.push({nextx, nexty});
                visited[nextx][nexty] = true; // 只要加入队列立刻标记
            }
        }
    }
}
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));

        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && grid[i][j] == '1') {
                    result++; // 遇到没访问过的陆地，+1
                    bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                }
            }
        }
        return result;
    }
};
```
### 岛屿的最大面积
#### 深度优先搜索算法
将 `stack` 换成 `queue` 就是广度优先算法
![[Pasted image 20240227125230.png]]
```C++
class Solution {
private:
int dfs(int x,int y,vector<vector<int>>& grid,vector<vector<bool>>& visited){
    vector<vector<int>> dfsIndex = {{1,0},{-1,0},{0,1},{0,-1}};
    int IslandSize = 1;
    stack<pair<int,int>> q;
    q.push({x,y});
    
    while(!q.empty()){
        pair index = q.top();
        q.pop();
        for(int i = 0;i<4;i++){
            int nextx = index.first+dfsIndex[i][0],nexty = index.second+dfsIndex[i][1];
            if(nextx<0 ||nextx>=grid.size()||nexty<0||nexty>=grid[0].size()) continue;
            if( !visited[nextx][nexty] && grid[nextx][nexty] == 1){
                q.push({nextx,nexty});
                visited[nextx][nexty] = true;
                IslandSize++;
            }
        }
    }
    return IslandSize;
}
public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int res = 0;
        vector<vector<bool>> visited(grid.size(),vector<bool>(grid[0].size(),false));
        for(int i = 0;i<grid.size();i++){
            for(int j = 0;j<grid[0].size();j++){
                if(!visited[i][j] && grid[i][j] == 1){
                    visited[i][j] = true;
                    int tmpSize = dfs(i,j,grid,visited);
                    if(tmpSize > res) res = tmpSize;
                }
            }
        }

        return res;
    }
};
```
## 岛屿最大面积
### Dfs
```C++
// 版本一
class Solution {
private:
    int count;
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
    void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
        for (int i = 0; i < 4; i++) {
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过
            if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 没有访问过的 同时 是陆地的

                visited[nextx][nexty] = true;
                count++;
                dfs(grid, visited, nextx, nexty);
            }
        }
    }

public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));

        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && grid[i][j] == 1) {
                    count = 1;  // 因为dfs处理下一个节点，所以这里遇到陆地了就先计数，dfs处理接下来的相邻陆地
                    visited[i][j] = true;
                    dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                    result = max(result, count);
                }
            }
        }
        return result;
    }
};
```
### bfs
```C++
class Solution {
private:
    int count;
    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向
    void bfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, int x, int y) {
        queue<int> que;
        que.push(x);
        que.push(y);
        visited[x][y] = true; // 加入队列就意味节点是陆地可到达的点
        count++;
        while(!que.empty()) {
            int xx = que.front();que.pop();
            int yy = que.front();que.pop();
            for (int i = 0 ;i < 4; i++) {
                int nextx = xx + dir[i][0];
                int nexty = yy + dir[i][1];
                if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue; // 越界
                if (!visited[nextx][nexty] && grid[nextx][nexty] == 1) { // 节点没有被访问过且是陆地
                    visited[nextx][nexty] = true;
                    count++;
                    que.push(nextx);
                    que.push(nexty);
                }
            }
        }
    }

public:
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));
        int result = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (!visited[i][j] && grid[i][j] == 1) {
                    count = 0;
                    bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true
                    result = max(result, count);
                }
            }
        }
        return result;
    }
};
```
#获取遍历层数
每次遍历时保存每层节点数 Size，然后
```C++
while(Size--){
	弹出节点；
}
```

## 被围绕的区域
![[Pasted image 20240228102545.png]]
### 思路
此题和以上几道题思路相似，到值得注意的是可以先找到所有靠近边界线的陆地进行标记'A'，再通过全局遍历，对不靠近边境的陆地进行处理为海'X'，标记过的陆地正常转换为'O'。
### dfs 写法
```C++
class Solution {
public:
    int n, m;

    void dfs(vector<vector<char>>& board, int x, int y) {
        if (x < 0 || x >= n || y < 0 || y >= m || board[x][y] != 'O') {
            return;
        }
        board[x][y] = 'A';
        dfs(board, x + 1, y);
        dfs(board, x - 1, y);
        dfs(board, x, y + 1);
        dfs(board, x, y - 1);
    }

    void solve(vector<vector<char>>& board) {
        n = board.size();
        if (n == 0) {
            return;
        }
        m = board[0].size();
        for (int i = 0; i < n; i++) {
            dfs(board, i, 0);
            dfs(board, i, m - 1);
        }
        for (int i = 1; i < m - 1; i++) {
            dfs(board, 0, i);
            dfs(board, n - 1, i);
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
    }
};

```
## 大西洋水流问题
![[Pasted image 20240229105406.png]]
### 解题思路：水往高处流
水最终必然会从陆地的四周流出，那么可以考虑从四周开始遍历，分别使用 Pacific 和 Altanitic 作为 `visited` 数组，向高处进行遍历，最终便能得到可流至海洋的陆地 Index
#### dfs
```C++
class Solution {
private:
    int dir[4][2] = {-1, 0, 0, -1, 1, 0, 0, 1}; // 保存四个方向

    // 从低向高遍历，注意这里visited是引用，即可以改变传入的pacific和atlantic的值
    void dfs(vector<vector<int>>& heights, vector<vector<bool>>& visited, int x, int y) {
        if (visited[x][y]) return;
        visited[x][y] = true;
        for (int i = 0; i < 4; i++) { // 向四个方向遍历
            int nextx = x + dir[i][0];
            int nexty = y + dir[i][1];
            // 超过边界
            if (nextx < 0 || nextx >= heights.size() || nexty < 0 || nexty >= heights[0].size()) continue;
            // 高度不合适，注意这里是从低向高判断
            if (heights[x][y] > heights[nextx][nexty]) continue;

            dfs (heights, visited, nextx, nexty);
        }
        return;

    }

public:

    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        vector<vector<int>> result;
        int n = heights.size();
        int m = heights[0].size(); // 这里不用担心空指针，题目要求说了长宽都大于1

        // 记录从太平洋边出发，可以遍历的节点
        vector<vector<bool>> pacific = vector<vector<bool>>(n, vector<bool>(m, false));

        // 记录从大西洋出发，可以遍历的节点
        vector<vector<bool>> atlantic = vector<vector<bool>>(n, vector<bool>(m, false));

        // 从最上最下行的节点出发，向高处遍历
        for (int i = 0; i < n; i++) {
            dfs (heights, pacific, i, 0); // 遍历最左列，接触太平洋 
            dfs (heights, atlantic, i, m - 1); // 遍历最右列，接触大西 
        }

        // 从最左最右列的节点出发，向高处遍历
        for (int j = 0; j < m; j++) {
            dfs (heights, pacific, 0, j); // 遍历最上行，接触太平洋
            dfs (heights, atlantic, n - 1, j); // 遍历最下行，接触大西洋
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // 如果这个节点，从太平洋和大西洋出发都遍历过，就是结果
                if (pacific[i][j] && atlantic[i][j]) result.push_back({i, j});
            }
        }
        return result;
    }
};
```
#### bfs
```C++
class Solution
{
private:
    int dirs[4][2] = {-1, 0, 1, 0, 0, -1, 0, 1};
    void bfs(vector<vector<int>> &heights, vector<vector<bool>> &visited, int x, int y)
    {
        queue<pair<int, int>> q;
        q.push({x,y});
        visited[x][y] = true;
        while (!q.empty())
        {
            x = q.front().first,y = q.front().second;
            q.pop();
            for (int i = 0; i < 4; i++)
            {
                int nextx = x + dirs[i][0], nexty = y + dirs[i][1];
                if (nextx >= 0 && nextx < m && nexty >= 0 && nexty < n && !visited[nextx][nexty] && heights[nextx][nexty] >= heights[x][y])
                {
                    q.push({nextx, nexty});
                    visited[nextx][nexty] = true;
                }
            }

        }
    }

public:
    int m, n;
    vector<vector<bool>> visited;
    vector<vector<int>> pacificAtlantic(vector<vector<int>> &heights)
    {
        vector<vector<int>> res;
        m = heights.size(), n = heights[0].size();
        vector<vector<bool>> pacific(m, vector<bool>(n, false));
        vector<vector<bool>> atlantic(m, vector<bool>(n, false));

        for (int i = 0; i < m; i++)
        {
            bfs(heights, pacific, i, 0);
            bfs(heights, atlantic, i, n - 1);
        }
        for (int j = 0; j < n; j++)
        {
            bfs(heights, pacific, 0, j);
            bfs(heights, atlantic, m - 1, j);
        }
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                // 判断pair是否相等
                if (pacific[i][j] && atlantic[i][j])
                {
                    res.push_back({i, j});
                }
            }
        }
        return res;
    }
};
```

那么本题整体的时间复杂度其实是： 2 * n * m + n * m ，所以最终时间复杂度为 O(n * m) 。

空间复杂度为：O(n * m) 这个就不难理解了。开了几个 n * m 的数组。

## 单词接龙
![[Pasted image 20240302111800.png]]
### 解题思路：建图与广搜
```C++
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        // 将vector转成unordered_set，提高查询速度
        unordered_set<string> wordSet(wordList.begin(), wordList.end());
        // 如果endWord没有在wordSet出现，直接返回0
        if (wordSet.find(endWord) == wordSet.end()) return 0;
        // 记录word是否访问过
        unordered_map<string, int> visitMap; // <word, 查询到这个word路径长度>
        // 初始化队列
        queue<string> que;
        que.push(beginWord);
        // 初始化visitMap
        visitMap.insert(pair<string, int>(beginWord, 1));

        while(!que.empty()) {
            string word = que.front();
            que.pop();
            int path = visitMap[word]; // 这个word的路径长度
            for (int i = 0; i < word.size(); i++) {
                string newWord = word; // 用一个新单词替换word，因为每次置换一个字母
                for (int j = 0 ; j < 26; j++) {
                    newWord[i] = j + 'a';
                    if (newWord == endWord) return path + 1; // 找到了end，返回path+1
                    // wordSet出现了newWord，并且newWord没有被访问过
                    if (wordSet.find(newWord) != wordSet.end()
                            && visitMap.find(newWord) == visitMap.end()) {
                        // 添加访问信息
                        visitMap.insert(pair<string, int>(newWord, path + 1));
                        que.push(newWord);
                    }
                }
            }
        }
        return 0;
    }
};
```

## 钥匙与房间
### 深搜
>需要注意：不需要进行回溯，深搜只管是否能遍历到所有节点即可。

```C++
class Solution {
private:
    void dfs(vector<vector<int>>& rooms,int PresentRome){

        for(auto it:rooms[PresentRome]){
            if(!vis[it]){
                vis[it]=1;
                dfs(rooms,it);
            }
        }
        return;
    }
    vector<int>vis;
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        vis.resize(rooms.size(),0);
        vis[0]=1;
        dfs(rooms,0);
        for(auto it:vis){
            // cout<<it<<" ";
            if(it==0)return false;
        }
        return true;

    }
};
```

### 广搜
```C++
class Solution {
bool bfs(const vector<vector<int>>& rooms) {
    vector<int> visited(rooms.size(), 0); // 标记房间是否被访问过
    visited[0] = 1; //  0 号房间开始
    queue<int> que;
    que.push(0); //  0 号房间开始

    // 广度优先搜索的过程
    while (!que.empty()) {
        int key = que.front(); que.pop();
         vector<int> keys = rooms[key];
         for (int key : keys) {
             if (!visited[key]) {
                 que.push(key);
                 visited[key] = 1;
             }
         }
    }
    // 检查房间是不是都遍历过了
    for (int i : visited) {
        if (i == 0) return false;
    }
    return true;

}
public:
    bool canVisitAllRooms(vector<vector<int>>& rooms) {
        return bfs(rooms);
    }
};
```

## 岛屿的周长
### 直接遍历
```C++
class Solution {
public:
    int direction[4][2] = {0, 1, 1, 0, -1, 0, 0, -1};
    int islandPerimeter(vector<vector<int>>& grid) {
        int result = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[0].size(); j++) {
                if (grid[i][j] == 1) {
                    for (int k = 0; k < 4; k++) {       // 上下左右四个方向
                        int x = i + direction[k][0];
                        int y = j + direction[k][1];    // 计算周边坐标x,y
                        if (x < 0                       // i在边界上
                                || x >= grid.size()     // i在边界上
                                || y < 0                // j在边界上
                                || y >= grid[0].size()  // j在边界上
                                || grid[x][y] == 0) {   // x,y位置是水域
                            result++;
                        }
                    }
                }
            }
        }
        return result;
    }
};
```

## 并查集
并查集：可以用于表示各个元素是否属于同一集合，路径压缩后可用是否为同一根节点表示

### 并查集代码模板
```C++
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

## 寻找图中是否存在路径
### 并查集
直接寻找两个目标节点是否在同一集合中即可
```C++
class Solution {
private:
    void initUnion(vector<int>& father){
        for(int i = 0;i<father.size();i++){
            father[i] = i;
        }
    }

    int FindFather(vector<int>& father,int item){
        return item == father[item]?item:father[item] = FindFather(father,father[item]);
    }

    bool IsSame(vector<int>& father,int a,int b){
        a = FindFather(father,a);
        b = FindFather(father,b);
        return a == b;
    }
    void Joinedge(vector<int>& father,int a,int b){
        a = FindFather(father,a);
        b = FindFather(father,b);
        if(a != b){
            father[a] = b;
        }
    }

public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        vector<int> father(n);
        initUnion(father);
        
        for(auto& edge:edges){
            Joinedge(father,edge[0],edge[1]);
        }
        return IsSame(father,source,destination);
    }
};
```

## 冗余连接
![[Pasted image 20240306103009.png]]
### 并查集方案

```C++
class Solution {
private:
int n;
void InitEdges(vector<int>& fa) {
    for(int i = 0;i<n;i++){
        fa[i] = i;
    }
}

bool IsSame(int a,int b,vector<int>& fa){
    return Find(a,fa) == Find(b,fa);
}

int Find(int a,vector<int>& fa){
    return fa[a] == a ? a : fa[a] = Find(fa[a],fa);
}

void JoinEdges(int a,int b,vector<int>& fa){
    a = Find(a,fa);
    b = Find(b,fa);
    if(a != n){
        fa[a] = b;
    }
}

public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
      n = edges.size() + 1;
      vector<int> fa(n);
      InitEdges(fa);
      //有环条件，当两节点已经在相同集合内，则说明忧患
      for(auto& edge:edges){
          if(IsSame(edge[0],edge[1],fa)){
            return edge;
          }else
          {
            JoinEdges(edge[0],edge[1],fa);
          }
          
      }
      return vector<int>{0};
    }
};
```
## 冗余连接 2
![[Pasted image 20240416165551.png]]
### 解题思路
该题可认为是并查集-有向图
>两种可能会出现冗余连接
>其一：存在节点的入度为 2
>其二：出现了单向有向环
>针对其一，只需要删除某入边后，剩下的节点仍能组成树，该边便是需要删除的结果。（注意判断边最后从后向前判断）
>针对其二，只需要删除环内的任意一条边即可

```C++
class Solution
{
private:
    int n;
    void InitEdges(vector<int> &fa)
    {
        for (int i = 0; i < n; i++)
        {
            fa[i] = i;
        }
    }

    bool IsSame(int a, int b, vector<int> &fa)
    {
        return Find(a, fa) == Find(b, fa);
    }

    int Find(int a, vector<int> &fa)
    {
        return fa[a] == a ? a : fa[a] = Find(fa[a], fa);
    }

    void JoinEdges(int a, int b, vector<int> &fa)
    {
        a = Find(a, fa);
        b = Find(b, fa);
        if (a != n)
        {
            fa[b] = a;
        }
    }

    bool IsTreeAfterRemoveEdge(int DeleteEdge, vector<vector<int>> &edges, vector<int> &fa)
    {
        InitEdges(fa);
        for (int i = 0; i < edges.size(); i++)
        {
            if (i == DeleteEdge)
            {
                continue;
            }
            if (IsSame(edges[i][0], edges[i][1], fa))
            {
                return false;
            }
            JoinEdges(edges[i][0], edges[i][1], fa);
        }
        return true;
    }

    vector<int> getRemoveEdge(const vector<vector<int>> &edges, vector<int> &fa)
    {
        InitEdges(fa); // 初始化并查集
        for (int i = 0; i < n; i++)
        { // 遍历所有的边
            if (IsSame(edges[i][0], edges[i][1], fa))
            { // 构成有向环了，就是要删除的边
                return edges[i];
            }
            JoinEdges(edges[i][0], edges[i][1], fa);
        }
        return {};
    }

public:
    vector<int> findRedundantDirectedConnection(vector<vector<int>> &edges)
    {
        n = edges.size() + 1;
        vector<int> fa(n);
        vector<int> InDegree(n, 0);
        InitEdges(fa);
        vector<int> TwoIndegSet;
        for (auto &edge : edges)
        {
            InDegree[edge[1]]++;
        }
        for (int i = 0 ;i<edges.size();i++)
        {
            if(InDegree[edges[i][1]] == 2){
                TwoIndegSet.push_back(i);
            }
        }
        if(TwoIndegSet.size() > 0 ){
            // cout<<"situation1"<<endl;
            if( IsTreeAfterRemoveEdge(TwoIndegSet[1],edges, fa) )
                return edges[TwoIndegSet[1]];
            else
            {
                return edges[TwoIndegSet[0]];
            }
            
        }
        // cout<<"situation2"<<endl;
        //情况2单向有向环
        return getRemoveEdge(edges, fa);
    }
};
```
## 两城市间最小分数
![[Pasted image 20240414191943.png]]
找一个联通集合里最短的路径即可。但此处可以优化，即不断优化合并，将全不断压缩给根节点。
```C++
class Solution {
private:
    vector<int> fa, mi;
public:
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    void merge(int x, int y) {
        int a = find(x), b = find(y);
        fa[a] = b;
        mi[b] = min(mi[a], mi[b]);
    }
    int minScore(int n, vector<vector<int>>& roads) {
        fa = vector<int>(n + 1);
        mi = vector<int>(n + 1, 1e9);
        for(int i = 1; i <= n; i++) fa[i] = i;
        for(auto& r : roads) {
            int a = find(r[0]), b = find(r[1]), c = r[2];
            mi[a] = min(mi[a], c);
            mi[b] = min(mi[b], c);
            merge(a, b);
        }
        return mi[find(1)];       
    }
};
```



## 广度优先-腐烂的橘子
![[Pasted image 20240315095300.png]]

```C++
class Solution {
private:
int dir[4][2] = {1,0,-1,0,0,1,0,-1};
int m,n;
int cnt;
vector<vector<int>> visited;
int bfs(vector<vector<int>>& grid, queue<pair<int,int>> q ){
    if (q.empty()) return 0;
    q.push({-1,-1});//添加标记
    int res = -1;
    while(!q.empty()){
        auto condex = q.front();
        q.pop();
        
        // cout<<"i:"<<condex.first <<"j:"<< condex.second<<endl;
        if(condex.first == -1 && condex.second == -1){
            res++;
            if(!q.empty()) q.push({-1,-1});//添加标记
            continue;
        }
        for(int i = 0;i < 4 ; i++){
            int nextx = condex.first + dir[i][0], nexty = condex.second + dir[i][1]; 
            if( nextx<0 || nextx>= m || nexty<0 || nexty >= n || visited[nextx][nexty] == 1 ||grid[nextx][nexty] != 1) continue;
            if(grid[nextx][nexty] == 1){
                q.push({nextx,nexty});
                // cout<<nextx<<","<<nexty<<endl;
                visited[nextx][nexty] = 1;
                cnt--;
            }
        }
        
    }
    return res;
}
public:
    int orangesRotting(vector<vector<int>>& grid) {
        m = grid.size();n = grid[0].size();
        visited.resize(m,vector<int>(n,0));
        int res;
        // int totalorangenum = 0;
        cnt = 0;
        queue<pair<int,int>> q;
        for(int i = 0 ; i < m ;i++){
            for(int j  = 0 ; j < n ;j++){
                if(grid[i][j] == 2){
                    q.push({i,j});
                    visited[i][j] = 1;
                    
                }
                if(grid[i][j] == 1){
                    cnt++;
                }
            }
        }
        res = bfs(grid,q);
        
        return cnt == 0 ? res:-1;

    }
};
```
记录遍历层数的方法：
> 1. 记录 queue 的 size，使用 while (size--)遍历节点，既能保证遍历完这一整层的节点了
> 2. 使用一个二维数组记录距离

```C++
if (tx < 0|| tx >= n || ty < 0|| ty >= m|| ~dis[tx][ty] || !grid[tx][ty]) continue;
                dis[tx][ty] = dis[x.first][x.second] + 1;
                Q.push(make_pair(tx, ty));
                if (grid[tx][ty] == 1){
                    cnt -= 1;
                    ans = dis[tx][ty];
                    if (!cnt) break;

```



## 最短路径
一般搜索算法流程框架：
1．定义点集 X 为已经处理的点，点集 F 为已发现但尚未处理的点
2．初始化点集 X 为空，点集 F 只包含搜索的起点
3．只要点集 F 不为空，循环 4～6：
	4．从点集 F 中取出一个点 v
	5．处理点 v，把点 v 加入点集 X
	6．遍历 v 的出边，对于每个 v 的邻居，若既不在点集 X 中也不在点集 F 中，则加入点集 F
7．搜索结束，点集 X 里的点是搜索过的点
注：F 为栈时，则算法时 DFS；若 F 是队列，则算法为 BFS。
#### 深度搜索
#### 1. 深搜应用-二叉树的遍历
##### 1.1 使用递归法
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    void travelsal(TreeNode* cur,vector<int> &res){
        if(cur == nullptr) return;
        if(cur->left) travelsal(cur->left,res);//左
        res.push_back(cur->val);//中
        if(cur->right) travelsal(cur->right,res);//右


    }

    vector<int> inorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> res;

        travelsal(root,res);
        return res;
    }
};
```


其他细节见 [[C++数据结构与算法基础#二叉树遍历方式]]

#### 广度搜索
##### 1. 无权图广度优先搜索
无权有向图按层级遍历搜索：不需要遍历完整整图就能找到答案

```C++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

// 使用BFS算法计算无权图的最短路径
vector<int> shortestPath(vector<vector<int>>& graph, int start, int end) {
    // 创建一个队列，用于存储待遍历的节点
    queue<int> q;
    // 创建一个布尔型数组，用于记录每个节点是否已经被遍历过
    vector<bool> visited(graph.size(), false);
    // 创建一个整型数组，用于记录每个节点到起始节点的距离
    vector<int> dist(graph.size(), -1);
    // 创建一个整型数组，用于记录每个节点在最短路径中的前一个节点
    vector<int> prev(graph.size(), -1);

    // 将起始节点加入队列中，并标记为已遍历
    q.push(start);
    visited[start] = true;
    dist[start] = 0;

    while (!q.empty()) {
        int curr = q.front();
        q.pop();

        for (int next : graph[curr]) {
            if (!visited[next]) {
                q.push(next);
                visited[next] = true;//标记已遍历过
                dist[next] = dist[curr] + 1;//标记到点next的最短路径
                prev[next] = curr;
            }
        }
    }

    vector<int> path;
    if (dist[end] != -1) {
        int curr = end;
        while (curr != -1) {
            path.push_back(curr);
            curr = prev[curr];
        }
        reverse(path.begin(), path.end());
    }

    return path;
}

int main() {
    int n, start, end;
    cin >> n >> start >> end;

    // 创建一个二维向量，用于存储图的邻接表表示
    vector<vector<int>> graph(n + 1);

    for (int i = 0; i < n; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
    }

    // 计算最短路径
    vector<int> path = shortestPath(graph, start, end);

    // 输出结果
    if (path.empty()) {
        cout << "无法到达目标站点" << endl;
    } else {
        cout << "最短路径为：";
        for (int i = 0; i < path.size(); i++) {
            cout << path[i];
            if (i != path.size() - 1) {
                cout << "->";
            }
        }
        cout << endl;
    }

    return 0;
}

```

#### 解释
1. 首先，我们定义了一个使用 BFS 算法计算无权图最短路径的函数 `shortestPath`，这个函数接收三个参数：一个二维向量 `graph` 表示图的邻接表，一个整数 `start` 表示起始节点的编号，一个整数 `end` 表示目标节点的编号。
2. 在函数内部，我们首先创建了一个队列 `q`，用于存储待遍历的节点。同时，我们还创建了三个向量：`visited` 用于记录每个节点是否已经被遍历过，`dist` 用于记录每个节点到起始节点的距离，`prev` 用于记录每个节点在最短路径中的前一个节点。这些向量的大小都等于图中节点的数量。
3. 接下来，我们将起始节点加入队列中，并标记为已遍历。同时，将起始节点到自己的距离设为 0。
4. 在队列不为空的情况下，我们从队列中取出第一个节点，并遍历其所有邻居节点。如果邻居节点还没有被遍历过，则将其加入队列中，并标记为已遍历。同时，将邻居节点到起始节点的距离设为当前节点到起始节点的距离加 1，并将当前节点设为邻居节点在最短路径中的前一个节点。
5. 当队列中所有节点都被遍历完毕后，我们就可以得到图中所有节点到起始节点的最短路径。具体来说，我们可以通过目标节点的 `dist` 值是否为-1 来判断是否存在从起始节点到目标节点的路径。如果存在路径，则可以通过 `prev` 数组逆向推导出这条路径上所有的节点。
6. 最后，我们将所有路径上的节点存储在一个向量 `path` 中，并返回该向量作为函数的结果。

#### 2. 有权图广度优先搜索
```C++
#include <bits/stdc++.h>
using namespace std;
const int INF = 1e6;
const int NUM = 105;
struct edge
{
    int from, to, w; // 边：起点，终点，权值。from并没用到，e[i]的i就是from
    edge(int a, int b, int c)
    {
        from = a;
        to = b;
        w = c;
    }
};
vector<edge> e[NUM]; // 存储图
struct s_node
{
    int id, n_dis; // id：结点，n_dis：这个结点到起点的距离
    s_node(int b, int c)
    {
        id = b;
        n_dis = c;
    }
    bool operator<(const s_node &a) const
    {
        return n_dis > a.n_dis;
    }
};
int n, m;
int pre[NUM];                 // 记录前驱结点
void print_path(int s, int t) // 打印从s到t的最短路径
{
    if (s == t)
    {
        printf("%d ", s); // 打印起点
        return;
    }
    print_path(s, pre[t]); // 先打印前一个点
    printf("% ", t);       // 后打印当前点，最后打印的是终点t
}
void dijkstra()
{
    int s = 1;      // 起点是1
    int dis[NUM];   // 记录所有结点到起点的距离
    bool done[NUM]; // done[i]=true表示到结点i的最短路径已经找到
    for (int i = 1; i <= n; i++)
    {
        dis[i] = INF;
        done[i] = false;
    }
    dis[s] = 0;                // 起点到自己的距离为0
    priority_queue<s_node> Q;  // 优先队列，存结点信息
    Q.push(s_node(s, dis[s])); // 起点入队
    while (!Q.empty())
    {
        s_node u = Q.top(); // pop出距离起点s最小的节点u
        Q.pop();
        if (done[u.id])
            continue; // 丢弃已经找到最短路径的结点，即集合A中的结点
        done[u.id] = true;
        for (int i = 0; i < e[u.id].size(); i++) // 检查结点u的所有邻居
        {
            edge y = e[u.id][i]; // u.id的第i个邻居是y.to
            if (done[y.to])
                continue; // 丢弃已经找到最短路径的邻居结点
            if (dis[y.to] > y.w + u.n_dis)
            {
                dis[y.to] = y.w + u.n_dis;
                Q.push(s_node(y.to, dis[y.to])); // 扩展新的邻居，放到优先队列中
                pre[y.to] = u.id;                // 记录路径
            }
        }
    }
    printf("%d\n", dis[n]);
    // print_path(s,n); //打印路径
}
int main()
{
    while (~scanf("%d%d", &n, &m))
    {
        if (n == 0 && m == 0)
            return 0;
        for (int i = 1; i <= n; i++)
            e[i].clear();
        while (m--)
        {
            int a, b, c;
            scanf("%d%d%d", &a, &b, &c);
            e[a].push_back(edge(a, b, c)); // 结点a的邻居都放在node[a]里
            e[b].push_back(edge(b, a, c));
        }
        dijkstra();
    }
}
```

### K 站中转内最便宜的航班
Todo：
![[Pasted image 20240322205937.png]]
#### 使用 dp 矩阵维护
```C++
class Solution {
public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        int MANINT = INT_MAX/2;
        vector<vector<int>>dp(k+2,vector<int>(n,MANINT));
        dp[0][src] = 0;
        for(int i = 1; i<=k+1; i++){
            for(auto flight: flights){
                int begin = flight[0],end = flight[1],cost = flight[2];
                dp[i][end] = min (dp[i-1][begin] + cost, dp[i][end]);
            }
        }
        int ans = MANINT;
        for(int i = 0 ; i<k+2; i++){
            ans = min(ans,dp[i][dst]);
        }
        return (ans == MANINT? -1 : ans);
    }
};
```
#### 使用一维 dp
```C++
class Solution {
private:
    static constexpr int INF = 10000 * 101 + 1;

public:
    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {
        vector<int> f(n, INF);
        f[src] = 0;
        int ans = INF;
        for (int t = 1; t <= k + 1; ++t) {
            vector<int> g(n, INF);
            for (auto&& flight: flights) {
                int j = flight[0], i = flight[1], cost = flight[2];
                g[i] = min(g[i], f[j] + cost);
            }
            f = move(g);
            ans = min(ans, f[dst]);
        }
        return (ans == INF ? -1 : ans);
    }
};

```
作者注：求解最短路一般有三种方法，floyd 算法，dijkstra 算法和 bellman ford 算法。这题使用 bellman ford 算法是适用性最强的，因为该算法的第 k 步就是求出的从给定起点到所有节点经过最多 k 步的最短路。如果只想到了 dijkstra 算法，说明思考方向是对的，但没有用到最合适的算法。
## 几种最短路径解法
各种算法对比：

**Bellman-Ford Algorithm**:
- **适用范围**: 含负权边的图（无向或有向）
- **不适合范围**: 仅适用于无负权边的图时效率较低

**Dijkstra Algorithm**:
- **适用范围**: 无负权边的加权图（无向或有向）
- **不适合范围**: 含负权边的图（无法正确处理）

简单来说，当图中存在负权边时，应选用Bellman-Ford算法；若图中的所有边权重均为非负，Dijkstra算法则是更高效的选择。

### Bellman ford 算法
**Bellman-Ford 算法** 是一种用于在有向图或无向图中寻找从一个指定源节点到所有其他节点的最短路径的算法，特别是在存在负权重边的情况下。该算法能够处理包含负权重边的图，这是 Dijkstra 算法所无法直接处理的场景。以下是 Bellman-Ford 算法的具体流程：
**注意：bf 算法每次遍历的是所有边，故稀疏图效果更好，稠密图效率不高**
#### **步骤详解**

1. **初始化**
    
    - 给定一个带权重的有向图 `G=(V,E)`，其中 `V` 是顶点集，`E` 是边集，每个边 `(u, v)` 都有一个权重 `w(u, v)`。
    - 定义一个源节点 `s`，我们要从该节点出发寻找最短路径。
    - 对于图中的每一个顶点 `v ∈ V`，初始化其距离值 `d[v]`：
        - 若 `v = s`，则 `d[v] = 0`，表示源节点到自身的距离为零；
        - 若 `v ≠ s`，则 `d[v] = ∞`，表示源节点到其它节点的初始距离视为无穷大。
2. **松弛操作（Relaxation）**
    
    - 重复执行以下过程 `|V| - 1` 次，即进行 `V` 个顶点减去源节点数量的迭代（因为源节点的距离已经正确初始化为零）：
        - 遍历图中的每一条边 `(u, v) ∈ E`：
            - 计算以当前距离信息为基础的新路径长度：`newDist = d[u] + w(u, v)`。
            - 如果新路径长度 `newDist` 小于当前已知的从源节点到顶点 `v` 的距离 `d[v]`，说明找到了一条更短的路径，则更新 `d[v]` 为 `newDist`，并可记录前驱节点以恢复路径（如果需要）。
3. **检查负权环检测**
    
    - 在完成上述 `|V| - 1` 次迭代后，再对所有的边进行一次遍历，执行最后一次松弛操作。
    - 如果在这次遍历中仍能找到任何一条边 `(u, v)` 使得 `d[v] > d[u] + w(u, v)`，说明存在一条从源节点出发经过若干条边后又回到某顶点的路径，且这条路径上的总权重之和小于之前计算出的该顶点到源节点的距离，这意味着图中存在负权环。
    - 若没有发现这样的边，即所有边都无法继续缩短现有距离，那么当前得到的 `d[v]` 对于所有顶点 `v` 即是从源节点 `s` 到 `v` 的最短路径长度。
### **总结**

Bellman-Ford 算法通过反复执行松弛操作来逐步改进距离估计，直至达到稳定状态或者检测到负权环。该算法的时间复杂度为 `O(|V|·|E|)`，其中 `|V|` 是顶点数，`|E|` 是边数。尽管在最坏情况下效率低于 Dijkstra 算法对于正权图的情况，但它能够处理负权边，使得其在特定应用场景中具有不可替代性。同时，若图中不存在负权环，算法在完成指定次数的迭代后即可确保得到正确的最短路径信息；若检测到负权环，则可以立即报告图中存在此类结构，这对于某些问题的求解至关重要。
使用邻接表：
```C++
void bellmanFord(Graph& graph, int source, std::vector<long long>& distances, std::vector<int>& predecessors) {

    const int numVertices = graph.adjList.size();
    distances.resize(numVertices, std::numeric_limits<long long>::max()); // 初始化距离向量，将所有节点到源节点的距离设为无穷大（除了源节点本身）
    predecessors.resize(numVertices, -1); // 初始化前驱节点向量，设置默认值为-1（表示尚未确定）

    distances[source] = 0; // 源节点到自身的距离为0

    // 主循环进行 |V| - 1 次松弛操作，|V|为节点数
    for (int i = 0; i < numVertices - 1; ++i) {
        for (const auto& edge : graph.adjList) { // 遍历所有节点的邻接列表
            for (const Edge& e : edge) { // 遍历节点的所有出边
                int u = e.from, v = e.to;
                long long newDist = distances[u] + e.weight; // 计算新的距离估计

                // 如果新距离小于当前已知距离，更新距离和前驱节点
                if (newDist < distances[v]) {
                    distances[v] = newDist;
                    predecessors[v] = u;
                }
            }
        }
    }

    // 负权环检测：再进行一次遍历，此时若有边还能继续缩短距离，则存在负权环
    bool hasNegativeCycle = false;
    for (const auto& edge : graph.adjList) {
        for (const Edge& e : edge) {
            int u = e.from, v = e.to;
            if (distances[u] != std::numeric_limits<long long>::max() && distances[u] + e.weight < distances[v]) {
                hasNegativeCycle = true;
                break; // 发现一条能继续缩短距离的边，立即终止循环
            }
        }
        if (hasNegativeCycle) {
            break; // 发现负权环，无需继续检查剩余边
        }
    }

    // 根据负权环检测结果输出相应信息
    if (hasNegativeCycle) {
        std::cout << "Graph contains a negative-weight cycle.\n";
    } else {
        // 此处应根据实际需求处理最短路径结果，如打印、返回给调用者等
        // ...
    }
}
```

使用距离表
```C++
for (int i = 0; i < V - 1; ++i) {
	for (const auto& edge : graph.edges) {
		int u = edge.from, v = edge.to, w = edge.weight;
		if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
			dist[v] = dist[u] + w;
			predecessor[v] = u;//储存路径
		}
	}
}

// 检测负权环
bool hasNegativeCycle = false;
for (const auto& edge : graph.edges) {
	int u = edge.from, v = edge.to, w = edge.weight;
	if (dist[u] != INT_MAX && dist[u] + w < dist[v]) {
		hasNegativeCycle = true;
		break;
	}
}

if (hasNegativeCycle) {
	throw std::runtime_error("Graph contains a negative-weight cycle.");
    }
```

#### 例题，带负权边图的最小路径写法
```C++
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main() {
    int n, m, p1, p2, val;
    cin >> n >> m;

    vector<vector<int>> grid;

    // 将所有边保存起来
    for(int i = 0; i < m; i++){
        cin >> p1 >> p2 >> val;
        // p1 指向 p2，权值为 val
        grid.push_back({p1, p2, val});

    }
    int start = 1;  // 起点
    int end = n;    // 终点

    vector<int> minDist(n + 1 , INT_MAX/2);
    minDist[start] = 0;
    for (int i = 1; i < n; i++) { // 对所有边 松弛 n-1 次
        for (vector<int> &side : grid) { // 每一次松弛，都是对所有边进行松弛
            int from = side[0]; // 边的出发点
            int to = side[1]; // 边的到达点
            int price = side[2]; // 边的权值
            // 松弛操作 
            // minDist[from] != INT_MAX/2 防止从未计算过的节点出发
            if (minDist[to] > minDist[from] + price && minDist[from] != INT_MAX/2) { 
                minDist[to] = minDist[from] + price;  
            }
        }
    }
    if (minDist[end] == INT_MAX/2) cout << "unconnected" << endl; // 不能到达终点
    else cout << minDist[end] << endl; // 到达终点最短路径

}
```

### Dijkstra 求最短路


#### 使用优先队列来优化
```C++
#include <bits/stdc++.h>
using namespace std;

const int INF = INT_MAX;

// 定义节点结构体，包含节点ID、到源节点的距离、前驱节点ID以及是否已访问标志
struct Node {
    int id;
    int distance;
    int predecessor = -1; // 前驱节点ID，-1表示无前驱
    bool visited = false;
};

// Dijkstra算法实现，输入为邻接表形式的图、源节点索引以及节点列表
void dijkstra(const vector<vector<pair<int, int>>>& adj_list, int src, vector<Node>& nodes) {
    // 初始化所有节点的距离为无穷大，源节点距离设为0
    for (Node& node : nodes) {
        node.distance = INF;
    }
    nodes[src].distance = 0;

    // 创建一个优先队列，按节点距离大小进行排序
    priority_queue<Node, vector<Node>, greater<>> pq;
    pq.push(nodes[src]);

    while (!pq.empty()) {
        // 弹出队首距离最小的节点
        Node current = pq.top();
        pq.pop();

        if (current.visited) {
            continue; // 若已访问过该节点，则跳过
        }

        current.visited = true;

        // 遍历当前节点的所有出边，探索其邻居节点
        for (const pair<int, int>& edge : adj_list[current.id]) {
            int neighbor_id = edge.first;
            int weight = edge.second;
            int new_distance = current.distance + weight;

            // 如果找到一条更短的路径到达邻居节点，更新其距离和前驱节点
            if (new_distance < nodes[neighbor_id].distance) {
                nodes[neighbor_id].distance = new_distance;
                nodes[neighbor_id].predecessor = current.id; // 更新前驱节点
                pq.push(nodes[neighbor_id]); // 将更新后的邻居节点重新插入优先队列
            }
        }
    }
}

// 回溯并输出从源节点到目标节点的最短路径所经过的节点
void print_shortest_path(vector<Node>& nodes, int src, int target) {
    vector<int> path;
    int current = target;
    while (current != -1) { // 当前节点不是源节点时继续回溯
        path.push_back(current);
        current = nodes[current].predecessor;
    }
    reverse(path.begin(), path.end()); // 反转路径，使其从源节点到目标节点顺序排列

    cout << "Shortest path from node " << src + 1 << " to node " << target + 1 << ": ";
    for (int node_id : path) {
        cout << node_id + 1 << " "; // 打印节点编号（恢复为从1开始的形式）
    }
    cout << endl;
}

int main(int argc, char* argv[]) {
    // 示例用法：
    // 从标准输入读取数据，输出到标准输出
    int n, m; // 节点数量和边数量
    cin >> n >> m;

    // 初始化节点列表
    vector<Node> nodes(n);
    for (Node& node : nodes) {
        node.distance = INF;
    }

    // 读取边信息并构建邻接表
    vector<vector<pair<int, int>>> adj_list(n);
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w; // 边的两个端点和权重
        --u, --v; // 通常ACM题目节点编号从1开始，转换为从0开始的索引
        adj_list[u].push_back({v, w}); // 添加边至邻接表
        adj_list[v].push_back({u, w}); // 若图无向，添加反向边（如有需要可省略此行）
    }

    int src, target;
    cin >> src >> target; // 读取源节点和目标节点编号
    --src, --target; // 转换为从0开始的索引

    dijkstra(adj_list, src, nodes);

    // 输出结果
    cout << "Shortest distance from node " << src + 1 << " to node " << target + 1 << ": " << nodes[target].distance << endl;
    print_shortest_path(nodes, src, target); // 输出最短路径所经过的节点

    return 0;
}
```
##### 添加输出最短路径功能
记录每个节点上一个最近的 pre，reverse 后输出即可
```C++
void PrintPath(vector<int> &preNode,int x,int y){
    int cur = y;
    vector<int> path;
    path.push_back(y);
    while (preNode[cur]!= x)
    {
        cur = preNode[cur];
        path.push_back(cur);
    }
    path.push_back(x);
    reverse(path.begin(),path.end());
    for(auto it:path){
        cout<<it<<" ";
    }
    cout<<endl;
}
```

#### Dijstra 算法例题
```C++
// dijkstra求最短路
#include <bits/stdc++.h>
using namespace std;

const int inf = 0x3f3f3f3f;

int main() {
    int n, m;
    while (cin >> n >> m) {
        // 建图
        vector<vector<int>> g(n + 1, vector<int>(n + 1, inf));
        for (int i = 0; i < m; ++i) {
            int a, b, w;
            cin >> a >> b >> w;
            g[a][b] = min(g[a][b], w);
            g[b][a] = min(g[b][a], w);
        }
        
        int x, y;
        cin >> x >> y;
        
        vector<int> dist(n + 1, inf); // dist[i]: x->i的最短距离
        dist[x] = 0;
        vector<int> st(n + 1); // st[i]: dist[i]是否已经确定
        while (1) {
            // 找出还未确定最短路的点里面，距离x最近的点t
            int t = -1;
            for (int i = 1; i <= n; ++i) {
                if (!st[i] && (t == -1 || dist[i] < dist[t])) {
                    t = i;
                }
            }
            
            // 非连通或找到x->y的最短路了
            if (t == -1 || dist[t] == inf || st[t] || t == y) { 
                break;
            }
            st[t] = true;
            
            for (int i = 1; i <= n; ++i) {
                // 用dist[t]更新s到其它点的距离
                if (!st[i]) dist[i] = min(dist[i], dist[t] + g[t][i]);
            }
        }
        if (dist[y] >= inf) cout << "No path" << endl;
        else cout << dist[y] << endl;
    }
    
    return 0;
}
```

#### 访问消失节点的最少时间
![[Pasted image 20240414155005.png]]
流程：
>1. 制作稀疏图邻接表（关键：无向图要两边都添加）
```C++
for (auto edge : edges)
{
	Graph[edge[0]] .push_back ({edge[1], edge[2]});
	Graph[edge[1]] .push_back ({edge[0], edge[2]});
}
```
> 2. 初始化 `dist` 数组，其为到原点的最小距离, `dist[0] = 0`,0 为起点
> 3. 使用优先队列进行维护

```C++
priority_queue< pair<int,int>, vector<pair<int,int>> , greater<> > pq;
pq.push({0,0});
while (!pq.empty())
{
	auto curr = pq.top();
	int curnode = curr.second,curdis = curr.first;
	pq.pop();
	//若当前距离比历史距离还大，直接跳过
	if ( curdis> dist[curnode]) continue;
	//遍历相邻所有点
	for (auto node : graph[curnode])
	{
		int newdis = node.second + curdis;
		int newnode = node.first;
	//当存在更短路径时更新更短路
		if ( (dist[newnode] > newdis || dist[newnode] == -1 )&& newdis< disappear[newnode] )
		{
			pq.push({newdis,newnode});
			dist[newnode] = newdis;
		}
	}
}
```
本体与 dijistra 不同关键在于需要判断节点是否消失，即 $dist[node]<disappear[node]$

##### 完整代码
```C++
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> minimumTime(int n, vector<vector<int>>& edges, vector<int>& disappear) {
        vector<int> dist(n,-1);
        vector<vector<pair<int,int>>> graph(n);
        //制作稀疏图
        for (auto edge : edges)
        {
            graph[edge[0]] .push_back({edge[1],edge[2]});
            graph[edge[1]] .push_back({edge[0],edge[2]});
        }
        unordered_map<int,int> disappeartime;
        for(int i = 0; i<disappear.size();i++) disappeartime[i] = disappear[i];
        for(int i = disappear.size(); i<n;i++) disappeartime[i] = INT_MAX;
        dist[0] = 0;
        // dijiska
        priority_queue< pair<int,int>, vector<pair<int,int>> , greater<> > pq;
        pq.push({0,0});
        while (!pq.empty())
        {
            auto curr = pq.top();
            int curnode = curr.second,curdis = curr.first;
            pq.pop();
            if ( curdis> dist[curnode]) continue;

            for (auto node : graph[curnode])
            {
                int newdis = node.second + curdis;
                int newnode = node.first;

                if ( (dist[newnode] > newdis || dist[newnode] == -1 )&& newdis< disappear[newnode] )
                {
                    pq.push({newdis,newnode});
                    dist[newnode] = newdis;
                }
            }
        }
        return dist;
    }
}; 
```

## 拓扑排序
### 判断图是否有环
[图中是否有环算法](https://www.cnblogs.com/TenosDoIt/p/3644225.html#:~:text=%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%9B%BE%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF%201%20%E6%B1%82%E5%87%BA%E5%9B%BE%E4%B8%AD%E6%89%80%E6%9C%89%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6%EF%BC%8C%202,%E5%88%A0%E9%99%A4%E5%9B%BE%E4%B8%AD%E6%89%80%E6%9C%89%E5%BA%A6%3C%3D1%E7%9A%84%E9%A1%B6%E7%82%B9%E4%BB%A5%E5%8F%8A%E4%B8%8E%E8%AF%A5%E9%A1%B6%E7%82%B9%E7%9B%B8%E5%85%B3%E7%9A%84%E8%BE%B9%EF%BC%8C%E6%8A%8A%E4%B8%8E%E8%BF%99%E4%BA%9B%E8%BE%B9%E7%9B%B8%E5%85%B3%E7%9A%84%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6%E5%87%8F%E4%B8%80%203%20%E5%A6%82%E6%9E%9C%E8%BF%98%E6%9C%89%E5%BA%A6%3C%3D1%E7%9A%84%E9%A1%B6%E7%82%B9%E9%87%8D%E5%A4%8D%E6%AD%A5%E9%AA%A42%204%20%E6%9C%80%E5%90%8E%E5%A6%82%E6%9E%9C%E8%BF%98%E5%AD%98%E5%9C%A8%E6%9C%AA%E8%A2%AB%E5%88%A0%E9%99%A4%E7%9A%84%E9%A1%B6%E7%82%B9%EF%BC%8C%E5%88%99%E8%A1%A8%E7%A4%BA%E6%9C%89%E7%8E%AF%EF%BC%9B%E5%90%A6%E5%88%99%E6%B2%A1%E6%9C%89%E7%8E%AF)
#### 无向图
**算法1**

我们知道对于环1-2-3-4-1，每个节点的度都是2，基于此我们有如下算法（这是类似于有向图的拓扑排序）：

1. 求出图中所有顶点的度，
2. 删除图中所有度<=1的顶点以及与该顶点相关的边，把与这些边相关的顶点的度减一
3. 如果还有度<=1的顶点重复步骤2
4. 最后如果还存在未被删除的顶点，则表示有环；否则没有环

时间复杂度为O（E+V），其中E、V分别为图中边和顶点的数目，这个算法我们稍后分析算法3的时候再分析。

**算法2**

深度优先遍历该图，如果在遍历的过程中，发现某个节点有一条边指向已经访问过的节点，并且这个已访问过的节点不是当前节点的父节点（这里的父节点表示dfs遍历顺序中的父节点），则表示存在环。但是我们不能仅仅使用一个bool数组来标志节点是否访问过。如下图

[![image](https://images0.cnblogs.com/blog/517264/201404/032345090319800.png "image")](https://images0.cnblogs.com/blog/517264/201404/032345087814344.png)

#### 有向图
拓扑排序
### 拓扑排序算法流程
1. 统计所有节点的入度
2. 建立 stack 用于存储入度为 0 的节点（初始点），遍历边
3. 对下一节点进行处理, 如果入度为 0，则入栈
```C++
while(!st.empty()){
	int cur = st.top();
	int next = edge[cur];
	INdeg[next]--;
	if(INdeg[next] == 0) st.push(next);
}
```
4. 判断其他所有节点入度，若存在入度为 0 的节点，则认为有环。
### 课程表
![[Pasted image 20240315130237.png]]
#### 解法
考虑到需要统计该有向图中不存在环，可以使用入度进行统计与广度优先搜索，最终看所有节点是否入度为 0.
```C++
class Solution {
private:
vector<vector<int>> graph;

vector<int> InDeg;
int graphsize;
void bfs(){
    // cout<<"IN"<<graphsize<<endl;
    queue<int> q;
    for(int i = 0; i<graphsize; i++){
        // cout<<i<<": "<<InDeg[i]<<",  ";
        if(InDeg[i] == 0){
            q.push(i);
        }
    }
    while(!q.empty()){
        int tmpNode = q.front();
        q.pop();
        for(int i:graph[tmpNode]){
            InDeg[i] -- ;
            if(InDeg[i] == 0){
                q.push(i);
            }
        }
    }
    return;
}
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        // if(prerequisites.size() == 0) return true;
        graphsize = numCourses; 
        graph.resize(graphsize);
        InDeg.resize(graphsize,0);

        for(const auto &vec : prerequisites ){
            graph[vec[1]].push_back(vec[0]);
            InDeg[vec[0]]++;
        }

        bfs();
        for(int i: InDeg){
            if(i>0) return false;
        }
        return true;
       

    }
};
```

## 矩阵中的最长递增路径
![[Pasted image 20240408184652.png]]
### 记忆化深度优先搜索
```C++
#include <bits/stdc++.h>
using namespace std;

class Solution
{
private:
    int m, n;
    int dir[4][2] = {-1, 0, 1, 0, 0, 1, 0, -1};
    vector<vector<int>> visited;
    vector<vector<int>> depth;

    int dfs(vector<vector<int>> &matrix, int curx, int cury)
    {
        if(visited[curx][cury] != 0) return visited[curx][cury];
        visited[curx][cury]++;
        for (int i = 0; i < 4; i++)
        {
            int newx = curx + dir[i][0];
            int newy = cury + dir[i][1];
            if ( newx >= 0 && newx < m && newy >= 0 && newy < n 
                && matrix[newx][newy] > matrix[curx][cury] )
            {
                int dist = dfs(matrix,newx,newy) +1;
                visited[curx][cury] = max(visited[curx][cury],dist);
            }
        }
        
        return visited[curx][cury];
    }

public:
    int longestIncreasingPath(vector<vector<int>> &matrix)
    {
        int res = 0;
        m = matrix.size(), n = matrix[0].size();
        visited.resize(m, vector<int>(n));
        for(int i = 0; i<m;i++){
            for(int j = 0; j<n; j++){
                int curdepth = dfs(matrix, i, j);
                res = max(res, curdepth);
            }
        }

        return res;
    }
};
```
在该记忆化搜索中，使用 `visited` 二维数组保存每个点的最大深度（即每次搜索时，特定点的最大深度是确定的）。
`visited[i][j]` 为 0 时说明该节点未初始化，该节点的最小深度为 1，之后深搜四周节点，取深度最深值即可。
`visited[i][j]` 不为 0 时说明该节点已经搜索过，直接返回即可。

## 青蛙过河
![[Pasted image 20240408210933.png]]
假设 $dp[i][k]$ 为跳到第 i 个石头上应该用步长为 k 时的可能性（true or false）
这样我们可以写出状态转移方程： 
$$dp[i][k]=dp[j][k-1]\bigvee dp[j][k]\bigvee dp[j][k+1]$$
 式中 $j$ 代表了青蛙的「上一次所在的石子编号」, 满足 $stones[i]-$
 $stones[j]=k$ , 即遍历 $j∈[0,i-1]$

排除肯定跳不到石头上的可能性
```C++
for(int i = 1; i<n; i++){
	if( (stones[i] - stones[i-1]) >i ) return false;
}
```


```C++
class Solution {
public:
    bool canCross(vector<int>& stones) {
        int n  = stones.size();
        vector<vector<bool>> dp(n,vector<bool>(n,false) );
        dp[0][0] = true;
        for(int i = 1; i<n; i++){
            if( (stones[i] - stones[i-1]) >i ) return false;
        }
        for(int i = 1; i<n; i++){
            for(int j = i-1; j>=0; j--){
                int k = stones[i] - stones[j];
                if(k>j+1) break; // 剪枝，过远，肯定跳不上
                dp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1];
                if(i == n-1 && dp[i][k]) return true;
            }
            
        }
        return false;
    }
};
```

### 动态规划
```C++

```
# 单调栈
## 单调栈简介
单调栈是一种和单调队列类似的数据结构。单调队列主要用于 $O(n)$ 解决滑动窗口问题，单调栈则主要用于 $O(\overline{n)}$ 解决 NGE 问题 (Next Greater Element), 也就是，对序列中每个元素，找到下一个比它大的元素。(当然，“下一个”可以换成“上一个”,“比它大”也可以换成“比他小”, 原理不变。)
单调栈保证了栈内的元素一定是顺序排列的
### 单调栈伪代码 :
```C++
stack<int> st;
//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解
for (遍历这个数组)
{
	if (栈空 || 栈顶元素大于等于当前比较元素)
	{
		入栈;
	}
	else
	{
		while (栈不为空 && 栈顶元素小于当前元素)
		{
			栈顶元素出栈;
			更新结果;
		}
		当前数据入栈;
	}
}
```

## 每日温度
![[Pasted image 20240313104522.png]]

```C++
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        stack<int> st; // 递增栈
        vector<int> result(T.size(), 0);
        for (int i = 0; i < T.size(); i++) {
            while (!st.empty() && T[i] > T[st.top()]) { // 注意栈不能为空
                result[st.top()] = i - st.top();
                st.pop();
            }
            st.push(i);
        }
        return result;
    }
};
```

## 496. 下一个更大元素 I
![[Pasted image 20240313111620.png]]

```C++
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        vector<int> res(nums1.size());
        unordered_map<int,int> mp;
        stack<int>st;
        for(int i = 0; i<nums2.size(); i++){
            mp[nums2[i]] = -1;
            while(!st.empty() && nums2[i] > nums2[st.top()]){
                mp[nums2[st.top()]] = nums2[i];
                st.pop();
            }
            st.push(i);
        }
        for(int i = 0;i< nums1.size();i++){
            res[i] = mp[nums1[i]];
        }
        return res;
    }
};
```

## 下一个更大元素
![[Pasted image 20240316110217.png]]
### 思路：
将两个 `nums` 拼接起来作为一个数组，本题将和上体思路完全一致，直接寻找下一个最大元素即可。
```C++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        
        int size = nums.size();
        vector<int> extendnums(size*2);
        nums.insert(nums.end(),nums.begin(),nums.end());

        vector<int> tmpres(size*2,-1);
        stack<int> st;

        for(int i = 0;i < size*2; i++){
            if(st.empty()){
                st.push(i);
                continue;
            } 
            while( !st.empty() && nums[st.top()] < nums[i] ){
                tmpres[st.top()] = nums[i];
                st.pop();
                // i++;
            }
            st.push(i);
        }
        tmpres.resize(size);
        return tmpres;
    }
};
```

### 精简方案：
直接对 n 取模即可
```C++
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        int n = nums.size();
        vector<int> ret(n, -1);
        stack<int> stk;
        for (int i = 0; i < n * 2 - 1; i++) {
            while (!stk.empty() && nums[stk.top()] < nums[i % n]) {
                ret[stk.top()] = nums[i % n];
                stk.pop();
            }
            stk.push(i % n);
        }
        return ret;
    }
};
```

## 接雨水
![[Pasted image 20240316135110.png]]
### 单调栈写法
```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        stack<int> st;
        st.push(0);
        for(int i = 1 ; i<height.size(); i++){
            while(!st.empty() && height[st.top()]< height[i]  ){
                // cout<<st.top()<<",";
                int midheight = height[st.top()];
                st.pop();
                if(!st.empty()){
                    int h = min(height[i],height[st.top()]) - midheight;
                    int w = (i-st.top()-1);
                    res+= h*w;
                }
            }
            st.push(i);
        }
        return res;
    }
};
```
## 柱状图中最大的矩形
![[Pasted image 20240319144516.png]]
### 思路
1. 对于一个高度，如果能得到向左和向右的边界
2. 那么就能对每个高度求一次面积
3. 遍历所有高度，即可得出最大面积
4. 使用单调栈，在出栈操作时得到前后边界并计算面积

#### 初始化
```C++
vector<int> leftless(size,-1);
vector<int> rightless(size,size);
```
左边界初始为-1, 右边界初始为 `size`


```C++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int res = 0;
        int size = heights.size();
        vector<int> leftless(size,-1);
        vector<int> rightless(size,size);
        stack<int>st;
        // cout<<"hi"<<endl;
        for(int i  =0; i< size;i++){
            while(!st.empty() && heights[st.top()] > heights[i] ){
                rightless[st.top()] = i;
                st.pop();
            }
            st.push(i);
        }
        // cout<<"hi"<<endl;
        while(!st.empty())
            st.pop();
        
        // cout<<"hi"<<endl;
        for(int i  = size -1; i >= 0;i--){
            while(!st.empty() && heights[st.top()] > heights[i] ){
                leftless[st.top()] = i;
                st.pop();
                
            }
            st.push(i);
        }
        // cout<<"hi"<<endl;
        for(int i  = 0; i< size;i++){
            int tmpSqure = (rightless[i] - leftless[i]-1) * heights[i];
            res = res < tmpSqure ? tmpSqure : res;
        }
        // cout<<"hi"<<endl;
        return res;

    }
};
```

### 最大矩形
![[Pasted image 20240409122529.png]]
思路：
1. 统计出每行各值的高度
2. 用上一题的方案，分别用单调栈计算左右小于高度边界，算出这一行的最大矩形面积
```C++
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        int m = matrix.size(),n = matrix[0].size();
        vector<vector<int>> coldp(m,vector<int>(n,0));//列dp

        for(int j = 0; j<n; j++) coldp[0][j] = (matrix[0][j] == '1');
        for(int i = 1; i<m; i++){//列最大长度
            for(int j = 0; j<n; j++){
                if(matrix[i][j] == '1') coldp[i][j] = coldp[i-1][j] +1;
            }
        }

        int res = 0;
        for(int i = 0; i<m; i++){
            stack<int> st1;
            stack<int> st2;
            vector<int> leftless(n,-1);
            vector<int> rightless(n,n);

            for(int j = 0; j<n; j++){
                while (!st1.empty() && coldp[i][j] < coldp[i][st1.top()])
                {
                    rightless[st1.top()] = j;
                    st1.pop();
                }
                st1.push(j);
            }
            for(int j = n-1; j>=0; j--){
                while (!st2.empty() && coldp[i][j] < coldp[i][st2.top()])
                {
                    leftless[st2.top()] = j;
                    st2.pop();
                }
                st2.push(j);
            }
            for(int j = 0; j<n; j++){
                res = max(res, (rightless[j] - leftless[j] - 1) * coldp[i][j] );
            }

        }
        return res;
    }
};
```

##  边界元素是最大值的子数组数目
![[Pasted image 20240414200439.png]]
思路：子数组题目都可以通过遍历右端点来进行搜索
此题关键在于单调栈的构建，因为存储数据是，如果中有有更大的点，便不能形成两端是最大值的子数组，故可使用单调栈维护数据。但值得注意的是，栈顶有几个和右端点相同的值，就有几个子数组，所以还应该维护一下目前栈内元素的频率。
```C++
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    long long numberOfSubarrays(vector<int>& nums) {
        long long res = nums.size() ;
        stack<pair<int,int>> st;//pair->nums,freq
        for (int i = 0; i < nums.size(); i++)
        {
            while (!st.empty () && st.top().first < nums[i])
            {
                st.pop();
            }
            if(!st.empty () && st.top().first == nums[i]){
                res+=st.top().second;
                st.top().second++;
            }
            else st.push({nums[i],1});
        }
        return res;

    }
};
```

## 找出最具竞争力的子序列
![[Pasted image 20240524104518.png]]
思路：
1. 创建一个空栈。
2. 从左到右遍历 $nums$。
3. 设 $x=nums[i]$。如果栈不为空，且 x 小于栈顶元素，且栈的大小加上剩余元素个数 $(n-i+st.size())$ 大于 k，则可以弹出栈顶。不断循环直到不满足这三个条件之一。
4. 如果栈的大小小于 k，把 x 入栈。
5. 遍历结束，栈（从底到顶的顺序）就是答案。

```C++
class Solution {
public:
    vector<int> mostCompetitive(vector<int>& nums, int k) {
        stack<int> st;
        vector<int> res;
        int n = nums.size();
        for(int i = 0; i<n; i++){
            while( !st.empty() && nums[i]<st.top() && (n-i+st.size())>k ){
                // cout<<"POP:  "<<st.top()<<endl;
                st.pop();
            }
            st.push(nums[i]);
            // cout<<"pushIn:  "<<nums[i]<<endl;
        }
        // cout<<"done"<<endl;
        while(!st.empty()){
            if(st.size()<=k) res.push_back(st.top());
            st.pop();
        }
        reverse(res.begin(), res.end());
        return res;

    }
};
```





# 堆（优先队列）/滑动窗口
## 滑动窗口+双指针
![[Pasted image 20240409165422.png]]

### 最小子串长度
```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```

### 最小区间
![[Pasted image 20240409165357.png]]

```C++
#include<bits/stdc++.h>
using namespace std;

class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        int n = nums.size();
        unordered_map<int, vector<int>> indices;
        int xMin = INT_MAX, xMax = INT_MIN;
        for (int i = 0; i < n; ++i) {
            for (const int& x: nums[i]) {
                indices[x].push_back(i);
                xMin = min(xMin, x);
                xMax = max(xMax, x);
            }
        }

        vector<int> freq(n);
        int inside = 0;
        int left = xMin, right = xMin - 1;
        int bestLeft = xMin, bestRight = xMax;

        while (right < xMax) {
            ++right;
            if (indices.count(right)) {
                for (const int& x: indices[right]) {
                    ++freq[x];
                    if (freq[x] == 1) {
                        ++inside;
                    }
                }
                while (inside == n) {
                    if (right - left < bestRight - bestLeft) {
                        bestLeft = left;
                        bestRight = right;
                    }
                    if (indices.count(left)) {
                        for (const int& x: indices[left]) {
                            --freq[x];
                            if (freq[x] == 0) {
                                --inside;
                            }
                        }
                    }
                    ++left;
                }
            }
        }

        return {bestLeft, bestRight};
    }
};

```
### 找出最长等值子数组
![[Pasted image 20240523141607.png]]
思路：可以保存所有相同数字的索引，然后使用滑动窗口统计，在满足条件下，最多能包含多少个相同的数字。
```C++
/*
	以3为例，数组为
id	0	1	2
num	1	3	5
```
则对于一个窗口区间而言，需要删除的数字个数为：
$list[r] - list[l] +1 - (r-l+1))$
只要该值小于等于 k，即可认为窗口合法，记录下最大
```C++
class Solution {
public:
    int longestEqualSubarray(vector<int>& nums, int k) {
        int n = nums.size();
        if(n<=1) return n;
        vector<vector<int>> pos_list(n+1);
        for(int i = 0; i<n; i++){
            pos_list[nums[i]].push_back(i);
        }
        int res = 1;
        for(auto list: pos_list){
            // for(int num: list) cout<<num<<" ";
            // cout<<endl;

            int n = list.size();
            if(n == 1) continue;
            int l = 0, r = 1;
            while(r<n){
                // cout<<"listmins:  "<<(list[r] - list[l] - (r-l+1))<<endl;
                while( l<r && (list[r] - list[l] - (r-l)) > k ){
                    l++;
                }
                res = max(r-l+1,res);
                // cout<<l<<" "<<r<<" "<<res<<endl;
                r++;
            }
        }
        return res;
    }
};
```


## 定长滑动窗口
![[Pasted image 20240520170136.png]]
思路：使用定长滑动窗口统计一段时间内因为老板生气气走的人最大值，同时累计顾客人流量，最后相加两者即可。时间复杂度 $O(n)$。
```C++
class Solution {
public:
    int maxSatisfied(vector<int>& customers, vector<int>& grumpy, int minutes) {
        int calm_Customers =0;
        int res = 0;
        int n = customers.size();
        for(int i = 0;i<minutes;i++){
            if(grumpy[i]){
                calm_Customers+=customers[i];
            }
            res+=(!grumpy[i])*customers[i];
        }
        int max_calm_customers = calm_Customers;
        for(int i = minutes; i<n; i++){
            if(grumpy[i-minutes]) calm_Customers-=customers[i-minutes];
            if(grumpy[i]) calm_Customers+=customers[i];
            max_calm_customers = max(max_calm_customers , calm_Customers);
            res+=(!grumpy[i])*customers[i];
        }
        res+=max_calm_customers;
        return res;
    }
};
```
## 优先队列
### 使用两个堆寻找中位数
![[Pasted image 20240330200407.png]]
思路：使用两个优先队列维护数组左右各一半数据
其中左队列为 less 队列，右为 greater 队列，且始终尽量保持 left 的 top 比 right 的 top 小，同时
```C++
class MedianFinder {
private:
// vector<double> vec;
priority_queue<int> left;
priority_queue<int,vector<int>,greater<int>> right;
// int totalSize = 0;
public:
    MedianFinder() {
        // totalSize = 0;
        while(!right.empty()) right.pop();
        while(!left.empty()) left.pop();
    }
    
    void addNum(int num) {
        int size_l = left.size();
        int size_r = right.size();
        //比较两边优先队列的元素个数是否相等，再细分操作
        if (size_l == size_r) {
            //如果右边是空的，则是刚开始情况，直接加到左边队列；如果比右边最小的小，则加到左边
            if (size_r == 0 || num <= right.top()) left.push(num);
            else if (num > right.top()) {//如果是要加到右边，则要将右边的最小值移到左边
                int tmp = right.top();
                right.pop();
                right.push(num);
                left.push(tmp);
            }
        } else {//此时左边比右边多一个（这是我们一开始人为设定的情况）
            if (num >= left.top()) right.push(num);
            else {
                //如果是要加到左边，则要把左边的最大值移到右边队列
                int tmp = left.top();
                left.pop();
                right.push(tmp);
                left.push(num);
            }
        }

    }
    
    double findMedian() {
        int size_l = left.size();
        int size_r = right.size();
        if (size_l == size_r) //偶数情况
            return (left.top() + right.top()) / 2.0;
        else //奇数情况
            return left.top(); 
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

## 使用两个堆维护中位数和延迟删除
### 保持平衡

如果 $small$ 和 $large$ 中的元素个数满足要求，则不进行任何操作
如果 $small$ 比 $large$ 的元素个数多了 2 个，那么我们我们将 $small$ 的堆顶元素放入 $large$。此时 $small$ 的对应元素可能是需要删除的。
如果 $small$ 比 $large$ 的元素个数少了 1 个，那么我们将 $large$ 的堆顶元素放入 $small$。此时 $large$ 的对应的元素可能是需要删除的。

```C++
void keepBalance(bool toSmall,int x){
	if(toSmall){
		big.push(x);
		small.push(big.top());
		big.pop();
	}else{
		small.push(x);
		big.push(small.top());
		small.pop();
	}
}
```

```C++
if(left<=small.top()){//如果要删除的元素在small堆中，则要把small堆大小加一
	keepBalance(true,nums[i]);
}
else{//否则big堆大小加一
	keepBalance(false,nums[i]);
}
```

#### 延迟删除
使用哈希维护窗口移除的数据，每次搜索中位数时如果该数据在顶端，则删除该数据。
```C++
unordered_map<int, int> mp;//懒堆维护哪些数据要出去
double getMedian(int& k){
	while(!small.empty() && mp[small.top()]>0){//去除已经不在堆中的元素
			mp[small.top()]--;
			small.pop();
		}
	while(!big.empty() && mp[big.top()]>0){
			mp[big.top()]--;
			big.pop();
		}
	if(k&1) return small.top();
	else return ((long long)big.top()+small.top())*0.5;
}
```
#### 完整代码
```C++
class Solution {
public:
    priority_queue<int> small;    //大顶堆维护小的一部分
    priority_queue<int, vector<int>, greater<int>> big; //小顶堆维护大的一部分
    unordered_map<int, int> mp;//懒堆维护哪些数据要出去
    double getMedian(int& k){
        while(!small.empty() && mp[small.top()]>0){//去除已经不在堆中的元素
                mp[small.top()]--;
                small.pop();
            }
        while(!big.empty() && mp[big.top()]>0){
                mp[big.top()]--;
                big.pop();
            }
        if(k&1) return small.top();
        else return ((long long)big.top()+small.top())*0.5;
    }
    void keepBalance(bool toSmall,int x){
        if(toSmall){
            big.push(x);
            small.push(big.top());
            big.pop();
        }else{
            small.push(x);
            big.push(small.top());
            small.pop();
        }
    }
    vector<double> medianSlidingWindow(vector<int>& nums, int k) {
        //初始化k项
        for(int i=0;i<k;i++){
            //保证在奇数情况下small.size()==big.size()+1，偶数情况下small.size()==big.size()
            if(small.size()==big.size())keepBalance(true,nums[i]);
            else keepBalance(false,nums[i]);
        }
        vector<double> ans{getMedian(k)};
        for(int i = k; i < nums.size(); i++){
            int left = nums[i-k];
            mp[left]++;
            if(left<=small.top()){//如果要删除的元素在small堆中，则要把small堆大小加一
            keepBalance(true,nums[i]);
            }else{               //否则big堆大小加一
            keepBalance(false,nums[i]);
            }
            ans.push_back(getMedian(k));
        }
        return ans;
    }
};

```
## 串联所有单词字串
![[Pasted image 20240331205632.png]]


```C++
class Solution {
public:
    vector<int> findSubstring(string s, vector<string>& words) {
        vector<int> res;
        // 设 words中所有单词的长度为 d
        int n = s.size(), m = words.size(), d = words[0].size();
        int len = m*d;
        //um为标准频次模板
        unordered_map<string, int> um;
        for (string w : words) {
            um[w]++;
        }

        // init: 初始化长度为 d 的数组，代表从i(0<=i<=d)开始遍历长为len的字符串中各个word的频次哈希
        vector<unordered_map<string, int> > vu(d);
        for (int i = 0; i < d && i + len <= n; i++) {
            for (int j = i; j < i + len; j += d) {
                string w = s.substr(j, d);
                vu[i][w]++;
            }
            if (vu[i] == um) {
                res.emplace_back(i);
            }
        }

        // sliding window: 滑动窗口，每次移动 d 个位置
        for (int i = d; i + len <= n; i++) {
            int r = i % d;
            //wa左边删除的词，wb右边加入的词
            string wa = s.substr(i - d, d), wb = s.substr(i + len - d, d);
            if(--vu[r][wa] == 0) vu[r].erase(wa);
            vu[r][wb]++;
            if (vu[r] == um) {
                res.emplace_back(i);
            }
        }

        return res;
    }
};

```


# 其他
## 字典序排序
![[Pasted image 20240402152603.png]]
```C++
class Solution {
public:
    vector<int> lexicalOrder(int n) {
        vector<int> ret(n);
        int number = 1;
        for (int i = 0; i < n; i++) {
            ret[i] = number;
            if (number * 10 <= n) {
                number *= 10;
            } else {
		            //要进位或者 到n的最大值了，等同于
		            //while( cnt%10 == 9 || cnt == n )
                while (number % 10 == 9 || number + 1 > n) {
                    number /= 10;
                }
                number++;
            }
        }
        return ret;
    }
};

```

## 根据身高排序
![[Pasted image 20240403185120.png]]
思路，按照从高到低排序后，通过标记 $k_i$ 插入即可
### 链表实现 (list)
```C++
// 版本二
class Solution {
public:
    // 身高从大到小排（身高相同k小的站前面）
    static bool cmp(const vector<int>& a, const vector<int>& b) {
        if (a[0] == b[0]) return a[1] < b[1];
        return a[0] > b[0];
    }
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        sort (people.begin(), people.end(), cmp);
        list<vector<int>> que; // list底层是链表实现，插入效率比vector高的多
        for (int i = 0; i < people.size(); i++) {
            int position = people[i][1]; // 插入到下标为position的位置
            std::list<vector<int>>::iterator it = que.begin();
            while (position--) { // 寻找在插入位置
                it++;
            }
            que.insert(it, people[i]);
        }
        return vector<vector<int>>(que.begin(), que.end());
    }
};

```
## 0 和博弈
![[Pasted image 20240405160035.png]]
`dp[i][j]` 表示在轮到某位玩家时玩家相较于另一玩家的分数差，正为领先，负为落后
- 当 $i= j$ 时，只剩一个数字，当前玩家只能拿取这个数字，因此对于所有  i<nums.length, 都有 $dp[i][i]=nums[i]$ 。
- 当 $i<j$ 时，当前玩家可以选择 $nums[i]$ 或 $nums[j]$,然后轮到另一个玩家在
 数组剩下的部分选取数字。在两种方案中，当前玩家会选择最优的方案，使得自己的分数最大化。

 因此可以得到如下状态转移方程：
$dp[i][j]=$ $\max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1])$
可以认为：玩家 1 选择 $nums[i]$ 后，玩家 2 选择最佳差值为 $dp[i+1][j]$ 故玩家 1 领先玩家 2 $nums[i]-dp[i+1][j]$ 分
```C++
class Solution {
public:
    bool PredictTheWinner(vector<int>& nums) {
        int length = nums.size();
        auto dp = vector<vector<int>> (length, vector<int>(length));
        for (int i = 0; i < length; i++) {
            dp[i][i] = nums[i];
        }
        for (int i = length - 2; i >= 0; i--) {
            for (int j = i + 1; j < length; j++) {
                dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
            }
        }
        return dp[0][length - 1] >= 0;
    }
};

```

## 摆动排序 2
![[Pasted image 20240405164821.png]]
![[Pasted image 20240405164901.png]]
```C++
class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        vector<int> arr = nums;
        sort(arr.begin(),arr.end());
        int l = (nums.size()-1)/2, r = nums.size()-1;
        for(int i = 0;i< nums.size();i++) {
            if(i%2 == 0) {
                nums[i] = arr[l];
                l--;
            }
            else {
                nums[i] = arr[r];
                r--;
            }
        } 
    }
};

```


## 独热编码
![[Pasted image 20240520194507.png]]
### 找出最长超赞字符串
```C++
class Solution {
public:
    int longestAwesome(string s) {
        int n = s.size();
        unordered_map<int, int> prefix = {{0, -1}};
        int ans = 0;
        int sequence = 0;
        for (int j = 0; j < n; ++j) {
            int digit = s[j] - '0';
            sequence ^= (1 << digit);//反转第k位
            if (prefix.count(sequence)) {
                ans = max(ans, j - prefix[sequence]);
            } else {
                prefix[sequence] = j;
            }
            for (int k = 0; k < 10; ++k) {
                if (prefix.count(sequence ^ (1 << k))) {
                    ans = max(ans, j - prefix[sequence ^ (1 << k)]);
                }
            }
        }
        return ans;
    }
};

```

## 数组中重复元素相关
### 递增序列找出并删除重复元素
![[Pasted image 20240524162027.png]]
```C++
class Solution {
private:
    int my_removeDuplicate(vector<int>& nums, int k){
        int n = nums.size();
        if(n<=1 || n<=k) return n;
        int slow = 0;
        for(int i = 0; i<n; i++){
            if( slow < k ||  nums[slow-k] != nums[i]){
                nums[slow] = nums[i];
                slow++;
            }
        }
        return slow;
    }
public:
    int removeDuplicates(vector<int>& nums) {
        return my_removeDuplicate(nums,2);
    }
};
```
### 非递增序列
#### 找出数组中所有重复元素
![[Pasted image 20240524131856.png]]
不断交换数据，使得 $nums[i]$ 尽可能地被交换到位置 $nums[i]-1$ 上。
统计遍历一遍，找到所有 $nums[i] - 1 != i$ 的数据


```C++
class Solution {
public:
    vector<int> findDuplicates(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0; i < n; ++i) {
            while (nums[i] != nums[nums[i] - 1]) {
                swap(nums[i], nums[nums[i] - 1]);
            }
        }
        vector<int> ans;
        for (int i = 0; i < n; ++i) {
            if (nums[i] - 1 != i) {
                ans.push_back(nums[i]);
            }
        }
        return ans;
    }
};
```


双指针通解解法
一个指针 i 进行数组遍历，另外一个指针 j 指向有效数组的最后一个位置。
只有当 i 所指向的值和 j 不一致（不重复），才将 i 的值添加到 j 的下一位置。



# 周赛特辑
[[周赛特辑其