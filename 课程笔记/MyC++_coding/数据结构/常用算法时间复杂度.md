![时间复杂度](https://img-blog.csdnimg.cn/20200917170826106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM4MzI3MDc=,size_16,color_FFFFFF,t_70#pic_center)
##### O(log n) — 对数复杂度
典型的对数复杂度算法是**二分搜索算法**。这是一种用于在有序数组中查找特定值的算法，它不断迭代读取当前范围的中间值，判断目标值是小于还是大于中间值，排除不包含目标的那一半内容。
# 常用数据结构时间复杂度
### 1. 数组(Array)

- **访问/查找**: O(1)
- **插入/删除**: O(n) （需移动后续元素）
- **遍历**: O(n)

### 2. 向量(Vector) - 动态数组

- **访问/查找**: O(1)
- **尾部插入/删除**: Amortized O(1) 或 O(n)（如果引起重新分配）
- **中部插入/删除**: O(n)
- **遍历**: O(n)

### 3. 列表(List) - 双向链表

- **访问**: O(n)
- **插入/删除**: O(1) （给定迭代器位置）
- **遍历**: O(n)

### 4. 集合(Set)/映射(Map) - 红黑树实现

- **查找/插入/删除**: O(log N)
- **遍历**: O(n)

### 5. 无序集合(Unordered_Set)/无序映射(Unordered_Map) - 哈希表实现

- **查找/插入/删除**: 平均O(1), 最坏O(n)
- **遍历**: O(n)

### 6. 堆(Priority_Queue) - 二叉堆实现

- **插入/删除顶部元素**: O(log N)
- **查看顶部元素**: O(1)
- **遍历**: O(n)

### 7. 队列(Queue)/栈(Stack) - 基于deque或list

- **入队/出队/压栈/弹栈**: O(1)
- **遍历**: O(n)

### 8. 字符串(String)

- **访问**: O(1)
- **插入/删除**: O(n) （取决于位置，可能涉及字符移动）
- **查找**: O(n) （简单查找），KMP等高级算法可以达到O(m+n)或更好
- **遍历**: O(n)

请注意，上述时间复杂度是在理想情况下的估计，实际性能还受到具体实现、编译器优化、系统架构等因素的影响。此外，某些操作如容器的扩容（特别是对于`std::vector`）可能会引入更高的时间复杂度（如O(n)），但这是在操作次数相对较少的情况下发生的，且可以通过预留空间(`reserve`)来避免。

## 常见算法时间复杂度
1. **排序算法**：
    
    - `std::sort`：平均和最好的情况是O(N log N)，最坏的情况是$O(N^2)$，其中N是元素数量。通常使用快速排序或归并排序实现。
    - `std::stable_sort`：同样为$O(N log N)$，但保证排序稳定性，即相等元素的相对顺序不会改变。
2. **查找算法**：
    
    - `std::find`：在已排序和未排序的序列中寻找元素，时间复杂度都是O(N)。
    - `std::binary_search`：在已排序的序列中查找元素，时间复杂度为O(log N)。
3. **集合操作**：
    
    - `std::unique`：去除连续重复元素，返回新序列的结束位置，时间复杂度为O(N)。
    - `std::set_intersection`, `std::set_union`, `std::set_difference`, `std::set_symmetric_difference`：这些集合操作的时间复杂度都是O(min(m, n))，其中m和n分别是两个输入序列的大小。
4. **最大最小值**：
    
    - `std::min_element` 和 `std::max_element`：在序列中找到最小或最大元素，时间复杂度为O(N)。
    - `std::minmax_element`：同时找到最小和最大元素，时间复杂度也是O(N)。
5. **迭代器操作**：
    
    - `std::next_permutation` 和 `std::prev_permutation`：生成下一个或上一个排列，时间复杂度为O(N * log(N))。
    - `std::for_each`：对序列中的每个元素应用给定的函数对象，时间复杂度为O(N)，但C++11引入的范围基础循环通常更简洁高效。
6. **积累和统计**：
    
    - `std::accumulate`：累加元素，时间复杂度为O(N)。
    - `std::count` 和 `std::count_if`：计算序列中特定元素出现的次数，时间复杂度为O(N)。

# 总结
1. **常数时间复杂度 O(1)**:
    
    - 操作不依赖于输入数据的大小，例如访问数组的一个元素，执行基本算术运算，哈希表查找（假设没有冲突）。
2. **对数时间复杂度 O(log n)**:
    
    - 二分查找、平衡二叉树的操作（如插入、删除、查找）。
3. **线性时间复杂度 O(n)**:
    
    - 遍历数组或链表一次，线性查找。
    - 计算数组的和、最大值或最小值。
4. **线性对数时间复杂度 O(n log n)**:
    
    - 归并排序、快速排序（平均情况）、堆排序。
    - 广度优先搜索(BFS)在无环图中的运行时间。
5. **平方时间复杂度 O(n^2)**:
    
    - 冒泡排序、选择排序、插入排序。
    - 两层循环嵌套，例如矩阵乘法的朴素算法。
6. **立方时间复杂度 O(n^3)**:
    
    - 解决三变量线性方程组的直接方法，如高斯-约旦消元法。
    - 三层循环嵌套。
7. **更高次幂的时间复杂度 O(n^k)**:
    
    - 更复杂的多变量问题，如矩阵的多项式时间乘法。
8. **指数时间复杂度 O(2^n)**:
    
    - 分治策略中的递归问题，如子集和问题、旅行商问题（TSP）的朴素解决方案。
9. **阶乘时间复杂度 O(n!)**:
    
    - 排列组合计算，如全排列问题。

这些时间复杂度是基于最坏情况的分析，实际运行时间可能因具体输入数据而有所不同。在设计算法时，通常会尽量追求较低的时间复杂度以提高效率。