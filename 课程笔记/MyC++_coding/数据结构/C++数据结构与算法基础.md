# 链表
链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向 null（空指针的意思）。

链表的入口节点称为链表的头结点也就是head。

如图所示：
![[链表.png]]
## 链表类型
### 单链表
见上图
### 双链表
单链表中的指针域只能指向节点的下一个节点。
双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。
双链表 既可以向前查询也可以向后查询。
如图所示：
![[双链表.png]]
### 循环链表
循环链表，顾名思义，就是链表首尾相连。
循环链表可以用来解决约瑟夫环问题。
![[循环链表.png]]
## 链表的存储方式
了解完链表的类型，再来说一说链表在内存中的存储方式。
数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。
链表是通过指针域的指针链接在内存中各个节点。
所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。
如图所示：
![[Pasted image 20230630103859.png]]
这个链表起始节点为2，终止节点为7，各个节点分布在内存的不同地址空间上，通过指针串联在一起。
## 链表的定义
```C++
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```
有同学说了，我不定义构造函数行不行，答案是可以的，C++默认生成一个构造函数。
但是这个构造函数不会初始化任何成员变量，下面我来举两个例子：
通过自己定义构造函数初始化节点：
```C++
ListNode* head = new ListNode(5);
```
使用默认构造函数初始化节点：
```C++
ListNode* head = new ListNode();
head->val = 5;
```
所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值!
## 链表的操作
### 删除节点
删除D节点，如图所示：
![[节点删除.png]]
只要将C节点的next指针 指向E节点就可以了。
那有同学说了，D节点不是依然存留在内存里么？只不过是没有在这个链表里而已。
是这样的，所以在C++里最好是再手动释放这个D节点，释放这块内存。
其他语言例如 Java、Python，就有自己的内存回收机制，就不用自己手动释放了。
### 添加节点
如图所示：
![[添加节点.png]]
可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。
但是要注意，要是删除第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。
## 性能分析
再把链表的特性和数组的特性进行一个对比，如图所示：
![[对比.png]]
数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。
链表的长度可以是不固定的，并且可以动态增删，适合数据量不固定，频繁增删，较少查询的场景。







# 二叉树
## 二叉树种类
在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。
### 满二叉树
如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
![[满二叉树.png]]
这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树
### 完全二叉树 ：每一层节点从左到右中间不间断。
完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。
![[完全二叉树.png]]
之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。
### 二叉搜索树
二叉搜索树：前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。
- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树
![[二叉搜索树.png]]
### 平衡二叉搜索树（AVL 树）
平衡二叉搜索树：左子树和后子树高度差不大于 1.
![[平衡二叉搜索树.png]]
C++中 map、set、multimap，multiset 的底层实现都是平衡二叉搜索树，所以 map、set 的增删操作时间时间复杂度是 $logn$。
`unordered_map、unordered_set，unordered_map、unordered_set `底层实现是哈希表。

所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是 map、set 等等，否则自己写的代码，自己对其性能分析都分析不清楚！
### AVL 树旋转的选择
下图展示的四种失衡情况与上述案例逐个对应，分别需要采用右旋、左旋、先右后左、先左后右的旋转操作。[![AVL 树的四种旋转情况](https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png)](https://www.hello-algo.com/chapter_tree/avl_tree.assets/avltree_rotation_cases.png)
如下表所示，我们通过判断失衡节点的平衡因子以及较高一侧子节点的平衡因子的正负号，来确定失衡节点属于图中的哪种情况。
表 7-3   四种旋转情况的选择条件

|失衡节点的平衡因子|子节点的平衡因子|应采用的旋转方法|
|---|---|---|
|>1 （即左偏树）|≥0|右旋|
|>1 （即左偏树）|<0|先左旋后右旋|
|<−1 （即右偏树）|≤0|左旋|
|<−1 （即右偏树）|>0|先右旋后左旋|

为了便于使用，我们将旋转操作封装成一个函数。**有了这个函数，我们就能对各种失衡情况进行旋转，使失衡节点重新恢复平衡**。
```C++
/* 执行旋转操作，使该子树重新恢复平衡 */
TreeNode *rotate(TreeNode *node) {
    // 获取节点 node 的平衡因子
    int _balanceFactor = balanceFactor(node);
    // 左偏树
    if (_balanceFactor > 1) {
        if (balanceFactor(node->left) >= 0) {
            // 右旋
            return rightRotate(node);
        } else {
            // 先左旋后右旋
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }
    }
    // 右偏树
    if (_balanceFactor < -1) {
        if (balanceFactor(node->right) <= 0) {
            // 左旋
            return leftRotate(node);
        } else {
            // 先右旋后左旋
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }
    }
    // 平衡树，无须旋转，直接返回
    return node;
}

```

#### AVL 树典型应用
- 组织和存储大型数据，适用于高频查找、低频增删的场景。
- 用于构建数据库中的索引系统。
- 红黑树在许多应用中比 AVL 树更受欢迎。这是因为红黑树的平衡条件相对宽松，在红黑树中插入与删除节点所需的旋转操作相对较少，其节点增删操作的平均效率更高。

## 二叉树遍历方式
![[Pasted image 20230619155955.png]]

## 二叉树储存方式
**二叉树可以链式存储，也可以顺序存储**。
那么链式存储方式就用指针， 顺序存储的方式就是用数组。
顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。

### 链式存储
链式存储如图：
![[链式存储.png]]
### 顺序存储
![[顺序存储.png]]
## 二叉树的定义
```C++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```
## 二叉树的遍历方式
### 前序遍历之递归
这里帮助大家确定下来递归算法的三个要素。每次写递归，都按照这三要素来写，可以保证大家写出正确的递归算法！

1. **确定递归函数的参数和返回值**： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件**： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑**： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

#### 解法：递归遍历
步骤如下：
1. 确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数里需要传入 vector 来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是 void，代码如下：
```C++
void traversal(TreeNode* cur, vector<int>& vec)
```
2. 确定终止条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接 return，代码如下：
```C++
if (cur == NULL) return;
```
确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：
```C++
vec.push_back(cur->val);    // 中
traversal(cur->left, vec);  // 左
traversal(cur->right, vec); // 右
```
单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：


```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: A Tree
     * @return: Inorder in ArrayList which contains node values.
     */
    void travelsal(TreeNode* cur,vector<int> &res){
        if(cur == nullptr) return;
        if(cur->left) travelsal(cur->left,res);//左
        res.push_back(cur->val);//中
        if(cur->right) travelsal(cur->right,res);//右


    }

    vector<int> inorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> res;

        travelsal(root,res);
        return res;
    }
};

```

### 前序遍历之 stack
```C++
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */

class Solution {
public:
    /**
     * @param root: A Tree
     * @return: Preorder in ArrayList which contains node values.
     */
    vector<int> preorderTraversal(TreeNode *root) {
        // write your code here
        stack<TreeNode*> st;
        vector<int> res;
        if(root == nullptr) return res;
        st.push(root);
        while(!st.empty()){
            TreeNode * node=st.top();  //zhong1
            st.pop();
            res.push_back(node->val);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);

        }
        return res;
    }
};
```

### 中序遍历的后继 :
节点后继指的是：
如果该节点有右子节点, 那么后继是其右子节点的子树中最左端的节点
如果该节点没有右子节点, 那么后继是离它最近的祖先, 该节点在这个祖先的左子树内.

# 栈与队列
队列是先进先出，栈是先进后出的一种数据结构。
![[栈与队列示意图.png]]
栈和队列是 STL（C++标准库）里面的两个数据结构。栈提供 push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素。
**栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**

所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。那么问题来了，STL 中栈是用什么容器实现的？

从下图中可以看出，栈的内部结构，栈的底层实现可以是 vector，deque，list 都是可以的，主要就是数组和链表的底层实现。
![[栈结构.png]]
我们常用的 SGI STL，如果没有指定底层实现的话，默认是以 deque 为缺省情况下栈的底层结构。
deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。
SGI STL中 队列底层实现缺省情况下一样使用deque实现的。
我们也可以指定 vector 为栈的底层实现，初始化语句如下：
```C++
std::stack<int, std::vector<int> > third;  // 使用vector为底层容器的栈
```
也可以指定 list 为起底层实现，初始化 queue 的语句如下：
```C++
std::queue<int, std::list<int>> third; // 定义以list为底层容器的队列
```
所以 STL 队列也不被归类为容器，而被归类为 container adapter（ 容器适配器）。

# 常用算法
## 回溯算法
回溯法也可以叫做回溯搜索法，它是一种搜索的方式。回溯是递归的副产品，只要有递归就会有回溯。回溯法的性能如何呢，这里要和大家说清楚了，**虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法**。**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。
### 回溯算法能够解决问题
回溯法，一般可以解决如下几种问题：

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N 皇后，解数独等等

### 回溯算法模板
#### 回溯函数模板返回值以及参数

在回溯算法中，我的习惯是函数起名字为backtracking，这个起名大家随意。
回溯算法中函数返回值一般为void。
再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
但后面的回溯题目的讲解中，为了方便大家理解，我在一开始就帮大家把参数确定下来。
回溯函数伪代码如下：
```C
void backtracking(参数)
```
#### 回溯函数终止条件

既然是树形结构，那么我们在讲解[二叉树的递归 (opens new window)](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html)的时候，就知道遍历树形结构一定要有终止条件。所以回溯也有要终止条件。

什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。

所以回溯函数终止条件伪代码如下：

```C
if (终止条件) {
    存放结果;
    return;
}
```

#### 回溯搜索的遍历过程

在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
如图：

![回溯算法理论基础](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

注意图中，我特意举例集合大小和孩子的数量是相等的！
回溯函数遍历过程伪代码如下：

```C
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```
for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。backtracking这里自己调用自己，实现递归。
从图中看出**for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历**，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。
分析完过程，回溯算法模板框架如下：
```C
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```

## 贪心算法
局部最优推出全局最优
### 贪心一般解题步骤

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

这个四步其实过于理论化了，我们平时在做贪心类的题目 很难去按照这四步去思考，真是有点“鸡肋”。

做题的时候，只要想清楚 局部最优 是什么，如果推导出全局最优，其实就够了。

## 动态规划理论基础
### 什么是动态规划

动态规划，英文：Dynamic Programming，简称DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。
所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的，

在[关于贪心算法，你该了解这些！ (opens new window)](https://programmercarl.com/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html)中我举了一个背包问题的例子。

例如：有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

>动态规划中` dp[j]`是由 `dp[j-weight[i]]`推导出来的，然后取 `max(dp[j], dp[j - weight[i]] + value[i])`。

但如果是贪心呢，每次拿物品选一个最大的或者最小的就完事了，和上一个状态没有关系。

所以贪心解决不了动态规划的问题。

**其实大家也不用死扣动规和贪心的理论区别，后面做做题目自然就知道了**。

而且很多讲解动态规划的文章都会讲最优子结构啊和重叠子问题啊这些，这些东西都是教科书的上定义，晦涩难懂而且不实用。

大家知道动规是由前一个状态推导出来的，而贪心是局部直接选最优的，对于刷题来说就够用了。

上述提到的背包问题，后序会详细讲解。

### 动态规划的解题步骤

做动规题目的时候，很多同学会陷入一个误区，就是以为把状态转移公式背下来，照葫芦画瓢改改，就开始写代码，甚至把题目AC之后，都不太清楚`dp[i]`表示的是什么。

**这就是一种朦胧的状态，然后就把题给过了，遇到稍稍难一点的，可能直接就不会了，然后看题解，然后继续照葫芦画瓢陷入这种恶性循环中**。

状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。

**对于动态规划问题，我将拆解为如下五步曲，这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

一些同学可能想为什么要先确定递推公式，然后在考虑初始化呢？

**因为一些情况是递推公式决定了dp数组要如何初始化！**

后面的讲解中我都是围绕着这五点来进行讲解。

可能刷过动态规划题目的同学可能都知道递推公式的重要性，感觉确定了递推公式这道题目就解出来了。

其实 确定递推公式 仅仅是解题里的一步而已！

一些同学知道递推公式，但搞不清楚dp数组应该如何初始化，或者正确的遍历顺序，以至于记下来公式，但写的程序怎么改都通过不了。

后序的讲解的大家就会慢慢感受到这五步的重要性了。

### 动态规划应该如何 debug

相信动规的题目，很大部分同学都是这样做的。

看一下题解，感觉看懂了，然后照葫芦画瓢，如果能正好画对了，万事大吉，一旦要是没通过，就怎么改都通过不了，对 dp数组的初始化，递推公式，遍历顺序，处于一种黑盒的理解状态。

写动规题目，代码出问题很正常！

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。

这是一个很不好的习惯！

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。

这也是我为什么在动规五步曲里强调推导dp数组的重要性。

举个例子哈：在「代码随想录」刷题小分队微信群里，一些录友可能代码通过不了，会把代码抛到讨论群里问：我这里代码都已经和题解一模一样了，为什么通过不了呢？

发出这样的问题之前，其实可以自己先思考这三个问题：

- 这道题目我举例推导状态转移公式了么？
- 我打印dp数组的日志了么？
- 打印出来了dp数组和我想的一样么？

**如果这灵魂三问自己都做到了，基本上这道题目也就解决了**，或者更清晰的知道自己究竟是哪一点不明白，是状态转移不明白，还是实现代码不知道该怎么写，还是不理解遍历dp数组的顺序。

然后在问问题，目的性就很强了，群里的小伙伴也可以快速知道提问者的疑惑了。

**注意这里不是说不让大家问问题哈， 而是说问问题之前要有自己的思考，问题要问到点子上！**

**大家工作之后就会发现，特别是大厂，问问题是一个专业活，是的，问问题也要体现出专业！**

如果问同事很不专业的问题，同事们会懒的回答，领导也会认为你缺乏思考能力，这对职场发展是很不利的。

所以大家在刷题的时候，就锻炼自己养成专业提问的好习惯。

### 总结

这一篇是动态规划的整体概述，讲解了什么是动态规划，动态规划的解题步骤，以及如何debug。

动态规划是一个很大的领域，今天这一篇讲解的内容是整个动态规划系列中都会使用到的一些理论基础。

在后序讲解中针对某一具体问题，还会讲解其对应的理论基础，例如背包问题中的01背包，leetcode上的题目都是01背包的应用，而没有纯01背包的问题，那么就需要在把对应的理论知识讲解一下。

## 并查集
### 背景

首先要知道并查集可以解决什么问题呢？

并查集常用来解决连通性问题。

大白话就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。

并查集主要有两个功能：

- 将两个元素添加到一个集合中。
- 判断两个元素在不在同一个集合

接下来围绕并查集的这两个功能来展开讲解。

### 原理讲解

从代码层面，我们如何将两个元素添加到同一个集合中呢。

此时有录友会想到：可以把他放到同一个数组里或者set 或者 map 中，这样就表述两个元素在同一个集合。

那么问题来了，对这些元素分门别类，可不止一个集合，可能是很多集合，成百上千，那么要定义这么多个数组吗？

有录友想，那可以定义一个二维数组。

但如果我们要判断两个元素是否在同一个集合里的时候 我们又能怎么办？ 只能把而二维数组都遍历一遍。

而且每当想添加一个元素到某集合的时候，依然需要把把二维数组组都遍历一遍，才知道要放在哪个集合里。

这仅仅是一个粗略的思路，如果沿着这个思路去实现代码，非常复杂，因为管理集合还需要很多逻辑。

那么我们来换一个思路来看看。

我们将三个元素A，B，C （分别是数字）放在同一个集合，其实就是将三个元素连通在一起，如何连通呢。

只需要用一个一维数组来表示，即：father[A] = B，father[B] = C 这样就表述 A 与 B 与 C连通了（有向连通图）。

代码如下：

```C++
// 将v，u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```


可能有录友想，这样我可以知道 A 连通 B，因为 A 是索引下标，根据 father[A]的数值就知道 A 连通 B。那怎么知道 B 连通 A呢？

我们的目的是判断这三个元素是否在同一个集合里，知道 A 连通 B 就已经足够了。

这里要讲到寻根思路，只要 A ，B，C 在同一个根下就是同一个集合。

给出A元素，就可以通过 father[A] = B，father[B] = C，找到根为 C。

给出B元素，就可以通过 father[B] = C，找到根也为为 C，说明 A 和 B 是在同一个集合里。 大家会想第一段代码里find函数是如何实现的呢？其实就是通过数组下标找到数组元素，一层一层寻根过程，代码如下：

```C++
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u; // 如果根就是自己，直接返回
    else return find(father[u]); // 如果根不是自己，就根据数组下标一层一层向下找
}

```


如何表示 C 也在同一个元素里呢？ 我们需要 father[C] = C，即C的根也为C，这样就方便表示 A，B，C 都在同一个集合里了。

所以father数组初始化的时候要 father[i] = i，默认自己指向自己。

代码如下：

```C++
// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
```


最后我们如何判断两个元素是否在同一个集合里，如果通过 find函数 找到 两个元素属于同一个根的话，那么这两个元素就是同一个集合，代码如下：

```C++
// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}
```


### 路径压缩

在实现 find 函数的过程中，我们知道，通过递归的方式，不断获取father数组下标对应的数值，最终找到这个集合的根。

搜索过程像是一个多叉树中从叶子到根节点的过程，如图：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230602102619.png)

如果这棵多叉树高度很深的话，每次find函数 去寻找跟的过程就要递归很多次。

我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230602103040.png)

除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，

如果我们想达到这样的效果，就需要 **路径压缩**，将非根节点的所有节点直接指向根节点。 那么在代码层面如何实现呢？

**我们只需要在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果**。

因为 find 函数向上寻找根节点，father[u] 表述 u 的父节点，那么让 father[u] 直接获取 find函数 返回的根节点，这样就让节点 u 的父节点 变成根节点。

代码如下，注意看注释，路径压缩就一行代码：

```C++
// 并查集里寻根的过程
int find(int u) {
    if (u == father[u]) return u;
    else return father[u] = find(father[u]); // 路径压缩
}
```


以上代码在C++中，可以用三元表达式来精简一下，代码如下：

```C++
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]);
}
```

相信不少录友在学习并查集的时候，对上面这三行代码实现的 find函数 很熟悉，但理解上却不够深入，仅仅知道这行代码很好用，不知道这里藏着路径压缩的过程。

所以对于算法初学者来说，直接看精简代码学习是不太友好的，往往忽略了很多细节。

### 代码模板

那么此时并查集的模板就出来了， 整体模板C++代码如下：

```C++
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

通过模板，我们可以知道，并查集主要有三个功能。

1. 寻找根节点，函数：find(int u)，也就是判断这个节点的祖先节点是哪个
2. 将两个节点接入到同一个集合，函数：join(int u, int v)，将两个节点连在同一个根节点上
3. 判断两个节点是否在同一个集合，函数：isSame(int u, int v)，就是判断两个节点是不是同一个根节点

### 常见误区

这里估计有录友会想，模板中的 join 函数里的这段代码：

```C++
u = find(u); // 寻找u的根
v = find(v); // 寻找v的根
if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回

```

与 `isSam`e 函数的实现是不是重复了？ 如果抽象一下呢，代码如下：

```C++
// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    if (isSame) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```

这样写可以吗？ 好像看出去没问题，而且代码更精简了。

**其实这么写是有问题的**，在join函数中 我们需要寻找 u 和 v 的根，然后再进行连线在一起，而不是直接 用 u 和 v 连线在一起。

举一个例子：

```C++
join(1, 2);
join(3, 2);
```


此时构成的图是这样的：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230525111307.png)

此时问 1，3是否在同一个集合，我们调用 `join(1, 2); join(3, 2);` 很明显本意要表示 1，3是在同一个集合。

但我们来看一下代码逻辑，当我们调用 `isSame(1, 3)`的时候，find(1) 返回的是1，find(3)返回的是3。 `return 1 == 3` 返回的是false，代码告诉我们 1 和 3 不在同一个集合，这明显不符合我们的预期，所以问题出在哪里？

问题出在我们精简的代码上，即 join 函数 一定要先 通过find函数寻根再进行关联。

如果find函数是这么实现，再来看一下逻辑过程。

```C++
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根
    if (u == v) return ; // 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回
    father[v] = u;
}
```
分别将 这两对元素加入集合。

```C++
join(1, 2);
join(3, 2);
```


当执行`join(3, 2)`的时候，会先通过find函数寻找 3的根为3，2的根为1 （第一个`join(1, 2)`，将2的根设置为1），所以最后是将1 指向 3。

构成的图是这样的：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230525112101.png)

因为在join函数里，我们有find函数进行寻根的过程，这样就保证元素 1，2，3在这个有向图里是强连通的。

此时我们在调用 `isSame(1, 3)`的时候，find(1) 返回的是3，find(3) 返回的也是3，`return 3 == 3` 返回的是true，即告诉我们 元素 1 和 元素3 是 在同一个集合里的。

### 模拟过程

（**凸显途径合并的过程，每一个join都要画图**）

不少录友在接触并查集模板之后，用起来很娴熟，因为模板确实相对固定，但是对并查集内部数据组织方式以及如何判断是否是同一个集合的原理很模糊。

通过以上讲解之后，我在带大家一步一步去画一下，并查集内部数据连接方式。

1、`join(1, 8);`

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20231122112727.png)

2、`join(3, 8);`

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20231122113857.png)

有录友可能想，`join(3, 8)` 在图中为什么 将 元素1 连向元素 3 而不是将 元素 8 连向 元素 3 呢？

这一点 我在 「常见误区」标题下已经详细讲解了，因为在`join(int u, int v)`函数里 要分别对 u 和 v 寻根之后再进行关联。

3、`join(1, 7);`

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20231122114108.png)

4、`join(8, 5);`

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20231122114847.png)

这里8的根是3，那么 5 应该指向 8 的根 3，这里的原因，我们在上面「常见误区」已经讲过了。 但 为什么 图中 8 又直接指向了 3 了呢？

**因为路经压缩了**

即如下代码在寻找跟的过程中，会有路径压缩，减少 下次查询的路径长度。

```C++
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : father[u] = find(father[u]); // 路径压缩
}
```

5、`join(2, 9);`

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20231122115000.png)

6、`join(6, 9);`

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20231122115404.png)

这里为什么是 2 指向了 6，因为 9的根为 2，所以用2指向6。

大家看懂这个有向图后，相信应该知道如下函数的返回值了。

```C++
cout << isSame(8, 7) << endl;
cout << isSame(7, 2) << endl;
```


返回值分别如下，表示，8 和 7 是同一个集合，而 7 和 2 不是同一个集合。

```C++
true
false
```

### 拓展

在「路径压缩」讲解中，我们知道如何靠压缩路径来缩短查询根节点的时间。

其实还有另一种方法：按秩（rank）合并。

rank表示树的高度，即树中结点层次的最大值。

例如两个集合（多叉树）需要合并，如图所示：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230602172250.png)

树1 rank 为2，树2 rank 为 3。那么合并两个集合，是 树1 合入 树2，还是 树2 合入 树1呢？

我们来看两个不同方式合入的效果。

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20230602172933.png)

这里可以看出，树2 合入 树1 会导致整棵树的高度变的更高，而 树1 合入 树2 整棵树的高度 和 树2 保持一致。

所以在 join函数中如何合并两棵树呢？

一定是 rank 小的树合入 到 rank大 的树，这样可以保证最后合成的树rank 最小，降低在树上查询的路径长度。

按秩合并的代码如下：

```C++
int n = 1005; // n根据题目中节点数量而定，一般比节点数量大一点就好
vector<int> father = vector<int> (n, 0); // C++里的一种数组结构
vector<int> rank = vector<int> (n, 1); // 初始每棵树的高度都为1

// 并查集初始化
void init() {
    for (int i = 0; i < n; ++i) {
        father[i] = i;
        rank[i] = 1; // 也可以不写
    }
}
// 并查集里寻根的过程
int find(int u) {
    return u == father[u] ? u : find(father[u]);// 注意这里不做路径压缩
}

// 判断 u 和 v是否找到同一个根
bool isSame(int u, int v) {
    u = find(u);
    v = find(v);
    return u == v;
}

// 将v->u 这条边加入并查集
void join(int u, int v) {
    u = find(u); // 寻找u的根
    v = find(v); // 寻找v的根

    if (rank[u] <= rank[v]) father[u] = v; // rank小的树合入到rank大的树
    else father[v] = u;

    if (rank[u] == rank[v] && u != v) rank[v]++; // 如果两棵树高度相同，则v的高度+1因为，方面 if (rank[u] <= rank[v]) father[u] = v; 注意是 <=
}
```

可以注意到在上面的模板代码中，我是没有做路径压缩的，因为一旦做路径压缩，rank记录的高度就不准了，根据rank来判断如何合并就没有意义。

也可以在 路径压缩的时候，再去实时修生rank的数值，但这样在代码实现上麻烦了不少，关键是收益很小。

其实我们在优化并查集查询效率的时候，只用路径压缩的思路就够了，不仅代码实现精简，而且效率足够高。

按秩合并的思路并没有将树形结构尽可能的扁平化，所以在整理效率上是没有路径压缩高的。

说到这里可能有录友会想，那在路径压缩的代码中，只有查询的过程 即 find 函数的执行过程中会有路径压缩，如果一直没有使用find函数，是不是相当于这棵树就没有路径压缩，导致查询效率依然很低呢？

大家可以再去回顾使用路径压缩的 并查集模板，在isSame函数 和 join函数中，我们都调用了 find 函数来进行寻根操作。

也就是说，无论使用并查集模板里哪一个函数（除了init函数），都会有路径压缩的过程，第二次访问相同节点的时候，这个节点就是直连根节点的，即 第一次访问的时候它的路径就被压缩了。

**所以这里推荐大家直接使用路径压缩的并查集模板就好**，但按秩合并的优化思路我依然给大家讲清楚，有助于更深一步理解并查集的优化过程。

### 复杂度分析

这里对路径压缩版并查集来做分析。

空间复杂度： O(n) ，申请一个father数组。

关于时间复杂度，如果想精确表达出来需要繁琐的数学证明，就不在本篇讲解范围内了，大家感兴趣可以自己去深入去研究。

这里做一个简单的分析思路。

路径压缩后的并查集时间复杂度在O(logn)与O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于O(1)。

了解到这个程度对于求职面试来说就够了。

在第一次查询的时候，相当于是n叉树上从叶子节点到根节点的查询过程，时间复杂度是logn，但路径压缩后，后面的查询操作都是O(1)，而 join 函数 和 isSame函数 里涉及的查询操作也是一样的过程。

### 总结

本篇我们讲解了并查集的背景、原理、两种优化方式（路径压缩，按秩合并），代码模板，常见误区，以及模拟过程。

要知道并查集解决什么问题，在什么场景下我们要想到使用并查集。

接下来进一步优化并查集的执行效率，重点介绍了路径压缩的方式，另一种方法：按秩合并，我们在 「拓展」中讲解。

通过一步一步的原理讲解，最后给出并查集的模板，所有的并查集题目都在这个模板的基础上进行操作或者适当修改。

但只给出模板还是不够的，针对大家学习并查集的常见误区，详细讲解了模板代码的细节。

为了让录友们进一步了解并查集的运行过程，我们再通过具体用例模拟一遍代码过程并画出对应的内部数据连接图（有向图）。

这里也建议大家去模拟一遍才能对并查集理解的更到位。
# 前缀和与差分数组
前缀和用于快速计算数组中一段连续元素的和
差分数组用于方便地修改数组元素值而保持某些性质不变。
以下是这两者的主要用途及其在 C++中的示例说明：
1. **快速查询子数组和**：前缀和数组 `S` 存储了原数组 `A` 中从第一个元素到当前位置的所有元素之和。通过比较前缀和数组中两个索引对应的值，即可快速得到原数组对应区间内的所有元素之和，无需遍历整个区间。这对于解决许多涉及求子数组和的问题（如区间查询、滑动窗口求和等）非常有用，极大地提高了时间复杂度。
2. 可以考察区间值的变化量，用于平衡区间内的值。