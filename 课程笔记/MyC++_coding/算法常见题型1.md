# 1 算法使用
使用算法需要 `#include <algorithm>`
或者直接使用通用库引用方法：`#include <bits/stdc++.h>`
# 2 常用其他算法及方法

## 2.1 循环数组移动
![[Pasted image 20240222150520.png]]
#循环数组移动 使用三段 reverse 法
整体->局部
```c++
offset=offset % (s.size());

reverse(s.begin(),s.end());
reverse(s.begin(),s.begin()+offset);
reverse(s.begin()+offset,s.end());
```
## 数位运算
### 找规律+数位运算
![[Pasted image 20240511162629.png]]
打表后发现规律：应该找对应的镜像对称号码。例如： idx  = 8 `1000` 对应于 `0001` 1。
关键数位运算：
```C++
for(int i = 0; i<n;i++){
    if(idx&(1ll<<i)){
        res |= (1ll<<(n-1-i));
    }
}
```

```C++

#include <bits/stdc++.h>
using namespace std;

//打表用于判断。
// void dfs(long long i, long long j, vector<long long> &arr)
// {
//     if (j - i < 2)
//         return;
//     // cout<<i<<" "<<j<<endl;
//     vector<long long> tmp(arr.begin() + i, arr.begin() + j + 1);
//     long long mid = (i + j) / 2;
//     long long cnt = (j - i) / 2;
//     for (long long k = 0; k <= cnt; k++)
//     {
//         arr[i + k] = tmp[2 * k];
//         arr[mid + 1 + k] = tmp[2 * k + 1];
//     }

//     dfs(i, mid, arr);
//     dfs(mid + 1, j, arr);
// }
int main()
{
    long long n, m;
    while (cin >> n >> m)
    {
        // cout << pow(2, n) << endl;

        // vector<long long> arr(pow(2, n));
        // for (long long i = 0; i < arr.size(); i++)
        // {
        //     arr[i] = i;
        // }
        // dfs(0, arr.size() - 1, arr);
        // for(int i =0; i<arr.size(); i++){
        //     cout<<i<<" " <<arr[i]<<endl;
        // }cout<<endl;

        long long idx;
        while (m--)
        {
            cin >> idx;
            long long res = 0 ;
            for(int i = 0; i<n;i++){
                // cout<<(4&(1<<i))<<endl;
                if(idx&(1ll<<i)){
                    res |= (1ll<<(n-1-i));
                }
            }
            // reverse(res.begin(), res.end());

            cout << res << endl;
        }
    }
}
```


### 2.2.1 ip 破译

经典位运算
![[ip破译.png]]
```C++
#include <iostream>
using namespace std;
int main(){
    long long n, a1, a2, a3, a4;//n代表输入的整形数字；四个数分别代表输入的ip地址
    char ch;//代表输入的IP地址中的点
    while(cin >> a1 >> ch >> a2 >> ch >> a3 >> ch >> a4){
        cin >> n;
        long long res = 0;
        //采用左移运算符，把IP地址中的每一位依次向左移动24位（乘以2的24次方），16位，8位，0位。
        res += (a1 << 24)  + (a2 << 16) + (a3 << 8)  + a4;
        a1 = n >> 24;
        //255的二进制码是11111111，这样就可以只保留最后8位的数字，而把前面的都变为000000000
        a2 = (n >> 16) & 255;
        a3 = (n >> 8) & 255;
        a4 = n & 255;
        cout << res << endl << a1 << '.' << a2 << '.' << a3 << '.' << a4 << endl;
    }
    return 0;
}
```

## 数论相关
## 大数计算
使用 `string` 存储了相应大数字符串，现对其进行以下操作
### 大数相加
```C++
string bignumadd(string a, string b){
    int n = a.size(), m = b.size();
    if(n > m) return bignumadd(b, a);
    int sum = 0;
    for (int i = 0; i < m; i++)
    {
        int numa = i<n ? (a[n-1-i] - '0') : 0;
        int numb = b[m-1-i] - '0';
        sum += numa + numb;
        int bit = sum % 10;
        sum/=10;
        b[m-1-i] = bit + '0';
    }
    if(sum>0) b = "1"+b;
    return b;
}
```
### 大数相乘并取模
从高位到低位边取模边相乘，最后再乘积取模。
```C++
long long moda = 0， moda = 0, mod = 98989439;
for (int i = 0; i < n; i++)
{
    moda = (moda * 10 + (a[i] - '0')) % mod;
    modb = (modb * 10 + (b[i] - '0')) % mod;
}
long long res = moda*modb%mod;
```
#### 例题

![[Pasted image 20240511151002.png]]
```C++
#include <bits/stdc++.h>
using namespace std;

int main()
{
    int n;
    while (cin >> n)
    {
        string a, b;
        cin >> a >> b;
        for (int i = 0; i < n; i++)
        {
            if (a[i] > b[i]){
                swap(a[i],b[i]);
            }
        }
        // string result;
        int mod = 998244353;
        long long moda = 0, modb = 0;
        for (int i = 0; i < n; i++)
        {
            moda = (moda * 10 + (a[i] - '0')) % mod;
            modb = (modb * 10 + (b[i] - '0')) % mod;
        }

        long long result = (moda * modb) % mod;
        cout<<result<<endl;
    }
    return 0;
}
```
# 经典机考题
## 字符串相关
### KMP 算法
KMP 算法解决的是字符串匹配的问题，可以在 $O(m+n)$ 的时间复杂度下完成字符串匹配。
该算法的逻辑是：
1. 建立模式串的回退位置参考，也就是前缀表；
2. 遍历主串, 当遇到不匹配的情况依照前缀表进行回退；
3. 匹配成功后，即模式串的最后一个字符也匹配成功时 break。
#### 求 next 数组 (前缀表)
**前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。**
其中指针 j 指向的前缀字符串待匹配的最后一位，i 指向的是
```C++
void findnext(string s , vector<int> &next){
    int j = 0, n = s.size();
    for(int i = 1; i<n; i++){
        while( j>0 && s[i]!=s[j]){
            j = next[j-1];
        }
        if(s[i] == s[j]){
            next[i] = ++j;
        }
    }
}
```
#### 模式串与主串进行匹配逻辑
```C++
int strStr(string haystack, string needle) {
    int n = needle.size();
    vector<int> next(n);
    findnext(needle,next);
    int j = 0;
    for(int i = 0; i<haystack.size();i++){
        while(j>0 && haystack[i]!=needle[j]){
            j = next[j-1];
        }
        if(haystack[i] == needle[j]){
            j++;
            if(j == n) return (i-n+1);
        }
    }
    return -1;
}
```
### 最小覆盖子串
![[Pasted image 20240508141743.png]]
思路：用一个哈希存储模板串中字符频率，然后使用滑动窗口进行遍历求取最小窗口宽度。
```C++
class Solution {
private:
    unordered_map<char, int> tmplate; // 用于存t中字符频率
    bool check() {
        for (auto &it : tmplate) {
            if (it.second > 0) {
                return false;
            }
        }
        return true;
    }

public:
    string minWindow(string s, string t) {

        int n = s.size(), m = t.size();
        // unordered_set<int> st;
        for (auto &ch : t) {
            tmplate[ch]++;
        }
        int l = 0, r = 0;
        int minlen = INT_MAX, resl;
        while (r < n) {
            if(tmplate.count(s[r])) tmplate[s[r]]--;

            // cout<<s.substr(l,r-l+1)<<" "<<tmplate[s[r]]<<"
            // "<<totalchar<<endl;
            while (l <= r-m+1 && check()) {
                int tmplen = r - l + 1;
                if ( tmplen < minlen) {
                    minlen = tmplen;
                    resl = l;
                }
                if(tmplate.count(s[l])) tmplate[s[l]]++;
                l++;
                // cout<<"res: "<<s.substr(resl,minlen)<<endl;
                // cout<<s.substr(l,r-l+1)<<" : "<<s[l]<<" "<<tmplate[s[l]]<<"
                // "<<totalchar<<endl;
            }
            r++;
        }

        if (minlen == INT_MAX)
            return "";
        else
            return s.substr(resl, minlen);
    }
};
```
## 双指针法
### 1. 翻转链表
#### 题面 
![[翻转链表.png]]
#### 解法
交换方法：采用双指针，分别指向 prev 和 curr 两个节点
1. 初始：prev 指向 null，curr 指向 head；
2. 使用 temp=curr->next 保存临时地址
3. 将 curr->next 改为 prev，以此翻转指针指向；
4. Curr、prev 右移：prev=curr;   curr=temp。
以此，遍历完所有节点，完成链表翻转
```C++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp; // 保存cur的下一个节点
        ListNode* cur = head;
        ListNode* pre = NULL;
        while(cur) {
            temp = cur->next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
            cur->next = pre; // 翻转操作
            // 更新pre 和 cur指针
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};
```
- 时间复杂度: O(n)
- 空间复杂度: O(1)


### 移除元素
#### 题头
给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
```
示例 1：

输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
示例 2：

输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。

```
#### 解法-快慢指针法
```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex=0;
        for(int fastIndex = 0;fastIndex<nums.size();fastIndex++){
            if(nums[fastIndex] != val){
                nums[slowIndex++]=nums[fastIndex];

            }
        }
        return slowIndex;
    }
};
```
#### 思路
通过快慢指针右移，但遇到待删除元素时，快指针右移而慢指针不移动，同时遇到新元素时再让慢指针移动。
#### 方法二 ：相向指针法
```C++
/**
* 相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素
* 时间复杂度：O(n)
* 空间复杂度：O(1)
*/
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int leftIndex = 0;
        int rightIndex = nums.size() - 1;
        while (leftIndex <= rightIndex) {
            // 找左边等于val的元素
            while (leftIndex <= rightIndex && nums[leftIndex] != val){
                ++leftIndex;
            }
            // 找右边不等于val的元素
            while (leftIndex <= rightIndex && nums[rightIndex] == val) {
                -- rightIndex;
            }
            // 将右边不等于val的元素覆盖左边等于val的元素
            if (leftIndex < rightIndex) {
                nums[leftIndex++] = nums[rightIndex--];
            }
        }
        return leftIndex;   // leftIndex一定指向了最终数组末尾的下一个元素
    }
};
```
注：在 `while (leftIndex <= rightIndex && nums[leftIndex] != val)` 中不可直接交换两判断式的顺序，防止出现数组越界的问题。

### 反转字符串里的单词
#### 题目
题目类型：双指针+字符串，题号 151
![[反转字符串里的单词.png]]
![[反转字符串里的单词题目.png]]
#### 解法
空间复杂度 O (1)，时间复杂度 O (n)
```c++
class Solution {
public:
    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []
        for (int i = start, j = end; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }

    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html
        for (int i = 0; i < s.size(); ++i) { //
            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                    s[slow++] = s[i++];
                }
            }
        }
        s.resize(slow); //slow的大小即为去除多余空格后的大小。
    }

    string reverseWords(string s) {
        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
        reverse(s, 0, s.size() - 1);
        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。
        for (int i = 0; i <= s.size(); ++i) {
            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。
                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。
                start = i + 1; //更新下一个单词的开始下标start
            }
        }
        return s;
    }
};
```
### 赎金信
![[赎金信.png]]
#### 哈希解法
```C++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        //add
        if (ransomNote.size() > magazine.size()) {
            return false;
        }
        for (int i = 0; i < magazine.length(); i++) {
            // 通过record数据记录 magazine里各个字符出现次数
            record[magazine[i]-'a'] ++;
        }
        for (int j = 0; j < ransomNote.length(); j++) {
            // 遍历ransomNote，在record里对应的字符个数做--操作
            record[ransomNote[j]-'a']--;
            // 如果小于零说明ransomNote里出现的字符，magazine没有
            if(record[ransomNote[j]-'a'] < 0) {
                return false;
            }
        }
        return true;
    }
}
```

### 三数之和
![[Pasted image 20230902140304.png]]

#### 解法：双指针法
思路分为三步：
1. 排序数组
2. 第一层循环从头开始遍历
3. 第二层循环采用双指针头尾夹逼遍历
##### 需要注意观点
1. 需要考虑去重：当发现数值重复的话进行 continue
2. 如果无法实现，则在前期就应该跳出并返回程序
##### 解答程序

```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
// 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重a方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```
#### 总结
每层需要考虑减枝和删重
### 四数之和
#### 题目
![[四数之和题目.png]]
#### 解法
在三数之和的基础上，嵌套一层
```C++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++) {
            // 剪枝处理
            if (nums[k] > target && nums[k] >= 0) {
            	break; // 这里使用break，统一通过最后的return返回
            }
            // 对nums[k]去重
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            for (int i = k + 1; i < nums.size(); i++) {
                // 2级剪枝处理
                if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                    break;
                }

                // 对nums[i]去重
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    // nums[k] + nums[i] + nums[left] + nums[right] > target 会溢出
                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] > target) {
                        right--;
                    // nums[k] + nums[i] + nums[left] + nums[right] < target 会溢出
                    } else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  < target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 对nums[left]和nums[right]去重
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }

            }
        }
        return result;
    }
};
```


### 下一个排列
![[Pasted image 20240328183045.png]]
思路： 例如 2, 6, 3, 5, 4, 1 这个排列， 我们想要找到下一个刚好比他大的排列，于是可以从后往前看 我们先看后两位 4, 1 能否组成*更大的排列*，答案是不可以，同理 5, 4, 1也不可以 直到3, 5, 4, 1这个排列，因为 3 < 5， 我们可以通过重新排列这一段数字，来得到下一个排列 因为我们需要使得新的排列尽量小，所以我们从后往前找第一个比3更大的数字，发现是4 然后，我们调换3和4的位置，得到4, 5, 3, 1这个数列 因为我们需要使得新生成的数列尽量小，于是我们可以对5, 3, 1进行排序，可以发现在这个算法中，*我们得到的末尾数字一定是倒序排列的，于是我们只需要把它反转即可* 最终，我们得到了4, 1, 3, 5这个数列 完整的数列则是2, 6, 4, 1, 3, 5
```C++
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size()-2;
        while(i>=0 && nums[i+1]<=nums[i]){
            i--;
        }
        cout<<i<<endl;
        if(i>=0){
            for(int j = nums.size()-1; j>i; j--){
                if(nums[j]>nums[i]){
                    swap(nums[i],nums[j]);
                    break;
                }
            }
        }
        reverse(nums.begin()+i+1,nums.end());
    }
};
```

### 找到 K 个最接近的元素
![[Pasted image 20240331111006.png]]
#### 解法一：自定义排序
```C++
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        sort(arr.begin(), arr.end(), [x](int a, int b) -> bool {
            return abs(a - x) < abs(b - x) || abs(a - x) == abs(b - x) && a < b;
        });
        sort(arr.begin(), arr.begin() + k);
        return vector<int>(arr.begin(), arr.begin() + k);
    }
};

```
#### 解法二：二分法+双指针
```C++
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        vector<int> res;
        bool Iskodd = false;
        if(k%2 == 1) Iskodd = true;
        int idx = upper_bound(arr.begin(),arr.end(),x) - arr.begin();
        int left = idx-1,right = idx;
        // if(arr[idx] == x) res.push.back(arr[idx]);
        // cout<<idx<<endl;
        while(k--){
            if(left>=0 && right<arr.size()){
                if( ( x -arr[left]) <= (arr[right] - x) ){
                    res.push_back(arr[left]);
                    left--;
                }
                else{
                    res.push_back(arr[right]);
                    right++;
                }
            }
            else if(left < 0 && right<arr.size()){
                res.push_back(arr[right]);
                right++;
            }
            else if( left>=0 && right >= arr.size() ){
                res.push_back(arr[left]);
                left--;
            }
        }
        sort(res.begin(),res.end());
        return res;
    }
};
```

![[Pasted image 20240525162944.png]]
```C++
class Solution {
public:
    vector<int> findIndices(vector<int>& nums, int indexDifference, int valueDifference) {
        int n = nums.size();
        if(indexDifference >=n) return {-1,-1};
        /*O(n^2)方法 */
        // for(int i = 0; i<n-indexDifference; i++){
        //     for(int j = i +indexDifference; j<n; j++){
        //         if( abs(nums[i] - nums[j]) >= valueDifference){
        //             return {i,j};
        //         }
        //     }
        // }

        /* O(n) */
        int minIndex = 0, maxIndex = 0;
        for (int j = indexDifference; j < nums.size(); j++) {
            int i = j - indexDifference;
            if (nums[i] < nums[minIndex]) {
                minIndex = i;
            }
            if (nums[j] - nums[minIndex] >= valueDifference) {
                return {minIndex, j};
            }
            if (nums[i] > nums[maxIndex]) {
                maxIndex = i;
            }
            if (nums[maxIndex] - nums[j] >= valueDifference) {
                return {maxIndex, j};
            }
        }


        return {-1,-1};
    }
};
```
## 杂项题（数组等）
### 返回数组平方和排序
```C++
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```

### 长度最小的子数组
#### 题目
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：
输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
#### 我的解法
```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int leftIndex=0;
        int WindowSum=0;
        int minilen=nums.size();
        int findFlag=0;
        for(int rightindex=0;rightindex<nums.size();rightindex++){
            WindowSum +=nums[rightindex];
            while((WindowSum-nums[leftIndex]) >= target){
                
                WindowSum-=nums[leftIndex];
                leftIndex++;
            }
            //cout<<"left: "<<leftIndex<<" righr: "<<rightindex<<" "<<WindowSum<<endl;
            int templen=rightindex-leftIndex+1;

            if( (WindowSum >=target) && (templen<=minilen) ){
                //cout<<"confirm:"<<WindowSum<<" "<<templen<<endl;
                minilen = templen;
                findFlag = 1;
            }
            
        }
        if(findFlag)
            return minilen;
        else
            return 0;


    }
};
```

#### 标准解法
```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

### 螺旋数组 1
给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。
**示例 1**：
![[Pasted image 20230629110256.png]]
输入：n = 3
输出：`[[1,2,3],[8,9,4],[7,6,5]]`

**示例 2：**
输入：n = 1
输出：`[[1]]`
#### 解法
```C++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n,vector<int>(n,0));
        int loop = n/2;
        int mid = n/2+1;
        int xstart=0,ystart=0;
        int offset = 1;
        int cnt=1;

        while(loop--){
            int i=xstart;
            int j=ystart;
            for(j = ystart;j<(n-offset);j++){
                res[xstart][j]=cnt++;
            }
            for(i = xstart;i<(n-offset);i++){
                res[i][n-offset]=cnt++;
            }
            for(j = n-offset;j>ystart;j--){
                res[n-offset][j] = cnt++;
            }
            for(i =n-offset;i>xstart;i--){
                res[i][ystart]=cnt++;
            }


            offset++;
            xstart++;
            ystart++;
        }
        if(n%2)
            res[n/2][n/2] = n*n;
            //cout<<"hi"<<endl;

        return res;

    }
};
```
#### 关键：
确定循环次数和每一层遍历的区间都为左闭右开区间即可
### 题目 2：遍历数组

### 解法：
```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int m = matrix.size()-1;//行数，下边界
        int n = matrix[0].size()-1;//列数，右边界
        vector<int> res;
        int u=0,v=0;//上，左边界
        
        while(true){
            for(int i=v;i<=n;i++) res.push_back(matrix[u][i]);
            if(++u>m) break;
            for(int i=u;i<=m;i++) res.push_back(matrix[i][n]);
            if(--n<v) break;
            for(int i=n;i>=v;i--) res.push_back(matrix[m][i]);
            if(--m<u) break;
            for(int i=m;i>=u;i--) res.push_back(matrix[i][v]);
            if(++v>n) break;
        }
        return res;
    }
};
```
### 关键：
在每次改变遍历行列时及时改变边界，这样下次遍历便不会反复遍历到

## 链表题
### 设计链表（重要）
#### 题目要求
你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。

实现 MyLinkedList 类：

- MyLinkedList() 初始化 MyLinkedList 对象。
- int get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。
- void addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- void addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。
- void addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。
- void deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。
#### 解决方案
##### 单向链表
```C++
class MyLinkedList {
public:
    struct LinkedNode{
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    MyLinkedList() {
        _dummyhead = new LinkedNode(0);
        _size=0;

    }
    
    int get(int index) {
        if( index > (_size-1) || index < 0 ) {
            cout<<_size<<endl;
            return -1;
        }
        LinkedNode* cur = _dummyhead->next;
        while(index--){
            cur = cur->next;
        }

        return cur->val;
    }
    
    void addAtHead(int val) {
        LinkedNode* tempNode = new LinkedNode(val);
        tempNode->next = _dummyhead->next;
        _dummyhead->next=tempNode;
        _size++;
    }
    
    void addAtTail(int val) {
        LinkedNode* cur = _dummyhead;
        LinkedNode* addNode = new LinkedNode(val);
        while( cur->next != nullptr){
            cur=cur->next;
        }
        
        cur->next = addNode;
        _size++;
    }
    //关键
    void addAtIndex(int index, int val) {
        if(index>(_size) ){
            return;
        }
        if(index <0) index = 0;
        LinkedNode* cur = _dummyhead;
        while(index--){
            cur=cur->next;
        }
        LinkedNode* addNode =new LinkedNode(val);
        addNode->next = cur->next;
        cur->next = addNode;
        
        _size++;

    }
    
    void deleteAtIndex(int index) {
       if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyhead;
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = tmp->next;
        delete tmp;
/*
delete命令指示释放了tmp指针原本所指的那部分内存，
被delete后的指针tmp的值（地址）并非就是NULL，而是随机值。也就是被delete后，
如果不再加上一句tmp=nullptr,tmp会成为乱指的野指针
如果之后的程序不小心使用了tmp，会指向难以预想的内存空间
*/
        tmp=nullptr;
        _size--;
    }

    private:
    int _size;
    LinkedNode* _dummyhead;
};

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList* obj = new MyLinkedList();
 * int param_1 = obj->get(index);
 * obj->addAtHead(val);
 * obj->addAtTail(val);
 * obj->addAtIndex(index,val);
 * obj->deleteAtIndex(index);
 */
```

### 回文链表
![[Pasted image 20240304155416.png]]

```C++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(head==nullptr || head->next==nullptr){
            return true;
        }
        stack<int> st;
        ListNode* cur = head;
        while (cur!=nullptr)
        {
            st.push(cur->val);
            cur = cur->next;
        }
        cur = head;
        int num = st.size();
        for(int i = 0;i<(num/2);i++){
            // cout<<cur->val<<" "<<st.top()<<endl;
            if(st.top()!=cur->val){
                return false;
            }
            st.pop();
            cur = cur->next;
        }
        
        return true;
        
    }
};
```

### 删除链表

#### 解法 1
直接使用原来的链表来进行移除节点操作
```C++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 删除头结点
        while (head != NULL && head->val == val) { // 注意这里不是if
            ListNode* tmp = head;
            head = head->next;
            delete tmp;
        }

        // 删除非头结点
        ListNode* cur = head;
        while (cur != NULL && cur->next!= NULL) {
            if (cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        return head;
    }
};
```

#### 解法 2
设置一个虚拟头结点在进行移除节点操作：
```C++
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur = dummyHead;
        while (cur->next != NULL) {
            if(cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};```

- 时间复杂度: O(n)
- 空间复杂度: O(1)
 ### 两两交换链表中的节点
给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。
![[Pasted image 20230703151746.png]]
```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```
 #### 解法一
 接下来就是交换相邻两个元素了，此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序
初始时，cur 指向虚拟头结点，然后进行如下三步：
![[Pasted image 20230703155518.png]]

```C++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur = dummyHead;
        while(cur->next != nullptr && cur->next->next != nullptr) {
            ListNode* tmp = cur->next; // 记录临时节点
            ListNode* tmp1 = cur->next->next->next; // 记录临时节点

            cur->next = cur->next->next;    // 步骤一
            cur->next->next = tmp;          // 步骤二
            cur->next->next->next = tmp1;   // 步骤三

            cur = cur->next->next; // cur移动两位，准备下一轮交换
        }
        return dummyHead->next;
    }
};
```
时间复杂度：O(n)
空间复杂度：O(1)
###  删除链表的倒数第 N 个节点
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
进阶：你能尝试使用一趟扫描实现吗？
示例 1：
![[删除链表倒数节点.png]]
```
输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2：

输入：head = [1], n = 1 输出：[] 示例 3：

输入：head = [1,2], n = 1 输出：[1]
```

#### 解法一：扫描两遍
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* cur = head;
        int totalNode = 0;
        while(cur){
            totalNode++;
            cur=cur->next;
        }
        if(totalNode == 1) return nullptr;
        int cnt=0;
        // ListNode* dummyNode = new ListNode(-1);
        // dummyNode->next =head;
        if( !(totalNode - n) ) {
            
            return head->next;
        }
        cur = head;
        while( cnt != ( totalNode - n -1) ){
            cur = cur->next;
            cnt++;
        }

        cur->next=cur->next->next;
        return head;

    }
};
```

#### 方法二：扫描一遍
##### 思路：使用快慢指针
双指针的经典应用，如果要删除倒数第 n 个节点，让 fast 移动 n 步，然后让 fast 和 slow 同时移动，直到 fast 指向链表末尾。删掉 slow 所指向的节点就可以了
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyNode = new ListNode(-1);
        dummyNode->next = head;
        ListNode* slowNode = dummyNode;
        ListNode* fastNode = dummyNode->next;
        for(int i=0;i<n;i++){
            fastNode = fastNode->next;
        }
        while(fastNode){

            fastNode = fastNode->next;
            slowNode = slowNode->next;
        }
        slowNode->next=slowNode->next->next;
        return dummyNode->next;
    }
};
```
### 合并有序链表
![[Pasted image 20240305103117.png]]
解题思路：交替判断那边的节点值小，边吧节点接在合并链表后侧。
```C++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {

        ListNode* newList = new ListNode(-1);
        ListNode* curNode = newList;
        while(list1 != nullptr && list2 != nullptr){
            if( list1->val <= list2->val  ){
                curNode->next = list1;
                list1 = list1 -> next; 
            }
            else{
                curNode->next = list2;
                list2 = list2 -> next; 
            }
            curNode = curNode->next;
         }
        curNode->next = list1 == nullptr ? list2:list1;
        return newList->next;
    }
};
```
### 链表相交
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
图示两个链表在节点 c1 开始相交：
![[链表相交.png]]
#### 解法
找到两链表长度相差的个数，**末端对齐**后进行遍历便可寻找出指针相同的两节点。
```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        while (curA != NULL) { // 求链表A的长度
            lenA++;
            curA = curA->next;
        }
        while (curB != NULL) { // 求链表B的长度
            lenB++;
            curB = curB->next;
        }
        curA = headA;
        curB = headB;
        // 让curA为最长链表的头，lenA为其长度
        if (lenB > lenA) {
            swap (lenA, lenB);
            swap (curA, curB);
        }
        // 求长度差
        int gap = lenA - lenB;
        // 让curA和curB在同一起点上（末尾位置对齐）
        while (gap--) {
            curA = curA->next;
        }
        // 遍历curA 和 curB，遇到相同则直接返回
        while (curA != NULL) {
            if (curA == curB) {
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }
        return NULL;
    }
};
```

#### 更精彩做法
```C++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode *A = headA, *B = headB;
        while (A != B) {
            A = A != nullptr ? A->next : headB;
            B = B != nullptr ? B->next : headA;
        }
        return A;
    }
};

```
### 环形链表 1
![[Pasted image 20240305090736.png]]
```C++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* FastIndex = head;
        ListNode* SlowIndex = head;
        while(FastIndex!= nullptr && FastIndex->next!= nullptr){
            FastIndex = FastIndex->next->next;
            SlowIndex = SlowIndex->next;
            if(FastIndex == SlowIndex) return true;
        }
        return false;
    }
};
```
### 环形链表 2
![[Pasted image 20240305090610.png]]
#### 方法 1（低级做法）：
创建一个集合用于保存已遍历点，在便利的过程中不断判断当前所在点是否在所遍历点集中，若在；则返回该点作为环形链表的入口。代码如下：
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* cur = head;
        vector<ListNode*> Nodeset;
        //int cnt = 0;

        while(cur){
            int findflag = 0;
            for(auto s:Nodeset){
                if(s == cur){
                    findflag =1;
                    break;
                }
            }

            if(findflag) return cur;
            else Nodeset.push_back(cur);
            //cnt++;

            cur = cur->next;
        }

        return NULL;
    }
};
```
时间复杂度 O (n^2)
空间复杂度 O (n)

#### 方法 2（快慢指针法）
如果有环，如何找到这个环的入口
此时已经可以判断链表是否有环了，那么接下来要找这个环的入口了。
假设从头结点到环形入口节点的节点数为 x。环形入口节点到 fast 指针与 slow 指针相遇节点节点数为 y。从相遇节点再到环形入口节点节点数为 z。如图所示：
![[快慢指针.png|快慢指针]]
那么相遇时：slow 指针走过的节点数为: x + y， fast 指针走过的节点数：$x + y + n (y + z)$，n 为 fast 指针在环内走了 n 圈才遇到 slow 指针，（y+z）为一圈内节点的个数 A。
因为fast指针是一步走两个节点，slow指针一步走一个节点， 所以 fast指针走过的节点数 = slow指针走过的节点数 * 2：

$(x + y) * 2 = x + y + n (y + z)$

两边消掉一个（x+y）: $x + y = n (y + z)$

因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。所以要求x ，将x单独放在左面：$x = n (y + z) - y$ ,

再从 n(y+z)中提出一个 （y+z）来，整理公式之后为如下公式：
$$x = (n - 1) (y + z) + z$$
注意这里n一定是大于等于1的，因为 fast指针至少要多走一圈才能相遇slow指针。这个公式说明什么呢？
- 先拿 n 为1的情况来举例，意味着 fast 指针在环形里转了一圈之后，就遇到了 slow 指针了。
- 当 n 为1的时候，公式就化解为 $x = z$，这就意味着，从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是环形入口的节点。
- 那么 n 如果大于1是什么情况呢，就是 fast 指针在环形转 n 圈之后才遇到 slow 指针。其实这种情况和n为1的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。

结果便是：此时只要将慢指针指向头，快慢同时遍历，最终定能在环入口相遇。
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            // 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇
            if (slow == fast) {
                ListNode* index1 = fast;
                ListNode* index2 = head;
                while (index1 != index2) {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index2; // 返回环的入口
            }
        }
        return NULL;
    }
};
```
时间复杂度: O(n)，快慢指针相遇前，指针走的次数小于链表长度，快慢指针相遇后，两个 index 指针走的次数也小于链表长度，总体为走的次数小于 2n。
空间复杂度: O(1)。
### k 翻转链表
![[Pasted image 20240310205556.png]]

```C++
class Solution {
public:
    // 翻转一个子链表，并且返回新的头与尾
    pair<ListNode*, ListNode*> myReverse(ListNode* head, ListNode* tail) {
        ListNode* prev = tail->next;
        ListNode* p = head;
        while (prev != tail) {
            ListNode* nex = p->next;
            p->next = prev;
            prev = p;
            p = nex;
        }
        return {tail, head};
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* hair = new ListNode(0);
        hair->next = head;
        ListNode* pre = hair;

        while (head) {
            ListNode* tail = pre;
            // 查看剩余部分长度是否大于等于 k
            for (int i = 0; i < k; ++i) {
                tail = tail->next;
                if (!tail) {
                    return hair->next;
                }
            }
            ListNode* nex = tail->next;
            // 这里是 C++17 的写法，也可以写成
            // pair<ListNode*, ListNode*> result = myReverse(head, tail);
            // head = result.first;
            // tail = result.second;
            tie(head, tail) = myReverse(head, tail);
            // 把子链表重新接回原链表
            pre->next = head;
            tail->next = nex;
            pre = tail;
            head = tail->next;
        }

        return hair->next;
    }
};

```
### 随机链表深拷贝
具体见[[#随机链表的复制]]
### 合并 K 个升序链表
![[Pasted image 20240312105311.png]]
#### 改进的堆排序

```C++
class Solution {
public:
    // 自定义比较器
    struct Comparator {  
       bool operator()(ListNode *a,ListNode *b) {
          return a->val > b->val;
       }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        // 创建一个小根堆，并定义好排序函数
        priority_queue<ListNode*, vector<ListNode*>, Comparator> queue;
        std::for_each(lists.begin(), lists.end(), [&queue](ListNode* node){
            // 这里跟上一版不一样，不再是一股脑全部放到堆中
            // 而是只把k个链表的第一个节点放入到堆中
            if (node) queue.push(node);
        });
        ListNode dummy(-1);
        ListNode* p = &dummy;
        // 之后不断从堆中取出节点，如果这个节点还有下一个节点，
        // 而是只把k个链表的第一个节点放入到堆中
        while (!queue.empty()) {
            ListNode *tmp = queue.top();
            queue.pop();
            p->next = tmp;
            p = p->next;
            if (tmp->next) {
                queue.push(tmp->next);
            }
        }
        return dummy.next;   
    }
};

```

### 分割链表
![[Pasted image 20240320001700.png]]
#### 思路
建立两个链表，分别存储大于等于 x 的节点和小于 x 的节点
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        ListNode* largeList = new ListNode(0);
        ListNode* largeNode = largeList;
        ListNode* smallList = new ListNode(0);
        ListNode* smallNode = smallList;

        while( head != nullptr){
            if( head->val >= x ){
                largeList->next = head;
                largeList = largeList -> next;
            }
            else{
                smallList->next = head;
                smallList = smallList -> next;
            }
            head = head->next;
        }

        largeList->next = nullptr;
        smallList -> next = largeNode->next;
        return smallNode->next;
    }
};
```
### 旋转链表
![[Pasted image 20240322213111.png]]
思路：统计链表 size，使用快慢指针法找到新头尾节点即可。
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if (head == nullptr || head->next == nullptr) return head;
        if (k == 0) return head;
        int NodeTotalNum = 0;
        // ListNode * dummyhead = new ListNode(-1);
        // dummyhead->next = head;
        ListNode* tailNode = head;
        while(tailNode->next !=nullptr ){
            tailNode = tailNode->next;
            NodeTotalNum++;
        }//求出总节点个数
        NodeTotalNum++;
        k = k%NodeTotalNum;
        if (k == 0) return head;
        // cout<<NodeTotalNum<<", "<<k<<endl;
        ListNode* SlowNode = head;
        for(int i = 0; i<(NodeTotalNum - k-1); i++){
            SlowNode = SlowNode->next;
        }
        // cout<<SlowNode->val<<endl;
        ListNode* Newhead = SlowNode->next;
        // cout<<SlowNode->val<<endl;
        SlowNode->next = nullptr;
        tailNode->next = head;
        return Newhead;
    }
};
```

### 删除排序链表中的重复元素 II
![[Pasted image 20240329203041.png]]
思路：保存上一节点 pre, 判断是否存在节点相同，相同则用上一节点
```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* dummyhead = new ListNode(-1);
        dummyhead -> next = head;
        ListNode* pre = dummyhead;
        ListNode* cur = head;
        bool deleteFlag = false;
        while(cur!=nullptr){
            while( cur->next != nullptr && cur->val == cur->next->val){
                cur->next = cur->next->next;
                deleteFlag = true;
            }
            if(deleteFlag){
                cur = cur->next;
                pre->next = cur;
                deleteFlag = false;
            }else{
                pre = cur;
                cur = cur->next;
            }
            
        }
        return dummyhead->next;
    }
};
```


## 哈希表相关
### 哈希表定义

### 四数之和 1-set 用法

### 四数之和 2-map 用法
给你四个整数数组 ` nums1、nums2、nums3 和 nums4` ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：
```c
0 <= i, j, k, l < n
nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0
```

解法如下：分别统计前两数组和后两数组组合值出现的次数，累计后进行二次组合操作计算次数。
```c++
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
// 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
        for (int a : A) {
            for (int b : B) {
                umap[a + b]++;
            }
        }
        int count = 0; // 统计a+b+c+d = 0 出现的次数
// 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                if (umap.find(0 - (c + d)) != umap.end()) {
                    count += umap[0 - (c + d)];
                }
            }
        }
        return count;
    }
};
```

### 同积元组
![[Pasted image 20231020103528.png]]
#### 哈希解题思路
由于已经说明各个整数之间各不相同，故可以两层遍历，统计各种两数组合之和，的次数，然后通过
根据排列组合可以知道，如果存在 $cnt (a×b)$ 个乘积相同的数对，则此时可以有 $C_{\textit{cnt}(a \times b)}^2$ ​种不同的数对组合，即此时可以构成的同积元组的数目为: 
$$\dfrac{\textit{cnt}(a \times b) \times (\textit{cnt}(a \times b) -1)}{2} \times 8 = {\textit{cnt}(a \times b) \times (\textit{cnt}(a \times b) -1)} \times 4$$ 
例如，对于组合积为 4 共有 3 种排列，则能组合成 $3*8=24$ 种

```C++
class Solution {
public:
    int tupleSameProduct(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, int> mp;
        for(int i = 0; i < n; i++) {
            for(int j = i + 1; j < n; j++) {
                mp[nums[i] * nums[j]]++;
            }
        }
        int ret = 0;
        // 遍历哈希表
        for(auto c : mp) {
            ret += c.second * (c.second - 1) / 2;
        }
        return ret * 8;
    }
};

```
## 栈与队列相关
### 1.  用栈实现队列
#### 题目
![[用栈实现队列.png]]
#### 解决方案
通过两个栈（入栈和出栈来存储数据）。
入栈用于存取数据（push 必须使用栈进入），出栈用于将数据给翻转并使得队列的 pop 成为可能

```C++
class MyQueue {
public:
    stack<int> stackIn;
    stack<int> stackOut;

    MyQueue() {

    }
    
    void push(int x) {
        stackIn.push(x);
    }
    
    int pop() {
        if(stackOut.empty()){
            while(!stackIn.empty()){
                stackOut.push(stackIn.top());
                stackIn.pop();
            }
        }
        int tmp =stackOut.top();
        stackOut.pop();
        return tmp;
    }
    
    int peek() {
        int res = this->pop();
        stackOut.push(res);
        return res;
    }
    
    bool empty() {
        return stackIn.empty() && stackOut.empty();
    }
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```
### 2. 用队列实现栈

#### 解决方案
考虑到 queue 的特点，同样是拷贝翻转 queue 后进行 pop。
代码实现如下
```C++
class MyStack {
public:
    queue<int> queueSt1;
    queue<int> queueSt2;

    MyStack() {

    }
    
    void push(int x) {
        queueSt1.push(x);
    }
    
    int pop() {
        int qsize = queueSt1.size();
        qsize--;
        while(qsize--){
            queueSt2.push(queueSt1.front());
            queueSt1.pop();
        }
        int tmp = queueSt1.front();
        queueSt1.pop();
        queueSt1 = queueSt2;
        while(!queueSt2.empty()){
            queueSt2.pop();
        }
        return tmp;
    }
    
    int top() {
        return queueSt1.back();
    }
    
    bool empty() {
        return queueSt1.empty();
    }
};

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack* obj = new MyStack();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->top();
 * bool param_4 = obj->empty();
 */
```

### 3.  识别括号
#### 题头
![[Pasted image 20230907145632.png]]
#### 解决方法
使用栈来保存括号左半个对应的右半个括号，然后当遍历到右半个括号时就近 pop。
```C++
class Solution {
public:
    bool isValid(string s) {
        if(s.size()%2 != 0) return false;
        stack<char> st;
        for(int i=0;i<s.size();i++){
            if(s[i] == '(')  st.push(')');
            else if(s[i] == '[')  st.push(']');
            else if(s[i] == '{')  st.push('}');  
            else if(st.empty() || st.top() != s[i] ){
                return false;
            }
            else st.pop();
        }
        return st.empty();
    }
};
```
### 4. 逆波兰表达式求值
#### 题头
![[题头.png]]
#### 解法 
注意：
1. 因为题目数值给的较大，所以使用 long long 进行储存；
2. 在进行后置计算时，需分清 num 1 和 num 2 是哪个值，注意运算方法。
3. `switch-case ` 语句只能在 case 里放数据或者 char。
```C++
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        // 力扣修改了后台测试数据，需要用longlong
        stack<long long> st; 
        for (int i = 0; i < tokens.size(); i++) {
            if (tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                long long num1 = st.top();
                st.pop();
                long long num2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(num2 + num1);
                if (tokens[i] == "-") st.push(num2 - num1);
                if (tokens[i] == "*") st.push(num2 * num1);
                if (tokens[i] == "/") st.push(num2 / num1);
            } else {
                st.push(stoll(tokens[i]));
            }
        }

        int result = st.top();
        st.pop(); // 把栈里最后一个元素弹出（其实不弹出也没事）
        return result;
    }
};
```

### 滑动窗口移动
#### 题目
![[滑动窗口最大值.png]]
#### 思路
实现一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。
##### 队列使用
滑动窗口中寻找最大值的方法：
**设计单调队列的时候，pop，和 push 操作要保持如下规则：**
1. pop(value)：如果窗口移除的元素 value 等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作;**（目的：将队列中的最大值在未被从窗口中挤出去前保持在队列最前头）**
2. push(value)：如果 push 的元素 value 大于入口元素的数值，那么就将队列入口的元素弹出，直到 push 元素的数值小于等于队列入口元素的数值为止；**（目的：将可能存在的较大数据压入队列，将小数据弹出）**
数据结构示意：
```C++
class MyQueue {
public:
    void pop(int value) {
    }
    void push(int value) {
    }
    int front() {
        return que.front();
    }
};
```

保持如上规则，每次窗口移动的时候，只要问 que.front()就可以返回当前窗口的最大值。
关键 2：判断队首是否弹出，只需判断队首元素是否是当前元素前 k 个即可，即是否该元素在队首
```C++
if(!q.empty() && nums[i-k] ==q.front() ){
                q.pop_front();
            }
```

```C++
class Solution {
public:

    vector<int> maxSlidingWindow(vector<int>& nums, int k) {

        vector <int> res;
        
        deque<int> q;
        //q.push_back(nums[0]);

        for(int i=0;i<k;i++){
            
            while(!q.empty() && q.back() <nums[i]){
                q.pop_back();
            }
            q.push_back(nums[i]);
        }

        res.push_back(q.front());

        for(int i=k;i<nums.size();i++){
	        //关键
            if(!q.empty() && nums[i-k] ==q.front() ){
                q.pop_front();
            }

            while(!q.empty() && q.back() <nums[i]){
                q.pop_back();
            }
            q.push_back(nums[i]);

            res.push_back(q.front());
        }

        return res;
    }
};
```
总结：新建了一个可供排序的单调队列，其原理是：
1. 每次往队列里添加值 n 时，从尾部开始比较，把尾部比较小的值都 pop 掉，最后再 push_back () 入添加值 n。
2. 每次要 pop 值 n 时，判断队列非空并是否队列的头部是 n，如果是，执行 pop_front () 操作，如若不是，则无需 pop。
3. 程序设计思路，首先，将数组里前 k 项 push；再对第 k+1 项数到 nums. Size ()项进行 push 与 pop。从中直接将队列的 front 加入到结果向量中。
直接使用双向队列数据结构 `deque`
```C++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> pq;
        vector<int> res;
        for(int i = 0;i<k;i++){
            while(!pq.empty() && nums[i] > pq.back()){
                pq.pop_back();
            }
            pq.push_back(nums[i]);
        }
        res.push_back(pq.front());
        for(int i = k;i<nums.size();i++){
            if(!pq.empty() && nums[i-k] == pq.front()) pq.pop_front();
            while(!pq.empty() && nums[i] > pq.back()){
                pq.pop_back();
            }
            pq.push_back(nums[i]);
            
            res.push_back(pq.front());
        }
        return res;
    }
};
```
### 前 K 个高频元素
#### 题头
![[前k个高频元素.png]]
#### 解法
##### 解法一：
1. 使用 map 对函数进行统计
2. 用 PAIR 类型的 vector 对 map 进行保存
3. 通过 value 对数组进行排序，取前 K 个值即可。
```C++[]
class Solution {
public:
    typedef pair<int, int> PAIR; 
    struct CmpByValue {  
        bool operator()(const PAIR & lhs, const PAIR & rhs) {  
            return lhs.second > rhs.second;
        }
    }; 

    vector<int> topKFrequent(vector<int>& nums, int k) {
        map<int,int> mp;
        for(auto num:nums){
            mp[num]++;
        }
        vector<PAIR> vec_mp(mp.begin(),mp.end());
        sort(vec_mp.begin(),vec_mp.end(),CmpByValue());
        vector<int> res;
        for(int i=0;i<k;i++){
            res.push_back(vec_mp[i].first);
        }
        return res;
    }
};
```
##### 解法二 ：使用优先队列
首先统计元素出现的频率，这一类的问题可以使用 map 来进行统计。
然后是对频率进行排序，这里我们可以使用一种容器适配器：**优先级队列**。

什么是优先级队列呢？

其实就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。
而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？
缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。

什么是堆呢？

堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。 如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。
###### 大顶堆与小顶堆
所以大家经常说的**大顶堆（堆头是最大元素），小顶堆（堆头是最小元素）**，如果懒得自己实现的话，就直接用priority_queue（优先级队列）就可以了，底层实现都是一样的，从小到大排就是小顶堆，从大到小排就是大顶堆。

本题我们就要使用优先级队列来对部分频率进行排序。

为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。

此时要思考一下，是使用小顶堆呢，还是大顶堆？

有的同学一想，题目要求前 K 个高频元素，那么果断用大顶堆啊。

那么问题来了，定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。
而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？

所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。

寻找前k个最大元素流程如图所示：（图中的频率只有三个，所以正好构成一个大小为3的小顶堆，如果频率更多一些，则用这个小顶堆进行扫描）

```C++
class Solution {
public:
    // 小顶堆
    class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 要统计元素出现频率
        unordered_map<int, int> map; // map<nums[i],对应出现的次数>
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }

        // 对频率排序
        // 定义一个小顶堆，大小为k
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

// 用固定大小为k的小顶堆，扫面所有频率的数值
        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
            pri_que.push(*it);
            if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                pri_que.pop();
            }
        }

// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;

    }
};
```
## 树相关
树的基础概念见 [[C++数据结构与算法基础#二叉树|二叉树]]，二叉树分为广度优先遍历和深度优先遍历，也叫广搜和深搜。
二叉树的定义如下：
```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```
### 深度搜索
在深度优先遍历中：有三个顺序，前中后序遍历。
**这里前中后，其实指的就是中间节点的遍历顺序**，只要大家记住前中后序指的就是中间节点的位置就可以了。
#### 递归遍历
递归算法主要有以下三个要素：
1. 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. 确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. 确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

以下以前序遍历为例：

**1. 确定递归函数的参数和返回值**：因为要打印出前序遍历节点的数值，所以参数里需要传入 vector 来放节点的数值，除了这一点就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是 void，代码如下：
```C++
void traversal(TreeNode* cur, vector<int>& vec)
```
**2. 确定终止条件**：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要结束了，所以如果当前遍历的这个节点是空，就直接 return，代码如下：
```C++
if (cur == NULL) return;
```
**3. 确定单层递归的逻辑**：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：
```C++
vec.push_back(cur->val);    // 中
traversal(cur->left, vec);  // 左
traversal(cur->right, vec); // 右
```
单层递归的逻辑就是按照中左右的顺序来处理的，这样二叉树的前序遍历，基本就写完了，再看一下完整代码：
##### 递归解二叉树前序遍历
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    void traversal(TreeNode* Node,vector<int>&vec){
        if(Node == nullptr){
            return;
        }
        vec.push_back(Node->val);
        traversal(Node->left,vec);
        traversal(Node->right,vec);       
    } 
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> vec;
        traversal(root,vec);
        return vec;
    }
};
```
而对于中序，后序遍历，只需要改变中间节点 push 的位置即可，如下为中序遍历：
```C++
traversal(cur->left, vec);  // 左
vec.push_back(cur->val);    // 中
traversal(cur->right, vec); // 右
```
后序遍历：
```C++
traversal(cur->left, vec);  // 左
traversal(cur->right, vec); // 右
vec.push_back(cur->val);    // 中
```

#### 使用栈进行递归深搜
递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。
此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了

```C++
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> result;
        if (root == NULL) return result;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top(); // 中
            st.pop();
            result.push_back(node->val);
            // 右（空节点不入栈）
            if (node->right) st.push(node->right);
            // 左（空节点不入栈）
            if (node->left) st.push(node->left);
        }
        return result;
    }
};
```
#### 迭代法中序遍历
**迭代思路**：
1. 深度搜索迭代首先建立个 `stack<TreeNode*> st` 栈用于遍历节点
2. 在 `while (!St.empty())` 中进行遍历
```shell
if(curNode !=null){
	1. pop
	2. 添加右节点
	3. 添加中间节点，并push入NULL标记
	4. 添加右节点
}else{
	1. pop出空节点
	2. 取出结果，加入到结果集,pop；
}
```

```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                st.pop();
                result.push_back(cur->val);     // 中
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};

```

### 二叉树深度遍历标准方式
使用 null 作为标记，便可在实际编写程序时起到通用型作用
```C++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if (node->right) st.push(node->right); 
// 添加右节点（空节点不入栈）

                st.push(node);  // 添加中节点
                st.push(NULL); // 中节点访问过，但是还没有处理，加入空节点做为标记。

                if (node->left) st.push(node->left);    // 添加左节点（空节点不入栈）
            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集
                st.pop();           // 将空节点弹出
                node = st.top();    // 重新取出栈中元素
                st.pop();
                result.push_back(node->val); // 加入到结果集
            }
        }
        return result;
    }
};
```
### 翻转二叉树
![[翻转二叉树.png]]
#### 递归写法
```C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 左
        invertTree(root->right);        // 右
        return root;
    }
};
```
#### 使用栈前序遍历写法
```C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right);
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```
### 广度搜索
#### 二叉树的广度优先遍历
```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node->val);
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
```
#### 题目变种：寻找二叉树的最小深度
![[二叉树最小深度.png]]
##### 递归解法
递归三部曲：
- 1. 确定递归参数和返回值：参数为要传入的二叉树根节点，返回的是 int 类型的深度。
```C++
int getDepth(TreeNode* node)
```
- 2. 确定终止条件
终止条件也是遇到空节点返回0，表示当前节点的高度为0。
```C++
if (node == NULL) return 0;
```
- 3. 确定单层递归的逻辑

该逻辑包括：
确定选用左深度还是右深度递归作为返回值，为空时返回 0，左右子节点都不为空时返回递归最小值。
```C++
int leftDepth = getDepth(node->left);           // 左
int rightDepth = getDepth(node->right);         // 右
                                                // 中
// 当一个左子树为空，右不为空，这时并不是最低点
if (node->left == NULL && node->right != NULL) { 
    return 1 + rightDepth;
}   
// 当一个右子树为空，左不为空，这时并不是最低点
if (node->left != NULL && node->right == NULL) { 
    return 1 + leftDepth;
}
int result = 1 + min(leftDepth, rightDepth);
return result;
```
最终递归整体解法：
```C++
class Solution {
public:
    int getDepth(TreeNode* node) {
        if (node == NULL) return 0;
        int leftDepth = getDepth(node->left);           // 左
        int rightDepth = getDepth(node->right);         // 右
                                                        // 中
        // 当一个左子树为空，右不为空，这时并不是最低点
        if (node->left == NULL && node->right != NULL) { 
            return 1 + rightDepth;
        }   
        // 当一个右子树为空，左不为空，这时并不是最低点
        if (node->left != NULL && node->right == NULL) { 
            return 1 + leftDepth;
        }
        int result = 1 + min(leftDepth, rightDepth);
        return result;
    }

    int minDepth(TreeNode* root) {
        return getDepth(root);
    }
};
```
##### 迭代解法
采用广度遍历（层序遍历），当发现某个节点左右都是 null，则可判断已经达到子节点的最小深度节点。
```C++
class Solution {
public:

    int minDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录最小深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
                if (!node->left && !node->right) { // 当左右孩子都为空的时候，说明是最低点的一层了，退出
                    return depth;
                }
            }
        }
        return depth;
    }
};
```
### 对称二叉树判断
![[对称二叉树.png]]
#### 使用队列/栈遍历法
```C++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        queue<TreeNode*> que;
        que.push(root->left);   // 将左子树头结点加入队列
        que.push(root->right);  // 将右子树头结点加入队列
        
        while (!que.empty()) {  // 接下来就要判断这两个树是否相互翻转
            TreeNode* leftNode = que.front(); que.pop();
            TreeNode* rightNode = que.front(); que.pop();
            if (!leftNode && !rightNode) {  // 左节点为空、右节点为空，此时说明是对称的
                continue;
            }

            // 左右一个节点不为空，或者都不为空但数值不相同，返回false
            if ((!leftNode || !rightNode || (leftNode->val != rightNode->val))) {
                return false;
            }
            que.push(leftNode->left);   // 加入左节点左孩子
            que.push(rightNode->right); // 加入右节点右孩子
            que.push(leftNode->right);  // 加入左节点右孩子
            que.push(rightNode->left);  // 加入右节点左孩子
        }
        return true;
    }
};
```
#### 使用递归遍历
```C++
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right) {
        // 首先排除空节点的情况
        if (left == NULL && right != NULL) return false;
        else if (left != NULL && right == NULL) return false;
        else if (left == NULL && right == NULL) return true;
        // 排除了空节点，再排除数值不相同的情况
        else if (left->val != right->val) return false;

        // 此时就是：左右节点都不为空，且数值相同的情况
        // 此时才做递归，做下一层的判断
        bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
        bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
        bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
        return isSame;

    }
    bool isSymmetric(TreeNode* root) {
        if (root == NULL) return true;
        return compare(root->left, root->right);
    }
};
```
### 完全二叉树节点个数
![[完全二叉树节点数.png]]
#### 迭代解法
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int countNodes(TreeNode* root) {
        int cnt = 0;
        if (root == nullptr) return 0; 
        queue<TreeNode*> q;
        TreeNode* cur = root;
        q.push(root);
        while(!q.empty()){
            cur = q.front();
            q.pop();
            cnt++;
            if(cur->left){
                q.push(cur->left);
                //cnt++;
            }
            if(cur->right){
                q.push(cur->right);
                //cnt++;
            }
        } 

        return cnt;
    }
};
```
#### 递归解法
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int cntnodes(TreeNode* node){
        if(node == nullptr) return 0;
        
        if(node->left==nullptr && node->right == nullptr) return 1;
        if(node->left!=nullptr && node->right == nullptr) return cntnodes(node->left)+1;
        if(node->left==nullptr && node->right != nullptr) return cntnodes(node->right)+1;
        
        return cntnodes(node->left)+cntnodes(node->right)+1;
    }

    int countNodes(TreeNode* root) {
        return cntnodes(root);
    }
};
```
### 平衡二叉树（树的高度）
#### 树的高度和深度
- 二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数。
- 二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数。
但 leetcode 中强调的深度和高度很明显是按照节点来计算的，如图：
![[高度与深度.png]]
因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）
#### 题头

#### 解法
##### 递归解法
递归三步曲分析：
1 明确递归函数的参数和返回值
参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。

那么如何标记左右子树是否差值大于1呢？

如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。

所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。

代码如下：
```C++
// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度
int getHeight(TreeNode* node)
```
2 明确终止条件
递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0

代码如下：
```C++
if (node == NULL) {
    return 0;
}
```
明确单层递归的逻辑
如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。

分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。

代码如下：
```C++
int leftHeight = getHeight(node->left); // 左
if (leftHeight == -1) return -1;
int rightHeight = getHeight(node->right); // 右
if (rightHeight == -1) return -1;

int result;
if (abs(leftHeight - rightHeight) > 1) {  // 中
    result = -1;
} else {
    result = 1 + max(leftHeight, rightHeight); // 以当前节点为根节点的树的最大高度
}

return result;
```
最终写法为：
```C++
class Solution {
public:
    // 返回以该节点为根节点的二叉树的高度，如果不是平衡二叉树了则返回-1
    int getHeight(TreeNode* node) {
        if (node == NULL) {
            return 0;
        }
        int leftHeight = getHeight(node->left);
        if (leftHeight == -1) return -1;
        int rightHeight = getHeight(node->right);
        if (rightHeight == -1) return -1;
        return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};
```

##### 迭代解法
```C++
class Solution {
private:
    int getDepth(TreeNode* cur) {
        stack<TreeNode*> st;
        if (cur != NULL) st.push(cur);
        int depth = 0; // 记录深度
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);
                depth++;
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                depth--;
            }
            result = result > depth ? result : depth;
        }
        return result;
    }

public:
    bool isBalanced(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return true;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            if (abs(getDepth(node->left) - getDepth(node->right)) > 1) {
                return false;
            }
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return true;
    }
};
```
当然此题用迭代法，其实效率很低，因为没有很好的模拟回溯的过程，所以迭代法有很多重复的计算。
虽然理论上所有的递归都可以用迭代来实现，但是有的场景难度可能比较大。
例如：都知道回溯法其实就是递归，但是很少人用迭代的方式去实现回溯算法！因为对于回溯算法已经是非常复杂的递归了，如果再用迭代的话，就是自己给自己找麻烦，效率也并不一定高。
### 二叉树所有路径
#### 题目
![[二叉树所有路径.png]]
#### 递归与回溯
复盘：
遍历方式：前序遍历
结束标志：当某个节点的左右子节点都为空时，说明遍历到了叶子节点，此时：
```C++
// 版本一
class Solution {
private:

    void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {
        path.push_back(cur->val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中 
        // 这才到了叶子节点
        if (cur->left == NULL && cur->right == NULL) {
            string sPath;
            for (int i = 0; i < path.size() - 1; i++) {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }
        if (cur->left) { // 左 
            traversal(cur->left, path, result);
            path.pop_back(); // 回溯
        }
        if (cur->right) { // 右
            traversal(cur->right, path, result);
            path.pop_back(); // 回溯
        }
    }

public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;
    }
};
```
递归-回溯的算法框架为：
```C++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
#### 迭代法
```C++
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> treeSt;// 保存树的遍历节点
        stack<string> pathSt;   // 保存遍历路径的节点
        vector<string> result;  // 保存最终路径集合
        if (root == NULL) return result;
        treeSt.push(root);
        pathSt.push(to_string(root->val));
        while (!treeSt.empty()) {
            TreeNode* node = treeSt.top(); treeSt.pop(); // 取出节点 中
            string path = pathSt.top();pathSt.pop();    // 取出该节点对应的路径
            if (node->left == NULL && node->right == NULL) { // 遇到叶子节点
                result.push_back(path);
            }
            if (node->right) { // 右
                treeSt.push(node->right);
                pathSt.push(path + "->" + to_string(node->right->val));
            }
            if (node->left) { // 左
                treeSt.push(node->left);
                pathSt.push(path + "->" + to_string(node->left->val));
            }
        }
        return result;
    }
};
```

### 左叶子遍历
#### 题头
![[左叶子遍历.png]]
#### 解法
##### 迭代法
思路：
1. 递归输入输出：`int getsum(TreeNode* node)`
2. 确定递归结束条件：当一个节点为空（或者其左右孩子为空）时，递归结束，返回 0；
3. 递归处理：检测该节点有左孩子时其左孩子是否有其他孩子，如无，该左孩子便是左叶子节点。
遍历方式：后序遍历（左右中）。
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int getsum(TreeNode* node){
        if(node == nullptr) return 0;
        int sum = 0;
        if(node->left){
            if(node->left->left == nullptr && node->left->right == nullptr ){
                sum+=node->left->val;
            }
            sum+=getsum(node->left);
        }
        if(node->right){
            sum+=getsum(node->right);
        }
        
        return sum;
    }
    int sumOfLeftLeaves(TreeNode* root) {
        return getsum(root);
    }
};
```

### 找数左下角的值
#### 递归回溯解法
思路：层序遍历：中右左

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode *> q;
        q.push(root);
        int res;
        TreeNode * cur = root;
        while(!q.empty()){
            cur = q.front();
            q.pop();
            if(cur->right) q.push(cur->right);
            if(cur->left) q.push(cur->left);
            if(q.empty() && cur->left == nullptr && cur->right == nullptr) return cur->val;
        }
        return cur->val;
    }
};
```
#### 迭代法
```C++

```


### 路径总和
#### 题头
![[路径总和.png]]
#### 递归回溯法
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool travelsal(TreeNode* node , int remaintargetSum){
        if(node->left==nullptr && node->right==nullptr){
            if (remaintargetSum == 0) return true;
            else return false;
        }
        if(node->left){
            if(travelsal(node->left,remaintargetSum-node->left->val)) return true;
        }
        if(node->right){
            if(travelsal(node->right,remaintargetSum-node->right->val)) return true;
        }
        return false;

    } 
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) return false;
        return travelsal(root,targetSum-root->val);
    }
};
```
#### 迭代法
思路：新建一种数据结构 `pair<TreeNode*,int>`，分别存放该树节点和遍历到该节点时从树根开始累计下来的总值。
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    typedef pair<TreeNode*,int> nodeValPair;
    bool hasPathSum(TreeNode* root, int targetSum) {
        stack< nodeValPair > st;
        if(root == nullptr) return false;
        st.push(nodeValPair(root,root->val));
        int lastval = 0;
        while(!st.empty()){
            nodeValPair cur = st.top();
            st.pop();
            
            if(cur.first->left) {
                st.push( nodeValPair(cur.first->left,cur.second+cur.first->left->val) );
            }
            if(cur.first->right){ 
                st.push( nodeValPair(cur.first->right,cur.second+cur.first->right->val) );
            }
            if(cur.first->left == nullptr && cur.first->right== nullptr
                && cur.second == targetSum){         
                return true;
            }
            
        }
        return false;

    }
};
```

### 最大二叉树

#### 递归解法
思路：递归三部曲：
1. 递归输入输出为：`TreeNode* constructMaximumBinaryTree(vector<int>& nums)`
2. 递归终止条件为：当输入的 `nums` 只有一个元素；
3. 递归单层任务：遍历数组，找出最大值构造节点，将数组左右区间分别送入左子树的递归和右子树的递归。
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        TreeNode* node = new TreeNode(0);
        if(nums.size() == 1 ){//递归终止条件
            node->val = nums[0];
            return node;
        } 
        auto idx = max_element(nums.begin(),nums.end());
        int maxnum = *idx;
        node->val = maxnum;
        
        if( idx>nums.begin() ){
            vector<int>b(nums.begin(),idx);
            node->left = constructMaximumBinaryTree( b );
        }
        if( idx < nums.end()-1 ){
            vector<int>b(idx+1,nums.end());
            node->right = constructMaximumBinaryTree( b );
        }
        return node;

    }
};
```
#### 解法二：单调栈
##### 单调栈
> 1 如果栈顶元素大于待插入的元素，那么**直接入栈**。 
> 2 如果栈顶元素小于待插入的元素，那么**栈顶元素出栈**。

这道题使用单调栈的特殊意义在于：可以通过生成左子树->根节点->生成右子树的顺序来对整个树进行生成。
算法为：
> 1> 如果栈顶元素大于待插入的元素，则：**栈顶元素.right = 待插入元素**。 2> 如果栈顶元素小于待插入的元素，则：**待插入元素.left = 栈顶元素**。



```C++
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        Deque<TreeNode> deque = new ArrayDeque();
        for (int i = 0; i < nums.length; i++) {
            TreeNode node = new TreeNode(nums[i]);
            while(!deque.isEmpty()) {
                TreeNode topNode = deque.peekLast();
                if (topNode.val > node.val) {
                    deque.addLast(node);
                    topNode.right = node;
                    break;
                } else {
                    deque.removeLast(); // 出栈操作
                    node.left = topNode;
                }
            }
            if (deque.isEmpty()) deque.addLast(node);
        }
        return deque.peek();
    }
}

```

### 推理：通过中序和后序遍历还原树
#### 思路
- 第一步：如果数组大小为零的话，说明是空节点了。
- 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
- 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
- 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
- 第五步：切割后序数组，切成后序左数组和后序右数组
- 第六步：递归处理左区间和右区间

切割中序数组方法：使用后序遍历的子节点
切割后序数组的方法：使用之前切割的左右字串的 size 来切割后序遍历
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(postorder.size() == 0) return nullptr;

        int postval = postorder[postorder.size()-1];
        TreeNode* root = new TreeNode(postval);

        if(postorder.size() == 1) return root;//叶子节点

        int delIndex;
        for(delIndex =0;delIndex<inorder.size();delIndex++){
            if(inorder[delIndex] == postval) break;
        }
        //左闭右开切割中序数组
        vector<int > leftInorder(inorder.begin(),inorder.begin()+delIndex);
        vector<int > rightInorder(inorder.begin()+delIndex+1,inorder.end());

        //左闭右开切割后序数组并进行递归
        // postorder 舍弃末尾元素，因为这个元素就是中间节点，已经用过了
        postorder.resize(postorder.size() - 1);

        // 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        // [leftInorder.size(), end)
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end());

        root->left  = buildTree(leftInorder,leftPostorder);
        root->right = buildTree(rightInorder,rightPostorder);

        return root;
    }
};
```

#### 简化解法 :
思路：不再定义过多的 vector，采用数组的 `[begin, end)` 索引来进行区间划分
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* travelsal( vector<int>& inorder, vector<int>& postorder, int inorderbegin ,
        int inorderend,int postorderbegin,int postorderend ){
            //结束标志
            if(postorderbegin == postorderend) return nullptr;

            int postval = postorder[postorderend-1];
            TreeNode* root = new TreeNode(postval);
            if(postorderend-postorderbegin == 1) return root;
            int delIndex;
            //分割中序遍历数组
            for(delIndex = inorderbegin; delIndex < inorderend; delIndex++){
                if(inorder[delIndex] == postval) break;
            }
            //[inordebegin,delIndex)----[deLIndex+1,inorderend)

            //分割后序遍历数组
            //int leftTreeSize = delIndex-inorderbegin;
            //[postorderbegin,postorderbegin+delIndex-inorderbegin)----[postorderbegin+delIndex-inorderbegin,postorderend-1)          

            //树递归
            root->left = travelsal(inorder,postorder,inorderbegin,delIndex,postorderbegin,postorderbegin+delIndex-inorderbegin);
            root->right = travelsal(inorder,postorder,delIndex+1,inorderend,postorderbegin+delIndex-inorderbegin,postorderend-1);
            return root;

    }

    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if (inorder.size() == 0 || postorder.size() == 0) return NULL;
        int size1 = inorder.size();
        return travelsal(inorder,postorder,0,size1,0,size1);
    }
};
```
### 合并二叉树 
![[合并二叉树.png]]
#### 递归解法
```C++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
        if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
        // 修改了t1的数值和结构
        t1->val += t2->val;                             // 中
        t1->left = mergeTrees(t1->left, t2->left);      // 左
        t1->right = mergeTrees(t1->right, t2->right);   // 右
        return t1;
    }
};
```
#### 层序遍历解法
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        queue<TreeNode*> nodeQ;
        if(root1==nullptr) return root2;
        if(root2==nullptr) return root1;
        nodeQ.push(root1);
        nodeQ.push(root2);
        while(!nodeQ.empty()){
            TreeNode* cur1 = nodeQ.front();nodeQ.pop();
            TreeNode* cur2 = nodeQ.front();nodeQ.pop();
            cur1->val+=cur2->val;
            if( cur1->left != nullptr && cur2->left != nullptr ){
                nodeQ.push(cur1->left);nodeQ.push(cur2->left);
            }
            if( cur1->right != nullptr && cur2->right != nullptr ){
                nodeQ.push(cur1->right);nodeQ.push(cur2->right);
            }
            if( cur1->left == nullptr && cur2->left != nullptr ){
                cur1->left = cur2->left;
            }
            if( cur1->right == nullptr && cur2->right != nullptr ){
                cur1->right = cur2->right;
            }
        }
        return root1;
    }
};
```
### 二叉搜索树
#### 二叉搜索树性质
- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉搜索树

#### 递归法

#### 迭代法
```C++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```

### 二叉搜索树的最小绝对差
![[Pasted image 20231018095005.png]]
#### 思路
题目中要求在二叉搜索树上任意两节点的差的绝对值的最小值。
注意是二叉搜索树，二叉搜索树可是有序的。
遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个有序数组上求最值，求差值，这样就简单多了。
**关键**：本体解法的关键在于使用一个 pre 节点保存 cur 上一个节点的指针，这样便能比较中序遍历结果相邻值。
#### 迭代解法
此题解法实际上便是一种中序遍历，遍历时求 cur 节点与 pre 节点值之间的差即可。
```C++
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int result = INT_MAX;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top();
                st.pop();
                if (pre != NULL) {              // 中
                    result = min(result, cur->val - pre->val);
                }
                pre = cur;
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```
### 寻找二叉树中的众数
501
![[Pasted image 20231018105301.png]]
#### 递归解法
```C++
class Solution {
private:
    int maxCount = 0; // 最大频率
    int count = 0; // 统计频率
    TreeNode* pre = NULL;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;

        searchBST(cur->left);       // 左
                                    // 中
        if (pre == NULL) { // 第一个节点
            count = 1;
        } else if (pre->val == cur->val) { // 与前一个节点数值相同
            count++;
        } else { // 与前一个节点数值不同
            count = 1;
        }
        pre = cur; // 更新上一个节点

        if (count == maxCount) { // 如果和最大值相同，放进result中
            result.push_back(cur->val);
        }

        if (count > maxCount) { // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur->val);
        }

        searchBST(cur->right);      // 右
        return ;
    }

public:
    vector<int> findMode(TreeNode* root) {
        count = 0;
        maxCount = 0;
        pre = NULL; // 记录前一个节点
        result.clear();

        searchBST(root);
        return result;
    }
};
```

#### 迭代解法
```C++
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int maxCount = 0; // 最大频率
        int count = 0; // 统计频率
        vector<int> result;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur->left;                // 左
            } else {
                cur = st.top();
                st.pop();                       // 中
                if (pre == NULL) { // 第一个节点
                    count = 1;
                } else if (pre->val == cur->val) { // 与前一个节点数值相同
                    count++;
                } else { // 与前一个节点数值不同
                    count = 1;
                }
                if (count == maxCount) { // 如果和最大值相同，放进result中
                    result.push_back(cur->val);
                }

                if (count > maxCount) { // 如果计数大于最大值频率
                    maxCount = count;   // 更新最大频率
                    result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
                    result.push_back(cur->val);
                }
                pre = cur;
                cur = cur->right;               // 右
            }
        }
        return result;
    }
};
```
### 二叉树最近公共祖先
![[Pasted image 20231018141917.png]]
采用后序遍历+回溯的方式进行搜索：
递归结束方法：如果节点搜索到了 p, q，则节点返回 p, q；如果节点搜索到了 null，则直接返回 null
单层递归方案：如果搜索到左右节点都为非空，则直接返回当前节点；
若只有一侧非空，则返回左/右侧非空子节点
若双空，则返回空。

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == NULL||root == p||root == q){
            return root;
        }
        TreeNode* left = lowestCommonAncestor(root->left,p,q);
        TreeNode* right = lowestCommonAncestor(root->right,p,q);
        if(left&&right) return root;

        if (left == NULL && right != NULL) return right;
        else if (left != NULL && right == NULL) return left;
        else  { //  (left == NULL && right == NULL)
            return NULL;
        }
        
    }
};
```

### 二叉搜索树中的插入操作
![[二叉搜索树插入操作.png]]
#### 写法 1：使用原逻辑
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
       
        if (root == nullptr) return new TreeNode(val);
         TreeNode* cur = root;
        //TreeNode* pre = nullptr;
        while(true){
            //cout<<cur->val<<endl;
            //if(cur->left && cur->right)
            if(val > cur->val ){
                //pre = cur;
                if(cur->right) {
                    cur = cur->right;
                    //cout<<"firstin = "<<cur->val<<endl;
                }
                else{
                    TreeNode* insertNode = new TreeNode(val);
                    cur->right=insertNode;
                    break;
                }
            }
            else if(val < cur->val ){
                if(cur->left) {
                    cur = cur->left;
                    //cout<<"secondin = "<<cur->val<<endl;
                }
                else{
                    //cout<<"secondbreak = "<<cur->val<<endl;
                    TreeNode* insertNode = new TreeNode(val);
                    cur->left = insertNode;
                    //cout<<"secondout = "<<insertNode->val<<""<<endl;
                    break;
                }
            }
            
            
        }
        return root;
    }
};
```
### 450. 删除二叉搜索树中的节点
![[删除二叉搜索树上的节点.png]]
#### 递归解法
思路：
```C++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if (root->val == key) {
            // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            if (root->left == nullptr && root->right == nullptr) {
                ///! 内存释放
                delete root;
                return nullptr;
            }
            // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
            else if (root->left == nullptr) {
                auto retNode = root->right;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
            else if (root->right == nullptr) {
                auto retNode = root->left;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            // 并返回删除节点右孩子为新的根节点。
            else {
                TreeNode* cur = root->right; // 找右子树最左面的节点
                while(cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp = root;   // 把root节点保存一下，下面来删除
                root = root->right;     // 返回旧root的右孩子作为新root
                delete tmp;             // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            }
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```
### 修剪二叉搜索树
![[修剪二叉搜索树.png]]
#### 递归思路
> 1. 递归函数 `TreeNode* trimBST(TreeNode* root, int low, int high)`
> 2. 结束递归条件（遍历到空节点）
> 3. 单层递归操作
```Shell
if(节点值不在[low,high]之间){
	寻找值在区间内的节点，并返回该节点
}
root->left与root->right接入符合条件的节点，即trimBST(TreeNode* root, int low, int high)
```

```C++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == nullptr ) return nullptr;
        if (root->val < low) {
            TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点
            return right;
        }
        if (root->val > high) {
            TreeNode* left = trimBST(root->left, low, high); // 寻找符合区间[low, high]的节点
            return left;
        }
        root->left = trimBST(root->left, low, high); // root->left接入符合条件的左孩子
        root->right = trimBST(root->right, low, high); // root->right接入符合条件的右孩子
        return root;
    }
};
```
### 将有效数组转为二叉搜索树
#### 递归解法
不断二分即可
```C++
class Solution {
private:
    TreeNode* traversal(vector<int>& nums, int left, int right) {
        if (left > right) return nullptr;
        int mid = left + ((right - left) / 2);
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = traversal(nums, left, mid - 1);
        root->right = traversal(nums, mid + 1, right);
        return root;
    }
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root = traversal(nums, 0, nums.size() - 1);
        return root;
    }
};
```

### 把二叉树转换为累加树
#### 递归解法
```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int pre = 0;

    TreeNode* convertBST(TreeNode* root) {
        if(root == nullptr) return nullptr;
        convertBST(root->right);
        root->val+=pre;
        pre = root->val;
        convertBST(root->left);
        return root;

    }
};
```
### 路径总和 3
![[Pasted image 20240508204832.png]]
#### Dfs
回溯时，返回值为后续的路径总和。
```C++
class Solution {
public:
    long long rootSum(TreeNode* root, long long targetSum) {
        if (!root) {
            return 0;
        }

        long long ret = 0;
        if (root->val == targetSum) {
            ret++;
        } 

        ret += rootSum(root->left, targetSum - root->val);
        ret += rootSum(root->right, targetSum - root->val);
        return ret;
    }

    int pathSum(TreeNode* root, int targetSum) {
        if (!root) {
            return 0;
        }
        
        long long ret = rootSum(root, targetSum);
        ret += pathSum(root->left, targetSum);
        ret += pathSum(root->right, targetSum);
        return ret;
    }
};
```
#### 前缀和写法 

```C++
class Solution {
public:
    unordered_map<long long, int> prefix;
	//curr累计前缀和，ret累计路径和恰好targetSum的值之和
	//递推：计算前缀和
	//回溯:计算传递满足要求路径数
    int dfs(TreeNode *root, long long curr, int targetSum) {
        if (!root) {
            return 0;
        }

        int ret = 0;
        curr += root->val;
        //搜索是否存在以当前节点为末尾的最短路径。
        if (prefix.count(curr - targetSum)) {
            ret = prefix[curr - targetSum];
        }

        prefix[curr]++;
        ret += dfs(root->left, curr, targetSum);
        ret += dfs(root->right, curr, targetSum);
        prefix[curr]--;
        //回溯过程
        
        return ret;
    }

    int pathSum(TreeNode* root, int targetSum) {
        prefix[0] = 1;
        return dfs(root, 0, targetSum);
    }
};

```
## 回溯算法
### 简单组合
![[组合题.png]]
#### 剪枝回溯

```C++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(int n, int k, int startIndex) {
        if (path.size() == k) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化的地方
            path.push_back(i); // 处理节点
            backtracking(n, k, i + 1);
            path.pop_back(); // 回溯，撤销处理的节点
        }
    }
public:

    vector<vector<int>> combine(int n, int k) {
        backtracking(n, k, 1);
        return result;
    }
};
```
### 电话号码的字母组合
![[电话号码的字母组合.png]]
#### 回溯思路
首先建立数字字母映射表
然后建立遍历树模型
回溯
>回溯三要素
>1. 函数原型 `backTracking (int Index,const string & digits,const int & Maxsize)` 包含参数：`Index`、输入参数 `digits`、输入参数的 `size`
>2. 返回条件：当出现路径字符串 `path` 的 `size` 等于设定最大字符时，将 `pathString` 添加进结果
>3. 单层递归逻辑：以字母组合构建多叉树的网络模型，组层遍历与回溯
```C++
class Solution {
public:
    vector<string> result;
    string pathString;
    vector<string> numtoLetter = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"};
    void backTracking (int Index,const string & digits,const int & Maxsize){
        if(pathString.size() == Maxsize){
            result.push_back(pathString);
            return;
        }
        int digit = digits[Index] - '0';
        //string tmpString(('a'+digits[i]));
        for (auto charnum: numtoLetter[digit]){
            pathString.push_back(charnum);
            backTracking(Index+1,digits,Maxsize);
            pathString.pop_back();
        }
        
    }
    vector<string> letterCombinations(string digits) {
        int Maxsize = digits.size();
        if (Maxsize == 0) return result;
        backTracking(0,digits,Maxsize);
        return result;

    }
};
```
### 组合总和
![[组合总和.png]]
#### 回溯思路
因为可以重复选取数据，故 `strartIndex` 只需设置为 i 即可，即每次组合都从当前选取的第一层的值开始，避免多选少选
#### 剪枝思路
可以对数组进行从小到大排列，这样当加上下一个值会大于目标值时，则不再进行下一层遍历：如下
```shell
for(int i = startIndex;i<candidates.size() && (targetSum-candidates[i])>=0 ;i++){

}
```
#### C++代码
```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(int targetSum,const vector<int>& candidates,int startIndex){
        if(targetSum == 0){
            res.push_back(path);
            return;
        }


        for(int i = startIndex;i<candidates.size() && (targetSum-candidates[i])>=0 ;i++){
            targetSum-= candidates[i];
            path.push_back(candidates[i]);
            backTracking(targetSum,candidates,i);
            targetSum+= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end()); // 需要排序
        backTracking(target,candidates,0);
        return res;
    }
};
```
### 组合总和 2
该题和上题的要求在于需要对结果数组进行去重
![[Pasted image 20231030100130.png]]
去重方案：判断是否为同一个树层的相同树，如果出现相同数，则可能会遍历到同一子树
![](https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png)
关键的去重代码则是判断当不在第一层的情况下，
```C++
if(i > startIndex && candidates[i] == candidates[i-1]){
	continue;
}
```

```C++
class Solution {
public:
    vector<vector<int>> res;
    vector<int> path;
    void backTracking(int targetSum,const vector<int>& candidates,int startIndex){
        if(targetSum == 0){
            //if(find(res.begin(),res.end(),path) == res.end())超时
            res.push_back(path);
            return;
        }
        for(int i = startIndex;i<candidates.size() && (targetSum-candidates[i])>=0 ;i++){
            if(i > startIndex && candidates[i] == candidates[i-1]){
                continue;
            }
            targetSum-= candidates[i];
            path.push_back(candidates[i]);
            backTracking(targetSum,candidates,i+1);
            targetSum+= candidates[i];
            path.pop_back();
        }
    }
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end()); // 需要排序
        backTracking(target,candidates,0);
        return res;
    }
};
```
### 分割回文子串
![[Pasted image 20231030201603.png]]
#### 思路
分割回文子串同其他回溯算法体一样，但需要重新抽象某些具体细节。可以认为每个字符之间都有个逗号，分割本质上是选不选该逗号，题目便是找出满足要求的所有‘，’位置子集。
当然，本题中本质上是在对子字符串末尾位置进行回溯，找到其所有的子集。
```C++
class Solution {
private:
    vector<vector<string>> result;
    vector<string> path; // 放已经回文的子串
    void backtracking (const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome(s, startIndex, i)) {   // 是回文子串
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {                                // 不是回文，跳过
                continue;
            }
            backtracking(s, i + 1); // 寻找i+1为起始位置的子串
            path.pop_back(); // 回溯过程，弹出本次已经添加的子串
        }
    }
    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; i++, j--) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
public:
    vector<vector<string>> partition(string s) {
        result.clear();
        path.clear();
        backtracking(s, 0);
        return result;
    }
};
```


### 子集（标准组合问题）
![[子集.png]]
#### 解法
解法：以递归+回溯的方法遍历所有可能性即可，返回条件可取消，且需要将所有 path 放入结果中。
```C++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉自己
        if (startIndex >= nums.size()) { // 终止条件可以不加
            return;
        }
        for (int i = startIndex; i < nums.size(); i++) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    }
};

```
### 子集 2
![[Pasted image 20231102152407.png]]
和上题区别在于 `nums` 各个元素不一定互不相同，可能会出现重复，而又要求最后结果不出现重复值。
#### 剪枝去重法
和题目 [[#组合总和 2]] 一样，可以在判断 `i>startIndex && muns[i]==nums[i-1]` 时出现的重复子树，故可判断跳过后序的遍历。
这道题的特殊性在于每次遍历回溯时是从 `startIndex` 开始的，故可以用上述条件方法，如若不是，则需要使用 `used` 数组储存是否用过前面出现的值。关键判断条件为：
```C++
// used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
            // used[i - 1] == false，说明同一树层candidates[i - 1]使用过
            // 而我们要对同一树层使用过的元素进行跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }

```
最终解法为：
```C++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> res;
    void backtracking(const vector<int>& nums,int startIndex){
        res.push_back(path);
        if(startIndex>=nums.size()){
            return;
        }
        for(int i = startIndex;i<nums.size();i++){
            if(i > startIndex && nums[i] == nums[i-1]){
                continue;
            }else{
                path.push_back(nums[i]);
                backtracking(nums,i+1);
                path.pop_back();
            }
        }
    }
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        backtracking(nums,0);
        return res;
    }
};
```

#### 使用 set 去重
```C++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path);
        unordered_set<int> uset;
        for (int i = startIndex; i < nums.size(); i++) {
            if (uset.find(nums[i]) != uset.end()) {
                continue;
            }
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // 去重需要排序
        backtracking(nums, 0);
        return result;
    }
};
```
### 递增子序列
![[Pasted image 20231102161525.png]]
使用数组代替哈希 `unordered_set` 进行哈希
```C++
// 版本二
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        if (path.size() > 1) {
            result.push_back(path);
        }
        int used[201] = {0}; // 这里使用数组来进行去重操作，题目说数值范围[-100, 100]
        for (int i = startIndex; i < nums.size(); i++) {
            if ((!path.empty() && nums[i] < path.back())
                    || used[nums[i] + 100] == 1) {
                    continue;
            }
            used[nums[i] + 100] = 1; // 记录这个元素在本层用过了，本层后面不能再用了
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        result.clear();
        path.clear();
        backtracking(nums, 0);
        return result;
    }
};
```

### 全排列
#### 解法：使用 used 数组
![46.全排列](https://code-thinking-1253855093.file.myqcloud.com/pics/20201209174225145.png)

可以看出叶子节点，就是收割结果的地方。
那么什么时候，算是到达叶子节点呢？
当收集元素的数组 path 的大小达到和 nums 数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。

对于如何判断遇到了重复的排列，可使用一个 `used` 数组作为回溯函数 `backTracking` 的参数用于判断是否重复使用了元素。
在本题中，由于各个元素互不相同，故可以使用 
`if (used[i] == true) continue; // path里已经收录的元素，直接跳过` 去重
`


```C++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking (vector<int>& nums, vector<bool>& used) {
        // 此时说明找到了一组
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            if (used[i] == true) continue; // path里已经收录的元素，直接跳过
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

### 全排列 2
![[Pasted image 20231108195626.png]]
#### 解题思路
仍然使用 `used` 数组去判断是否重复遍历过数组进行排列，关键在于 `if(used[i] == false)`，但本题还需要考虑要对同层进行去重，即如果同层遍历到相同数，应该 continue。条件 `i>0 && nums[i]==nums[i-1]` 很容易想到，但如果不加上 `&&used[i-1] == false`，则会出现以下情况：递归到非第一层时发现在两个相同的数如 `{1,1,2}` 中的 `{1,1}` 时，由于 1 和 1 重复，但由于重复而直接 continue 了。
故应该考虑并上不在最外层的考虑，最好的方法就是判断 `used[i-1]` 为 false 作为跳过该分枝叶的条件。

**使用该方案去重时必须对数组进行排序**
```C++
if(i>0 && nums[i]==nums[i-1] && used[i-1] == false){
	continue;
}

if(used[i] == false){
	used[i] = true;
	path.push_back(nums[i]);
	backTracking(nums,used);
	used[i] = false;
	path.pop_back();
}
```

```C++
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking (vector<int>& nums, vector<bool>& used) {
        // 此时说明找到了一组
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            // used[i - 1] == true，说明同一树枝nums[i - 1]使用过
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过
            // 如果同一树层nums[i - 1]使用过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            if (used[i] == false) {
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // 排序
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};

// 时间复杂度: 最差情况所有元素都是唯一的。复杂度和全排列1都是 O(n! * n) 对于 n 个元素一共有 n! 中排列方案。而对于每一个答案，我们需要 O(n) 去复制最终放到 result 数组
// 空间复杂度: O(n) 回溯树的深度取决于我们有多少个元素
```
但实际上，**如果改成 `used[i - 1] == true`，也是正确的!**，去重代码如下：

```C++
if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == true) {
    continue;
}
```

这是为什么呢，就是上面我刚说的，如果要对树层中前一位去重，就用 `used[i - 1] == false`，如果要对树枝前一位去重用 `used[i - 1] == true`。

**对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！**
这么说是不是有点抽象？

来来来，我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![47.全排列II2](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201406192.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![47.全排列II3](https://code-thinking-1253855093.file.myqcloud.com/pics/20201124201431571.png)

大家应该很清晰的看到，树层上对前一位去重非常彻底，效率很高，树枝上对前一位去重虽然最后可以得到答案，但是做了很多无用搜索

### 332 重新安排行程
#### 解题思路（图的深度搜索）

#### 解题思路（回溯法）
使用 `unordered_map<出发机场, map<到达机场, 航班次数>> targets` 该数据结构对起点终点数据 `targets` 进行排序，并进行映射。
每次遍历回溯关键在于判断 `targets[result.back()]` 对应的航班次数是否大于 0
`If (backtracking (ticketNum, result)) return true;` 这句的含义为到了叶子节点直接返回，用于控制找到唯一
```C++
for (pair<const string, int>& target : targets[result.back()]) {
        if (target.second > 0 ) { // 记录到达机场是否飞过了
            result.push_back(target.first);
            target.second--;
            //这句的含义为到了叶子节点直接返回
            if (backtracking(ticketNum, result)) return true;
            result.pop_back();
            target.second++;
        }
    }
```


```C++
class Solution {
private:
// unordered_map<出发机场, map<到达机场, 航班次数>> targets
unordered_map<string, map<string, int>> targets;
bool backtracking(int ticketNum, vector<string>& result) {
    if (result.size() == ticketNum + 1) {
        return true;
    }
    for (pair<const string, int>& target : targets[result[result.size() - 1]]) {
        if (target.second > 0 ) { // 记录到达机场是否飞过了
            result.push_back(target.first);
            target.second--;
            if (backtracking(ticketNum, result)) return true;
            result.pop_back();
            target.second++;
        }
    }
    return false;
}
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        targets.clear();
        vector<string> result;
        for (const vector<string>& vec : tickets) {
            targets[vec[0]][vec[1]]++; // 记录映射关系
        }
        result.push_back("JFK"); // 起始机场
        backtracking(tickets.size(), result);
        return result;
    }
};
```
### N 皇后
```C++
class Solution {
private:
vector<vector<string>> result;
// n 为输入的棋盘大小
// row 是当前递归到棋盘的第几行了
void backtracking(int n, int row, vector<string>& chessboard) {
    if (row == n) {
        result.push_back(chessboard);
        return;
    }
    for (int col = 0; col < n; col++) {
        if (isValid(row, col, chessboard, n)) { // 验证合法就可以放
            chessboard[row][col] = 'Q'; // 放置皇后
            backtracking(n, row + 1, chessboard);
            chessboard[row][col] = '.'; // 回溯，撤销皇后
        }
    }
}
bool isValid(int row, int col, vector<string>& chessboard, int n) {
    // 检查列
    for (int i = 0; i < row; i++) { // 这是一个剪枝
        if (chessboard[i][col] == 'Q') {
            return false;
        }
    }
    // 检查 45度角是否有皇后
    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    // 检查 135度角是否有皇后
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (chessboard[i][j] == 'Q') {
            return false;
        }
    }
    return true;
}
public:
    vector<vector<string>> solveNQueens(int n) {
        result.clear();
        std::vector<std::string> chessboard(n, std::string(n, '.'));
        backtracking(n, 0, chessboard);
        return result;
    }
};
```

### 解数烛
![[Pasted image 20231111161811.png]]
关键思路：和上题不同，此题不需要记录从哪开始，是因为当填入一个值后便在回溯时会跳过该层
```C++
class Solution {
private:
bool backtracking(vector<vector<char>>& board) {
    for (int i = 0; i < board.size(); i++) {        // 遍历行
        for (int j = 0; j < board[0].size(); j++) { // 遍历列
            if (board[i][j] == '.') {
                for (char k = '1'; k <= '9'; k++) {     // (i, j) 这个位置放k是否合适
                    if (isValid(i, j, k, board)) {
                        board[i][j] = k;                // 放置k
                        if (backtracking(board)) return true; // 如果找到合适一组立刻返回
                        board[i][j] = '.';              // 回溯，撤销k
                    }
                }
                return false;  // 9个数都试完了，都不行，那么就返回false
            }
        }
    }
    return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
}
bool isValid(int row, int col, char val, vector<vector<char>>& board) {
    for (int i = 0; i < 9; i++) { // 判断行里是否重复
        if (board[row][i] == val) {
            return false;
        }
    }
    for (int j = 0; j < 9; j++) { // 判断列里是否重复
        if (board[j][col] == val) {
            return false;
        }
    }
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++) { // 判断9方格里是否重复
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == val ) {
                return false;
            }
        }
    }
    return true;
}
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtracking(board);
    }
};
```
### 单词搜索
![[Pasted image 20240320123511.png]]
```C++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        rows = board.size();
        cols = board[0].size();
        for(int i = 0; i < rows; i++) {
            for(int j = 0; j < cols; j++) {
                if (dfs(board, word, i, j, 0)) return true;
            }
        }
        return false;
    }
private:
    int rows, cols;
    bool dfs(vector<vector<char>>& board, string word, int i, int j, int k) {
        if (i >= rows || i < 0 || j >= cols || j < 0 || board[i][j] != word[k]) return false;
        if (k == word.size() - 1) return true;
        board[i][j] = '\0';//置零即表示遍历过
        bool res = dfs(board, word, i + 1, j, k + 1) 
				|| dfs(board, word, i - 1, j, k + 1) 
				|| dfs(board, word, i, j + 1, k + 1) 
				|| dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    }
};

```
### Dfs
```C++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++)
            for(int j = 0; j < board[i].size(); j++)
                if(dfs(board,word,0,i,j)) return true;
        return false;        
    }
    int dx[4] = {-1,0,1,0}, dy[4] = {0,1,0,-1}; //方向数组
    bool dfs(vector<vector<char>>& board, string& word,int u,int x,int y)
    {
        if(board[x][y] != word[u]) return false;
        if(u == word.size() - 1)   return true;
        char t = board[x][y];
        board[x][y] = '.';
        for(int i = 0; i < 4; i++)
        {
            int a = x + dx[i], b = y + dy[i];
            //出界或者走到已经搜索过的位置
            if(a < 0 || a >= board.size() || b < 0 || b >= board[0].size() || board[a][b] == '.')  continue;
            if(dfs(board,word,u+1,a,b)) return true;
        }
        board[x][y] = t;
        return false;
    }
};

```
# 力扣热题 100
## 字母易位重组
### 题头
### 解法 1：使用哈希编码
```C++

/*
 * @lc app=leetcode.cn id=49 lang=cpp
 *
 * [49] 字母异位词分组
 */

// @lc code=start
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map <string,vector<string>> u_mapres;
        for(auto str:strs){
            u_mapres[encode(str)].push_back(str);

        }
        for( auto pair:  u_mapres ){
            res.push_back(pair.second);
        }
        return res;
    }

    string encode(string s){
        string count(26,'0');
        for (char c :s)
        {
            count[c-'a']++;
        }
        return count;
    }
};

```
时间复杂度：$O (n (k+∣Σ∣))$ ，其中 n 是 strs中的字符串的数量，k 是 strs 中的字符串的的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，∣Σ∣=26。需要遍历 n 个字符串，对于每个字符串，需要 $O (k)$ 的时间计算每个字母出现的次数，$O (∣Σ∣)$ 的时间生成哈希表的键，以及 O (1)的时间更新哈希表，因此总时间复杂度是  $O (n (k+∣Σ∣))$。

空间复杂度：$O (n (k+∣Σ∣))$ ，其中 n 是 strs 中的字符串的数量，k 是 strs 中的字符串的最大长度，Σ 是字符集，在本题中字符集为所有小写字母，$∣Σ∣=26$。需要用哈希表存储全部字符串，而记录每个字符串中每个字母出现次数的数组需要的空间为 $O (∣Σ∣)$ ，在渐进意义下小于   $O (n (k+|\Sigma|))$ ，可以忽略不计。

### 解法 2
通过对每个字符进行排序
```C++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        vector<vector<string>> res;
        unordered_map <string ,vector<string>> mp;
        for (auto s : strs){
            string tmp = s;
            sort(s.begin(),s.end());
            mp[s].push_back(tmp);
        }
        for(auto pair :mp){
            res.push_back(pair.second);
        }

        return res;
    }
};
```
时间复杂度：$O (nklog⁡k)$ ，其中 n 是 $\textit{strs}$ 中的字符串的数量，k 是 $\textit{strs}$ 中的字符串的的最大长度。需要遍历 n 个字符串，对于每个字符串，需要   $O (klogk)$ 的时间进行排序以及$O (1)$ 的时间更新哈希表，因此总时间复杂度是 $O (nklog⁡k)$。
空间复杂度 $O (nk)$

## 最长连续序列
![[Pasted image 20231115163201.png]]
### 哈希解法
**精彩优化**：
1. 使用 `unordered_set` 对数组进行去重
2. 使用 `if(!st.count(num - 1))` 条件保证每次都从递增序列最小值开始搜索最长序列。

```C++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set st(nums.begin(),nums.end());
        int res =0,cnt = 0;
        for (const int& num : st){
            if(!st.count(num - 1)){//确定不会出现反复搜索
                int curnum = num;
                int cursteak = 1;
                
                while(st.count(curnum + 1)){
                    curnum++;
                    cursteak++;//累加值
                }
                res = max(res,cursteak);
            }
        }
        return res;
    }
};
```

## 移动零
![[Pasted image 20231115165145.png]]
```C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int n = nums.size(), left = 0, right = 0;
        while (right < n) {
            if (nums[right]) {
                swap(nums[left], nums[right]);
                left++;
            }
            right++;
        }
    }
};


```
# 每日一题&&热题 100
## 2371 移动机器人
### 题头
![[移动机器人.png]]
### 解法
思路：关键点在于思考到机器人在相撞后其实能看作仍然沿着原轨迹移动，故只需要排序后统计所有机器人的位置，计算两两位置之和即可。
```C++
class Solution {
public:
    int sumDistance(vector<int>& nums, string s, int d) {
        int robonum = nums.size();
        vector<long long> arr(robonum);
        for(int i=0;i<robonum;i++){
            if(s[i] == 'L') arr[i] = nums[i]-d;
            else if(s[i] == 'R') arr[i] = nums[i]+d;
            
        }
        sort(arr.begin(),arr.end());
        long long res = 0;
        long long sum = 0;
        long long modnum = 1e9+7;
        for(int i =0 ;i<robonum;i++){
            res=(res+ i*arr[i]-sum )% modnum;
            sum+=arr[i];
            //cout<<"res:"<<res<<","<<"sum:"<<sum<<endl;
        }
        return res;
        
    }
};
```
计算两两位置之和有着下面这段关键代码：
```C++
int64_t ans = 0, sum = 0;
		for (int i = 0; i < n; ++i) {
			ans = (ans + pos[i] * i - sum) % MOD;
			sum += pos[i];
		}
		return ans;
```
可有效将 $O(n^2)$ 的复杂度降为 $O(log n)$

## 最大单词长度乘积
![[Pasted image 20231106111237.png]]
### 解法
使用下面这段代码建立每一个 `word` 的掩码
```C++
for (int j = 0; j < wordLength; j++) {
	masks[i] |= 1 << (word[j] - 'a');
}
```
之后两两比较 `masks[i] & masks[j]) == 0` 掩码即可得知是否存在重复值
```C++
class Solution {
public:
    int maxProduct(vector<string>& words) {
        int length = words.size();
        vector<int> masks(length);
        for (int i = 0; i < length; i++) {
            string word = words[i];
            int wordLength = word.size();
            for (int j = 0; j < wordLength; j++) {
                masks[i] |= 1 << (word[j] - 'a');
            }
        }
        int maxProd = 0;
        for (int i = 0; i < length; i++) {
            for (int j = i + 1; j < length; j++) {
                if ((masks[i] & masks[j]) == 0) {
                    maxProd = max(maxProd, int(words[i].size() * words[j].size()));
                }
            }
        }
        return maxProd;
    }
};


```

## 和为 K 的子数组
![[Pasted image 20240129223756.png]]
### 解法一：暴力枚举（会超时）
暴力遍历得到所有的子数组之和, 时间复杂度为 $O(n^2)$
```C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
         int res = 0;
         for(int leftIdnex = 0;leftIdnex<nums.size();leftIdnex++){
             int tmpSum = 0;
             for(int rightIndex = leftIdnex+1;rightIndex<=nums.size();rightIndex++){
                 
                tmpSum+=nums[rightIndex-1];
                // if(tmpSum>k) break;
                if(tmpSum == k){
                    res++;
                } 
             }
         }
         return res;
    }
};
```
### 前缀和思路
我们可以基于方法一利用数据结构进行进一步的优化，我们知道方法一的瓶颈在于对每个i，我们需要枚举所有的 j 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。

我们定义 $pre[i]为 [0, i]$ 里所有数的和，则 $pre[i]$ 可以由 $pre[i−1]$ 递推而来，即：
$Pre[i]=pre[i−1]+nums[i]$
那么数组 $nums[i,...,j]$ 和为 k 这个条件我们可以转化为
$$Pre[i]−pre[j−1]==k$$
简单移项可得符合条件的下标j需要满足
$$Pre[j−1]==pre[i]−k$$
我们可以使用哈希表来保存 `pre[i]`，这样只需要一次遍历便可获得所有上公式成立的 `pre[j-1]` 。值得注意的是：当 $[0,..i]$ 项子数组和 $Pre[i]$ 恰好为 k 时，也要算做有一个子数组满足要求，这往往会被忘记。可以提前设定 `mp[0] = 1` 或者
`if(pre == k) res++;`
> 边遍历建立前缀和哈希边统计 res 的原因：需要保证 $i>=j$
```C++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int res = 0;
        int pre = 0;
        unordered_map<int ,int> mp_subarray_zero2i;
        mp_subarray_zero2i[0] = 1;
        for(int num:nums){
            pre+=num;
            if(mp_subarray_zero2i.find(pre - k) != mp_subarray_zero2i.end()){
                res+=mp_subarray_zero2i[pre - k];
            }
            mp_subarray_zero2i[pre]++;
        }
        
        return res;
    }
};
```

#### 复杂度分析

- 时间复杂度： $O(n)$，其中 n 为数组的长度。我们遍历数组的时间复杂度为 $O (n)$，中间利用哈希表查询删除的复杂度均为 $O (1)$，因此总时间复杂度为 $O (n)$。

- 空间复杂度：$O (n)$，其中 n 为数组的长度。哈希表在最坏情况下可能有 n 个不同的键值，因此需要 $O (n)$ 的空间复杂度。

## 只出现一次的数字
![[Pasted image 20240221201120.png]]
#位运算
解法，利用异或具有交换律的性质，不同则 0，相同则 1，直接获取最终不同的那个值
```C
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = nums[0];
        for(int i = 1;i<nums.size();i++){
            res^=nums[i];
        }
        return res;
    }
};
```
## 合并区间
![[Pasted image 20240222134706.png]]
- 解题思路
先对所有序列进行排序，接着只需考虑是否将序列接起来或者存入一个新的区间。
```C++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> mergeResult;
        sort(intervals.begin(), intervals.end());
        mergeResult.push_back(intervals[0]);
        for (int i = 1; i < intervals.size(); i++) {
            if (intervals[i][0] <= mergeResult.back()[1])
            {
                mergeResult.back()[1] = max(mergeResult.back()[1],intervals[i][1]);
            }
            else
            {
                mergeResult.push_back(intervals[i]);
            }
        }
        return mergeResult;
    }
};
```
## 最后一个单词的长度
![[Pasted image 20240222153506.png]]
思路：活用 while ()搜索非' '字符
```C++
class Solution {
public:
    int lengthOfLastWord(string s) {
        int index = s.size() - 1;
        while( s[index] == ' ' ){
            index--;
        }
        int cnt = 0;
        while( (index>=0) && (s[index] != ' ') ){
            // cout<<s[index]<<",";
            cnt++;
            index--;
        }
        return cnt;
    }
};
```

## 原地矩阵置零
![[Pasted image 20240224105417.png]]
![[Pasted image 20240224105446.png]]
常量空间解法思路：可以使用第一列与第一行来对整个矩阵中是否含 0 进行标记

```C++
class Solution {
// private:
// void printMatrix(const vector<vector<int>> matrix){
//     for (int i =0; i<matrix.size(); i++) {
//             for (int j = 0; j < matrix[0].size(); j++) {
//                 cout<<matrix[i][j]<<",";
//             }
//             cout<<endl;
//         } 
// }

public:
    void setZeroes(vector<vector<int>>& matrix) {
        int m = matrix.size();
        int n = matrix[0].size();
        int flag_col0 = false;
        for (int i = 0; i < m; i++) {//这一步检测第一列是否有0
            if (!matrix[i][0]) {
                flag_col0 = true;
            }
            for (int j = 1; j < n; j++) {//使用第一列与第一行将非0行列进行标记
                if (!matrix[i][j]) { 
                    matrix[i][0] = matrix[0][j] = 0;
                }
            }
        }
        // printMatrix(matrix);
        for (int i = m - 1; i >= 0; i--) {//后序行遍历数组，防止覆盖掉
            for (int j = 1; j < n; j++) {
                if (!matrix[i][0] || !matrix[0][j]) {
                    matrix[i][j] = 0;
                }
            }
            if (flag_col0) {
                matrix[i][0] = 0;
            }
        }
    }
};

```

## 缺失的第一个整数
![[Pasted image 20240229205010.png]]
```C++
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        vector<bool> Veccnt(nums.size()+2,false);
        for(auto num : nums){
            if( num>0 && num<=nums.size() ){
                Veccnt[num] = true;
            } 
        }
        for(int i = 1;i<=(nums.size()+1);i++){
            if(!Veccnt[i]) return i;
        }
        return 1;   
    }
};
```


## 搜索二维矩阵 1
![[Pasted image 20240320185942.png]]
### 分行二分
```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(),n = matrix[0].size();
        int convx;
        int left = 0;
        int right = m-1;
        if ( target < matrix[0][0] || target> matrix[m-1][n-1]) return false;
        int mid;
        while( left <= right ){
            mid = (left+right)/2;
            // cout<<mid<<endl;
            if(target == matrix[mid][0]){
                return true;
            }
            else if(target > matrix[mid][0]){
                left = mid + 1;
            }
            else if(target < matrix[mid][n-1] ){
                right = mid - 1;
            }
        }
        cout<<"hi"<<left<<", "<<right<<endl;
        convx = target <= matrix[mid][0] ? right: mid;
        // cout<<"hi"<<left<<", "<<right<<", "<<mid<<", "<<convx<<endl;
        left = 0;right = n-1;
        while( left <= right ){
            mid = (left+right)/2;
            if(target == matrix[convx][mid]){
                return true;
            }
            else if(target > matrix[convx][mid]){
                left = mid+ 1 ;
            }
            else if(target < matrix[convx][mid] ){
                right = mid -1;
            }
        }
        return false;
    }
};
```

## 搜索二维矩阵 2
![[Pasted image 20240301202632.png]]
### 二分解法
```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        for (const auto& row: matrix) {
            auto it = lower_bound(row.begin(), row.end(), target);
            if (it != row.end() && *it == target) {
                return true;
            }
        }
        return false;
    }
};

```
复杂度分析
- 时间复杂度 $\because O(m\log n)$。对一行使用二分查找的时间复杂度为 $O(\log n)$,最多需要进行 $m$ 次二分查找。
- 空间复杂度：$O(1)$ 。 

### 最优思路
将该矩阵的右上角作为根，可以认为这是一个比较奇怪的二叉搜索树，故可以采用二叉搜索树的方式来进行搜寻目标值。
```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();
        int x = 0, y = n - 1;
        while (x < m && y >= 0) {
            if (matrix[x][y] == target) {
                return true;
            }
            if (matrix[x][y] > target) {
                --y;
            }
            else {
                ++x;
            }
        }
        return false;
    }
};
```
复杂度分析
- 时间复杂度 $O(m+n)$。对一行使用二分查找的时间复杂度为 $O(\log n)$,最多需要进行 $m$ 次二分查找。
- 空间复杂度：$O(1)$ 。 
## 多数元素

### 解法：摩尔投票
原理：不断维护着出现频率最高的那个值即可，当从整个数组里拿出两个值不一样的数，剩余数组的众数并未发生过改变。
```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int x = 0, votes = 0;
        for (int num : nums){
            if (votes == 0) x = num;
            votes += num == x ? 1 : -1;
        }
        return x;
    }
};

```

## 随机链表的复制
[[#随机链表深拷贝]]
![[Pasted image 20240311102435.png]]
### 自写哈希
```C++
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;
    Node* random;
    
    Node(int _val) {
        val = _val;
        next = NULL;
        random = NULL;
    }
};
*/

class Solution {
public:
    Node* copyRandomList(Node* head) {
        int cnt = 0;
        Node* cur = head;
        unordered_map<Node*,int> mp;

        while( cur!= nullptr){
            mp[cur] = cnt;
            cur = cur->next;
            cnt++;
        }
        cur = head;
        vector<Node*> vec(cnt+1);
        for(int i = 0;i<cnt;i++){
            vec[i] = new Node(cur->val,nullptr,nullptr);
            cur = cur->next;
        }
        cur = head;
        for(int i = 0;i<cnt;i++){
            
            vec[i]->next = vec[i+1];
            if(cur->random == nullptr){
                vec[i]->random = nullptr;
            }
            else{
                int ramdonIdx = mp[cur->random];
                vec[i]->random = vec[ramdonIdx];
            }
            cur = cur->next;
        }
        // vec[cnt] =nullptr;
        return vec[0];
    }
};
```

### 更高效哈希
直接建立点对点的哈希 `map<Node*,Node*>` 来处理数据即可。
```C++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(head == nullptr) return nullptr;
        Node* cur = head;
        unordered_map<Node*, Node*> map;
        // 3. 复制各节点，并建立 “原节点 -> 新节点” 的 Map 映射
        while(cur != nullptr) {
            map[cur] = new Node(cur->val);
            cur = cur->next;
        }
        cur = head;
        // 4. 构建新链表的 next 和 random 指向
        while(cur != nullptr) {
            map[cur]->next = map[cur->next];
            map[cur]->random = map[cur->random];
            cur = cur->next;
        }
        // 5. 返回新链表的头节点
        return map[head];
    }
};
```

## LRU 缓存机制
#双向链表 + #哈希

![[Pasted image 20240318104141.png]]
```C++
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;

public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    
    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    
    void put(int key, int value) {
        if (!cache.count(key)) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode* node = new DLinkedNode(key, value);
            // 添加进哈希表
            cache[key] = node;
            // 添加至双向链表的头部
            addToHead(node);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode* removed = removeTail();
                // 删除哈希表中对应的项
                cache.erase(removed->key);
                // 防止内存泄漏
                delete removed;
                --size;
            }
        }
        else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};

```

## 查找和最小的 K 对数字
![[Pasted image 20240327150253.png]]
```C++
class Solution {
public:
    bool flag = true;
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        vector<vector<int>> ans;
        int n = nums1.size(), m = nums2.size();
        if(n > m) { //始终确保nums1为两数组中长度较少的那个
            swap(nums1, nums2);
            swap(m,n);
            flag = false;
        }
        //定义比较规则
        auto cmp = [&](const auto& a, const auto& b){
            return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];
        };
        priority_queue< pair<int,int>, vector<pair<int,int>>, decltype(cmp) > q(cmp);
        for(int i = 0; i < min(n,k); i++){
            q.push( {i, 0} );
        }
        while(ans.size() < k and q.size()){
            auto [a,b] = q.top();
            q.pop();
            flag ? ans.push_back( {nums1[a], nums2[b]}) : ans.push_back( {nums2[b], nums1[a]});
            if(b + 1 < m) q.push( {a, b + 1} );
        }
        return ans;
    }
};


```
## 丑数 2
![[Pasted image 20240327212100.png]]
### 小根堆
每次取最小的值进行 $*2,*3,*5$，判断没问题的放入堆中
```C++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> factors = {2, 3, 5};
        unordered_set<long> seen;
        priority_queue<long, vector<long>, greater<long>> heap;
        seen.insert(1L);
        heap.push(1L);
        int ugly = 0;
        for (int i = 0; i < n; i++) {
            long curr = heap.top();
            heap.pop();
            ugly = (int)curr;
            // cout<<heap.back()<<endl;
            for (int factor : factors) {
                long next = curr * factor;
                if (!seen.count(next)) {
                    seen.insert(next);
                    heap.push(next);
                }
            }
        }
        return ugly;
    }
};

```