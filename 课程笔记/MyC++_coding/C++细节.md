结构体在为结构体的成员开辟内存空间时，内存空间是连续的
C++三大特性封装、继承、多态
封装：将属性和方法集成在对象之中的方案
**继承**：继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。
**多态的概念**：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态和结果。主要依赖的的是函数重载和虚函数。
# 重要概念
## 编译原理
### 编译四过程
#### 预处理
编译过程的第一步预就是预处理，与处理结束后会产生一个后缀为(.i)的临时文件，这一步由预处理器完成。预处理器主要完成以下任务。

- 删除所有的注释
- 宏扩展
- 文件包含

预处理器会在编译过程中删除所有注释，因为注释不属于程序代码，它们对程序的运行没有特别作用。

宏是使用 **#define** 指令定义的一些常量值或表达式。宏调用会导致宏扩展。预处理器创建一个中间文件，其中一些预先编写的汇编级指令替换定义的表达式或常量（基本上是匹配的标记）。为了区分原始指令和宏扩展产生的程序集指令，在每个宏展开语句中添加了一个“+”号。  
  
**文件包含**  
C语言中的文件包含是在预处理期间_将另一个包含一些预写代码的文件添加到我们的C程序中。它是使用`#include`**指令完成的。在预处理期间包含文件会导致在源代码中添加**文件名**的全部内容，从而替换**`#include<文件名>`指令，从而创建新的中间文件。
#### 编译

C 中的编译阶段使用内置_编译器软件将 （.i） 临时文件转换为具有汇编级指令（低级代码）的**汇编文件** （.s）。为了提高程序的性能，编译器将中间文件转换为程序集文件。  
汇编代码是一种简单的英文语言，用于编写低级指令（在微控制器程序中，我们使用汇编语言）。整个程序代码由编译器软件一次性解析（语法分析），并通过终端窗口告诉我们源代码中存在的任何**语法错误**或**警告**。
这一步骤的存在允许C代码包含内联汇编指令，并允许使用不同的汇编器。
#### 汇编
在这个阶段，汇编器被用来将汇编指令翻译成机器码。
#### 链接
汇编阶段产生的目标代码是由处理器能够理解的机器指令组成的，但程序的某些部分是不符合顺序的或缺失的。为了产生一个可执行的程序，现有的部分必须被重新排列，并把缺失的部分补上。这个过程被称为链接。
链接器将安排目标代码的各个部分，使某些部分的功能能够成功地调用其他部分的功能。它还将添加包含程序所使用的库函数指令的片段。在 "Hello，world！"程序的例子中，链接器将添加puts函数的对象代码。
### 常用依赖构建工具
![[Pasted image 20240517140719.png]]
构建上面的目标需要提供下面的节点文件，然后递归地构建所有文件。
### 链接
静态库和动态库的载入时间是不一样的。
静态库的代码在编译的过程中已经载入到可执行文件中，所以最后生成的可执行文件相对较大。

动态库的代码在可执行程序运行时才载入内存，在编译过程中仅简单的引用，所以最后生成的可执行文件相对较小。

静态库和动态库的最大区别是，静态库链接的时候把库直接加载到程序中,而动态库链接的时候，它只是保留接口，将动态库与程序代码独立，这样就可以提高代码的可复用度和降低程序的耦合度。

**静态库在程序编译时会被连接到目标代码中，程序运行时将不再需要该静态库。
动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入，因此在程序运行时还需要动态库存在。**

无论静态库，还是动态库，都是由.o文件创建的。因此，我们必须将源程序hello.c通过gcc先编译成.o文件。

静态库的名字一般是libxxx.a 在编译的时候直接编译进可执行文件中，运行环境中可以不用存在库文件，但是如果库文件更新了，可执行文件需要重新编译。


## C关键字和关键概念
### 关键字volatile
volatile 指的是强制 CPU 每次都从内存读取数据，目的是防止指定内存被修改，而 CPU 却从缓存读取数据产生的数据不一致问题. 加上 volatile，则告诉编译器不要优化该变量，该变量可能会被其他线程或者中断所改变，是不稳定、易变化的。
使用场景：
1. 多线程都要访问修改的变量
2. 中断访问的变量
3. 硬件寄存器中的变量


### 关键字 const
`const` 用于声明常量，即其值在初始化后不能被修改的变量。这有助于提高程序的安全性和可读性，因为编译器会阻止对这些变量的无意修改。尽管如此，如果通过非正规手段（如强制类型转换指针）尝试修改 const 变量，某些情况下仍可能绕过这一限制，但这通常被视为不良编程实践。
但 `const` 修饰的变量储存位置和普通变量一致
1. const 放在`*`的左边，修饰的是指针指向的内容，保证指针指向的内容不能通过指针来改变。
（但是指针变量本身的内容可变）
```C
const int *p = &n;        n里面的值不能被改变
//*p = 20;        //会报错
```
2. **const 放在`*`的右边**，修饰的是指针变量本身，保证了指针变量的内容不能修改。

（但是可以通过指针改变指针指向的内容）
```C
int *const p = &n;        指向n的行为不能被改变
//p = &m;        //会报错
```
### 关键字 static
static 修饰全局变量或者函数，则代表该函数或者变量只能在本文件中运行，如果用于修饰局部变量，则用于说明该变量会变化。
- **静态局部变量**：使用 `static` 修饰的局部变量存储在全局数据区的静态变量区，即使函数结束，变量的值也会保持，直到程序结束。
- **静态全局变量**：同样存储在全局数据区，但其作用域仅限于定义它的文件（即具有内部链接性），除非显式声明为 `extern` 以扩展其作用域。
### 全局数据区
全局数据区，也常被称为全局区、静态区或者数据段，是程序在`内存`中的一种重要区域，用于存储程序运行所需的特定类型的数据。这个区域主要包含以下几类数据：

1. **全局变量**：在函数外部定义，作用域覆盖整个程序的变量。无论函数是否被调用，全局变量都会被分配空间，并在整个程序执行期间保持其值。
    
2. **静态变量**：包括静态局部变量和静态全局变量。静态局部变量是在函数内部定义，但使用`static`关键字修饰，这意味着它们的生命周期与全局变量相同，即使函数返回，其值仍会被保留。静态全局变量虽然作用域可能受限于定义它的文件，但存储位置仍然在全局数据区。
    
3. **常量数据**：包括使用`const`关键字定义的全局常量（注意，局部const变量可能存储在栈上）。这些数据初始化后不可修改，通常存储在只读数据段，以确保数据的不可变性。
    
4. **文字常量**：如字符串字面量（例如 `"Hello, World!"`）和其他类型的常量表达式，这些也存储在全局数据区的一个特殊部分，称为只读数据段或.rodata段。
    

全局数据区的特点是：

- **生命周期长**：从程序开始执行到结束，这部分内存一直被分配。
- **静态分配**：编译器在编译时就决定了所需的空间大小，并由操作系统在程序加载时分配。
- **系统管理释放**：程序结束时，由操作系统负责回收全局数据区的内存资源。
- **可读性与可写性**：根据数据的性质，可能存储在可读写区域或只读区域。

### C 语言变量访问
读：内存->CPU
写：CPU->内存
### 栈和堆的异同

### 结构体相关
#### 结构体内存对齐
##### 结构体内存对齐规则
1. 第一个成员在与结构体变量偏移量为0的地址处。  
2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。  
对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。  
和机器有关，32 位机器默认的值为 4
3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。  
4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整 
体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
##### 为什么
内存存数据原理：以 32 位计算机为例，CPU利用并行总线存读数据，所有数据必须存在每个交互 chip 的 bank 的相同位置。cpu同时读取四个数据拼接成一整个数据。
所有数据访问有着严格的数据对齐，即每次只能访问四个字节，这 4 字节便是最大对齐数。
##### 总结
1. 平台原因 (移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。
2. 性能原因：数据结构 (尤其是栈) 应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。本质上是一种时间换空间的操作。

#### union
union 占用内存大小只与结构最大的元素有关。

## 嵌软重要概念
### DMA
DMA，全称 Direct Memory Access，即直接存储器访问。

DMA 传输将数据从一个地址空间复制到另一个地址空间，提供在外设和存储器之间或者存储器和存储器之间的高速数据传输。当 CPU 初始化这个传输动作，传输动作本身是由 DMA 控制器来实现和完成的。DMA 传输方式无需 CPU 直接控制传输，也没有中断处理方式那样保留现场和恢复现场过程，通过硬件为 RAM 和 IO 设备开辟一条直接传输数据的通道，使得 CPU 的效率大大提高。

### 常用重要函数
#### C
##### **strlen**
而strlen是一个函数，用来计算字符串长度。求字符串长度，返回计算的字符串的实际长度，即不包括`\0`在内的实际字符的长度。
##### **sizeof**
sizeof是C语言中的一个单目运算符，用来计算数据类型所占空间的大小，单位为字节
##### **memset**
memset 的作用是在一段内存块中填充某个给定的值。  
```C
Void *memset (void *str, int c, size_t n)
```

解释：复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符。
作用：是在一段内存块中填充某个给定的值，它是对较大的结构体或数组进行清零操作的一种最快方法
头文件：C 中 `#include <string.h>`，
看着介绍其实函数作用非常简单，就是用于初始化，但是需要注意的是 memset 赋值的时候是按**字节**赋值，是将参数化成二进制之后填入一个字节。

##### **memcpy**
功能是从源内存地址的起始位置开始拷贝若干个字节到目标内存地址中。  
```C
void *memcpy(void *dest, const void *src, size_t n);
```
它的功能是从 src 的开始位置拷贝 n 个字节的数据到 dest。如果 dest 存在数据，将会被覆盖。memcpy 函数的返回值是 dest 的指针。memcpy 函数定义在 `string.h` 头文件里。
###### memcpy 实现
自己实现的时候，最简单的方法是用指针按照字节顺序复制即可。但是性能太低。
`memcpy` 函数的底层实现通常考虑了性能和安全性，特别是处理内存重叠的情况。

基本思路

1. **参数检查**：首先检查目标地址`dest`和源地址`source`是否有效，以及要复制的字节数`n`是否为正数。无效参数可能会导致函数立即返回或抛出异常（取决于实现）。
    
2. **内存重叠处理**：如果`dest`和`source`指向的内存区域可能重叠（即复制过程中源和目标区域有交集），实现需特别小心以避免数据损坏。一种简单而安全但效率较低的方法是对每个字节进行逐个复制。更高效的实现会根据重叠情况选择不同的复制方向。
    
3. **批量复制**：对于不重叠的情况，为了提高效率，通常不是按字节复制，而是利用处理器的字长进行批量复制。例如，在32位系统上，可以每次复制4字节。更高级的实现可能会使用更宽的 SIMD 指令（单指令多数据）来同时复制多个字节。

#### 考虑内存重叠的实现

对于内存可能重叠的情况，一种策略是如果`dest`在`source`之后，从高地址向低地址复制，反之则从低到高复制，这样可以避免源数据被覆盖。

```C
void* memcpy(void* dest, const void* src, size_t n)
{
    char* d = (char*)dest;
    const char* s = (const char*)src;
    
    if (d < s && s < d + n) { // 检查是否从后向前复制更安全
        s += n - 1;
        d += n - 1;//指向尾部
        while (n--)
            *d-- = *s--;
    } else {
        while (n--)
            *d++ = *s++;
    }
    return dest;
}
```
## 面对对象
### 虚函数

**什么是虚函数:**
虚函数是指一个类中你希望重载的成员函数 ，当你用一个基类指针或引用指向一个继承类对象的时候，调用一个虚函数时, 实际调用的是继承类的版本。



## 指针相关

### 函数指针
[深入理解函数指针与指针函数](https://blog.csdn.net/qq_27825451/article/details/103081289)
### 函数指针
所谓函数指针即定义一个指向函数的指针变量，定义的格式如下：
```C
int (*p)(int x, int  y);  //注意：这里的括号不能掉，因为括号()的运算优先级比解引用运算符*高
```
这个函数的类型是有两个整型参数，返回值是个整型。对应的**函数指针类型**：
```C
int (*) (int a, int b);  
```
对应的函数指针定义：
```C++
int (*p)(int x, int  y);  //参数名可以去掉，并且通常都是去掉的。这样指针p就可以保存函数类型为两个整型参数，返回值是整型的函数地址了。
int (*p)(int, int);
```
我们一般可以这么使用，通过函数指针调用函数：
```C
int maxValue (int a, int b) {
    return a > b ? a : b;
}    
 
int (*p)(int, int) = NULL;  //定义一个与maxValue兼容的指针
p = maxValue;
p(20, 45);  //通过指针调用
```
### 指针函数
指针函数：指的是函数的返回值是一个指针，比如我的函数返回的是一个指向整数 int 的指针，定义格式如下：
```C
int *fun(int a,int b); //注意这里的*与P之间是没有括号的，所以含义是函数p(int,int)会返回一个（int *）指针
```

![[Pasted image 20240320193744.png]]

### 将函数作为参数
上述内容是函数指针的基础用法，很多语言都支持函数作为参数和返回值，典型的像 python 动态语言，C 语言当然也可以了，没错，其实函数指针更重要的意义在于函数回调。

比如，我们实现了集中大小排列的函数
```C++
BOOL compareGreater(int number, int compareNumber) {
    return number > compareNumber;
}   

BOOL compareLess(int number, int compareNumber) {
    return number < compareNumber;
}
```

我们可以将这个函数作为 `compareNumberFunction` 的一个参数进行传递（没错，函数可以作为参数），那么我们就需要一个函数指针获取函数的地址，从而在 `compareNumberFunction` 内部进行对函数的调用，于是，`compareNumberFunction` 函数的定义变成了这样：
```C++
void compareNumberFunction(int *numberArray, int count, int compareNumber, BOOL (*p)(int, int)) 
{
    for (int i = 0; i < count; i++) 
    {
        if (p(*(numberArray + i), compareNumber)) //通过函数指针调用比较函数
        {
            printf("%d\n", *(numberArray + i));
        }
    }
}
```
所以，函数回调本质为函数指针作为函数参数，函数调用时传入函数地址，这使我们的代码变得更加灵活，可复用性更强。

函数指针宏定义
```C++
typedef int (*Pointer)(int,int); 	//Pointer等价于类型 int (*)(int,int)，int (*)(int,int)是类型名，Pointer是别名
Pointer p = add; //但是这里由于C语言语法的关系，我们不能写成 int (*)(int,int) Pointer 这样的形式
 
//函数本身又返回一个指向int的指针
typedef int *(*Pointer)(int,int); 	//Pointer等价于类型 int *(*)(int,int)，int *(*)(int,int)是类型名，Pointer是别名
Pointer p = add;
```

### C++11 智能指针

# C++对象相关
## 成员函数 cosnt 修饰

`const`成员函数的定义:需要在函数的声明及定义的后边加上const关键字
- const 对象只能调用 const 成员函数
- const 成员函数只能调用 const 成员函数
- const 成员函数中不能改变成员变量的值

# C++底层相关
## 迭代容器
### Map
#### Map 的[]索引与 insert ()区别
如果一个 key 存在， `operator[]` 对这个 key-value 进行重写  
如果一个 key 存在， `insert()` 不会对原来的 key-value 进行重写