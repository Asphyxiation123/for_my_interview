学习路线
1. 应用开发基础
2. 驱动开发基础
3. 实战项目

# Linux 驱动开发流程
## Linux 


## Linux驱动分类
### 字符设备 (Char Device)
- 字符(char)设备是个能够像字节流（类似文件）一样被访问的设备。
- 对字符设备发出读/写请求时，实际的硬件I/O操作一般紧接着发生。
- 字符设备驱动程序通常至少要实现open、close、read和write系统调用。
- 比如我们常见的lcd、触摸屏、键盘、led、串口等等，他们一般对应具体的硬件都是进行出具的采集、处理、传输。
### 块设备 (Block Device)
- 一个块设备驱动程序主要通过传输固定大小的数据（一般为 512 或 1 k）来访问设备。
- 块设备通过 buffer cache (内存缓冲区) 访问，可以随机存取，即：任何块都可以读写，不必考虑它在设备的什么地方。
- 块设备可以通过它们的设备特殊文件访问，但是更常见的是通过文件系统进行访问。
- 只有一个块设备可以支持一个安装的文件系统。
- 比如我们常见的电脑硬盘、SD 卡、U 盘、光盘等。
### 网络设备 (Net Device)
- 任何网络事务都经过一个网络接口形成，即一个能够和其他主机交换数据的设备。
- 访问网络接口的方法仍然是给它们分配一个唯一的名字（比如 eth 0），但这个名字在文件系统中不存在对应的节点。
- 内核和网络设备驱动程序间的通信，完全不同于内核和字符以及块驱动程序之间的通信，内核调用一套和数据包传输相关的函（socket 函数）而不是 `read`、`write` 等。
- 比如我们常见的网卡设备、蓝牙设备。

## 驱动程序的功能

1. 对设备初始化和释放
2. 把数据从内核传送到硬件和从硬件读取数据
3. 读取应用程序传送给设备文件的数据和回送应用程序请求的数据
4. 检测和处理设备出现的错误
## Linux 驱动开发流程
![在这里插入图片描述](https://img-blog.csdnimg.cn/8a8809f6c68c40b2a28cde3585d01635.png)


![[Pasted image 20240420000839.png]]
```C++
struct file_opreations{
	.open = fun_open;
	.read = fun_read;
	.write = fun_write
};

//注册函数，入口函数,main函数
void register_chrdev(0,name,&led_drv)
//出口函数
void unregister_chrdev(0,name,&led_drv)
```


- Linux 下进行驱动开发，完全将驱动程序与应用程序隔开，中间通过**C 标准库函数**以及**系统调用**完成驱动层和应用层的数据交换。

1. 加载一个驱动模块，产生一个**设备文件**，有**唯一对应的 inode 结构体**
2. 应用层调用**open 函数**打开设备文件，对于上层 open 调用到内核时会发生一次**软中断**，从用户空间**进入到内核空间**。
3. Open 会调用到**sys_open (内核函数)**，sys_open 根据**文件的地址**，找到设备文件对应的**struct inode 结构体**描述的信息，可以知道接下来要操作的设备类型（字符设备还是块设备），还会**分配一个 struct file 结构体**。
4. 根据**struct inode 结构体里面记录的主设备号和次设备号**，在**驱动链表**(管理所有设备的驱动) 里面，根据找到**字符设备驱动**
5. 每个字符设备都有一个**struct cdev 结构体**。此结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的**操作函数接口**
6. **找到 struct cdev 结构体**后，linux 内核就会将 struct cdev 结构体所在的**内存空间首地址**记录在**struct inode 结构体 i_cdev 成员**中，将 struct cdev 结构体中的记录的函**数操作接口地址记录**在**struct file 结构体的 f_ops 成员中**。
7. 执行**xxx_open 驱动函数**